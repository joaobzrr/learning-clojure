<p><img src="cover.jpeg" /></p>
<p><span id="titlepage.xhtml"></span></p>
<div>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="100%" height="100%" viewbox="0 0 566 749" preserveaspectratio="xMidYMid meet">
<image width="566" height="749" xlink:href="cover.jpeg"></image>
</svg>
</div>
<p><span id="text_part0000.html"></span></p>
<h1 class="h" id="text_part0000.html_title"><span
id="text_part0000.html_page_iii" class="calibre1"></span><strong>CLOJURE
FOR THE BRAVE AND TRUE</strong></h1>
<p><strong>learn the ultimate language and become a better
programmer</strong></p>
<div class="pub">
<img src="images_00006.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0001.html"></span></p>
<p><span id="text_part0001.html_page_iv" class="calibre4"></span><span
id="text_part0001.html_copy" class="calibre4"></span><strong>CLOJURE FOR
THE BRAVE AND TRUE.</strong> Copyright © 2015 by Daniel
Higginbotham.</p>
<p>All rights reserved. No part of this work may be reproduced or
transmitted in any form or by any means, electronic or mechanical,
including photocopying, recording, or by any information storage or
retrieval system, without the prior written permission of the copyright
owner and the publisher.</p>
<p>Printed in USA</p>
<p>First printing</p>
<p>19 18 17 16 15       1 2 3 4 5 6 7 8 9</p>
<p>ISBN-10: 1-59327-591-9<br />
ISBN-13: 978-1-59327-591-4</p>
<p>Publisher: William Pollock<br />
Production Editor: Riley Hoffman<br />
Cover Design: Beth Middleworth and Daniel and Jessica Higginbotham<br />
Cover and Interior Illustrations: Jessica Higginbotham<br />
Interior Design: Octopod Studios<br />
Developmental Editors: Hayley Baker and Seph Kramer<br />
Technical Reviewer: Alan Dipert<br />
Copyeditor: Anne Marie Walker<br />
Compositors: Riley Hoffman and Susan Glinert Stevens<br />
Proofreader: Emelie Burnette</p>
<p>For information on distribution, translations, or bulk sales, please
contact No Starch Press, Inc. directly:</p>
<p>No Starch Press, Inc.<br />
245 8th Street, San Francisco, CA 94103<br />
phone: 415.863.9900; <a href="mailto:info@nostarch.com"
class="calibre4">info@nostarch.com</a><br />
<a href="http://www.nostarch.com"
class="calibre4">www.nostarch.com</a></p>
<p><em>Library of Congress Cataloging-in-Publication Data</em></p>
<p><span class="literal">Higginbotham, Daniel.</span><br />
<span class="literal">  Clojure for the brave and true: learn the
ultimate language and become a better programmer / by</span><br />
<span class="literal">Daniel Higginbotham.</span><br />
<span class="literal">       pages cm</span><br />
<span class="literal">  Includes index.</span><br />
<span class="literal">  Summary: "Guide to the functional programming
language Clojure. Teaches tools and techniques for writing programs in
Clojure. Covers how to wield and compose Clojure’s core functions; use
Emacs for Clojure development; write macros to modify the Clojure
programming language; and use Clojure’s tools to simplify concurrency
and parallel programming"-- Provided by publisher.</span><br />
<span class="literal">  ISBN 978-1-59327-591-4 -- ISBN
1-59327-591-9</span><br />
<span class="literal">1. Clojure (Computer program language) I.
Title.</span><br />
<span class="literal"> QA76.73.C565H54 2015</span><br />
<span class="literal"> 005.13’3--dc23</span><br />
<span
class="literal">                                                                                2015014205</span></p>
<p>No Starch Press and the No Starch Press logo are registered
trademarks of No Starch Press, Inc. Other product and company names
mentioned herein may be the trademarks of their respective owners.
Rather than use a trademark symbol with every occurrence of a
trademarked name, we are using the names only in an editorial fashion
and to the benefit of the trademark owner, with no intention of
infringement of the trademark.</p>
<p>The information in this book is distributed on an “As Is” basis,
without warranty. While every precaution has been taken in the
preparation of this work, neither the author nor No Starch Press, Inc.
shall have any liability to any person or entity with respect to any
loss or damage caused or alleged to be caused directly or indirectly by
the information contained in it.</p>
<p><span id="text_part0002.html"></span></p>
<h2 class="h2a" id="text_part0002.html_pref01"><span
id="text_part0002.html_page_v" class="calibre1"></span><strong>About the
Author</strong></h2>
<p>Daniel Higginbotham has been a professional programmer for 11 years,
half of that at McKinsey &amp; Company, where he used Clojure to build
mobile and web applications. He has also contributed to the curriculum
for ClojureBridge, an organization that offers free, beginner-friendly
Clojure workshops for women. Daniel blogs about life and programming at
<em><a href="http://flyingmachinestudios.com/"
class="calibre4">http://flyingmachinestudios.com/</a></em>, and can be
found on Twitter, @nonrecursive. He lives in Durham, North Carolina,
with his wife and four cats.</p>
<p><span id="text_part0003.html"></span></p>
<h2 class="h2a" id="text_part0003.html_pref02"><strong>About the
Technical Reviewer</strong></h2>
<p>Alan Dipert first heard about Lisp when he was 10 years old. After it
was described to him, he said “That sounds dumb.” In 2009, he learned
Clojure and revised his opinion. Alan has designed and built Clojure
systems, conducted Clojure trainings, and spoken at Clojure conferences.
You can keep track of Alan’s work and recent opinions by visiting <em><a
href="http://tailrecursion.com/~alan"
class="calibre4">http://tailrecursion.com/~alan</a></em> or by following
him on Twitter, @alandipert.<span id="text_part0003.html_page_vi"
class="calibre4"></span></p>
<p><span id="text_part0004.html"></span></p>
<p><span id="text_part0004.html_page_vii" class="calibre4"></span><span
id="text_part0004.html_ded01" class="calibre4"></span>For Jess <span
id="text_part0004.html_page_viii" class="calibre4"></span></p>
<p><span id="text_part0005.html"></span></p>
<h2 class="h1" id="text_part0005.html_toc"><span
id="text_part0005.html_page_ix" class="calibre1"></span><strong>Brief
Contents</strong></h2>
<p><a href="#text_part0007.html_pref03" class="calibre4">Foreword by
Alan Dipert</a></p>
<p><a href="#text_part0008.html_pref04"
class="calibre4">Acknowledgments</a></p>
<p><a href="#text_part0009.html_ch00"
class="calibre4">Introduction</a></p>
<p><a href="#text_part0010.html_part01" class="calibre1"><strong>Part I:
Environment Setup</strong></a></p>
<p><a href="#text_part0011.html_ch01" class="calibre4">Chapter 1:
Building, Running, and the REPL</a></p>
<p><a href="#text_part0012.html_ch02" class="calibre4">Chapter 2: How to
Use Emacs, an Excellent Clojure Editor</a></p>
<p><a href="#text_part0013.html_part02" class="calibre1"><strong>Part
II: Language Fundamentals</strong></a></p>
<p><a href="#text_part0014.html_ch03" class="calibre4">Chapter 3: Do
Things: A Clojure Crash Course</a></p>
<p><a href="#text_part0015.html_ch04" class="calibre4">Chapter 4: Core
Functions in Depth</a></p>
<p><a href="#text_part0016.html_ch05" class="calibre4">Chapter 5:
Functional Programming</a></p>
<p><a href="#text_part0017.html_ch06" class="calibre4">Chapter 6:
Organizing Your Project: A Librarian’s Tale</a></p>
<p><a href="#text_part0018.html_ch07" class="calibre4">Chapter 7:
Clojure Alchemy: Reading, Evaluation, and Macros</a></p>
<p><a href="#text_part0019.html_ch08" class="calibre4">Chapter 8:
Writing Macros</a></p>
<p><a href="#text_part0020.html_part03" class="calibre1"><strong>Part
III: Advanced Topics</strong></a></p>
<p><a href="#text_part0021.html_ch09" class="calibre4">Chapter 9: The
Sacred Art of Concurrent and Parallel Programming</a></p>
<p><a href="#text_part0022.html_ch10" class="calibre4">Chapter 10:
Clojure Metaphysics: Atoms, Refs, Vars, and Cuddle Zombies</a></p>
<p><a href="#text_part0023.html_ch11" class="calibre4">Chapter 11:
Mastering Concurrent Processes with core.async</a></p>
<p><a href="#text_part0024.html_ch12" class="calibre4">Chapter 12:
Working with the JVM</a></p>
<p><a href="#text_part0025.html_ch13" class="calibre4">Chapter 13:
Creating and Extending Abstractions with Multimethods, Protocols, and
Records</a></p>
<p><span id="text_part0005.html_page_x" class="calibre4"></span><a
href="#text_part0026.html_app01" class="calibre4">Appendix A: Building
and Developing with Leiningen</a></p>
<p><a href="#text_part0027.html_app02" class="calibre4">Appendix B:
Boot, the Fancy Clojure Build Framework</a></p>
<p><a href="#text_part0028.html_app03"
class="calibre4">Farewell!</a></p>
<p><a href="#text_part0029.html_index" class="calibre4">Index</a></p>
<p><span id="text_part0006.html"></span></p>
<h2 class="h1" id="text_part0006.html_toc01"><span
id="text_part0006.html_page_xi" class="calibre1"></span><strong>Contents
in Detail</strong></h2>
<p><a href="#text_part0007.html_pref03"
class="calibre1"><strong>Foreword by Alan Dipert</strong></a></p>
<p><a href="#text_part0008.html_pref04"
class="calibre1"><strong>Acknowledgments</strong></a></p>
<p><a href="#text_part0009.html_ch00"
class="calibre1"><strong>Introduction</strong></a></p>
<p><a href="#text_part0009.html_ch00lev1sec1" class="calibre4">Learning
a New Programming Language: A Journey Through the Four
Labyrinths</a></p>
<p><a href="#text_part0009.html_ch00lev1sec2" class="calibre4">How This
Book Is Organized</a></p>
<p><a href="#text_part0009.html_ch00lev2sec1" class="calibre4">Part I:
Environment Setup</a></p>
<p><a href="#text_part0009.html_ch00lev2sec2" class="calibre4">Part II:
Language Fundamentals</a></p>
<p><a href="#text_part0009.html_ch00lev2sec3" class="calibre4">Part III:
Advanced Topics</a></p>
<p><a href="#text_part0009.html_ch00lev1sec3" class="calibre4">The
Code</a></p>
<p><a href="#text_part0009.html_ch00lev1sec4" class="calibre4">The
Journey Begins!</a></p>
<p><a href="#text_part0010.html_part01" class="calibre1"><strong>Part I:
Environment Setup</strong></a></p>
<p><a href="#text_part0011.html_ch01" class="calibre1"><strong>1:
Building, Running, and the REPL</strong></a></p>
<p><a href="#text_part0011.html_ch01lev1sec1" class="calibre4">First
Things First: What Is Clojure?</a></p>
<p><a href="#text_part0011.html_ch01lev1sec2"
class="calibre4">Leiningen</a></p>
<p><a href="#text_part0011.html_ch01lev2sec1" class="calibre4">Creating
a New Clojure Project</a></p>
<p><a href="#text_part0011.html_ch01lev2sec2" class="calibre4">Running
the Clojure Project</a></p>
<p><a href="#text_part0011.html_ch01lev2sec3" class="calibre4">Building
the Clojure Project</a></p>
<p><a href="#text_part0011.html_ch01lev2sec4" class="calibre4">Using the
REPL</a></p>
<p><a href="#text_part0011.html_ch01lev1sec3" class="calibre4">Clojure
Editors</a></p>
<p><a href="#text_part0011.html_ch01lev1sec4"
class="calibre4">Summary</a></p>
<p><a href="#text_part0012.html_ch02" class="calibre1"><strong>2: How to
Use Emacs, an Excellent Clojure Editor</strong></a></p>
<p><a href="#text_part0012.html_ch02lev1sec1"
class="calibre4">Installation</a></p>
<p><a href="#text_part0012.html_ch02lev1sec2"
class="calibre4">Configuration</a></p>
<p><a href="#text_part0012.html_ch02lev1sec3" class="calibre4">Emacs
Escape Hatch</a></p>
<p><a href="#text_part0012.html_ch02lev1sec4" class="calibre4">Emacs
Buffers</a></p>
<p><a href="#text_part0012.html_ch02lev1sec5" class="calibre4">Working
with Files</a></p>
<p><a href="#text_part0012.html_ch02lev1sec6" class="calibre4">Key
Bindings and Modes</a></p>
<p><a href="#text_part0012.html_ch02lev2sec1" class="calibre4">Emacs Is
a Lisp Interpreter</a></p>
<p><a href="#text_part0012.html_ch02lev2sec2"
class="calibre4">Modes</a></p>
<p><a href="#text_part0012.html_ch02lev2sec3"
class="calibre4">Installing Packages</a></p>
<p><a href="#text_part0012.html_ch02lev1sec7" class="calibre4">Core
Editing Terminology and Key Bindings</a></p>
<p><a href="#text_part0012.html_ch02lev2sec4"
class="calibre4">Point</a></p>
<p><a href="#text_part0012.html_ch02lev2sec5"
class="calibre4">Movement</a></p>
<p><a href="#text_part0012.html_ch02lev2sec6" class="calibre4">Selection
with Regions</a></p>
<p><a href="#text_part0012.html_ch02lev2sec7" class="calibre4">Killing
and the Kill Ring</a></p>
<p><a href="#text_part0012.html_ch02lev2sec8" class="calibre4">Editing
and Help</a></p>
<p><a href="#text_part0012.html_ch02lev1sec8" class="calibre4">Using
Emacs with Clojure</a></p>
<p><a href="#text_part0012.html_ch02lev2sec9" class="calibre4">Fire Up
Your REPL!</a></p>
<p><a href="#text_part0012.html_ch02lev2sec10"
class="calibre4">Interlude: Emacs Windows and Frames</a></p>
<p><span id="text_part0006.html_page_xii" class="calibre4"></span><a
href="#text_part0012.html_ch02lev2sec11" class="calibre4">A Cornucopia
of Useful Key Bindings</a></p>
<p><a href="#text_part0012.html_ch02lev2sec12" class="calibre4">How to
Handle Errors</a></p>
<p><a href="#text_part0012.html_ch02lev2sec13"
class="calibre4">Paredit</a></p>
<p><a href="#text_part0012.html_ch02lev1sec9" class="calibre4">Continue
Learning</a></p>
<p><a href="#text_part0012.html_ch02lev1sec10"
class="calibre4">Summary</a></p>
<p><a href="#text_part0013.html_part02" class="calibre1"><strong>Part
II: Language Fundamentals</strong></a></p>
<p><a href="#text_part0014.html_ch03" class="calibre1"><strong>3: Do
Things: A Clojure Crash Course</strong></a></p>
<p><a href="#text_part0014.html_ch03lev1sec1"
class="calibre4">Syntax</a></p>
<p><a href="#text_part0014.html_ch03lev2sec1"
class="calibre4">Forms</a></p>
<p><a href="#text_part0014.html_ch03lev2sec2" class="calibre4">Control
Flow</a></p>
<p><a href="#text_part0014.html_ch03lev2sec3" class="calibre4">Naming
Values with def</a></p>
<p><a href="#text_part0014.html_ch03lev1sec2" class="calibre4">Data
Structures</a></p>
<p><a href="#text_part0014.html_ch03lev2sec4"
class="calibre4">Numbers</a></p>
<p><a href="#text_part0014.html_ch03lev2sec5"
class="calibre4">Strings</a></p>
<p><a href="#text_part0014.html_ch03lev2sec6"
class="calibre4">Maps</a></p>
<p><a href="#text_part0014.html_ch03lev2sec7"
class="calibre4">Keywords</a></p>
<p><a href="#text_part0014.html_ch03lev2sec8"
class="calibre4">Vectors</a></p>
<p><a href="#text_part0014.html_ch03lev2sec9"
class="calibre4">Lists</a></p>
<p><a href="#text_part0014.html_ch03lev2sec10"
class="calibre4">Sets</a></p>
<p><a href="#text_part0014.html_ch03lev2sec11"
class="calibre4">Simplicity</a></p>
<p><a href="#text_part0014.html_ch03lev1sec3"
class="calibre4">Functions</a></p>
<p><a href="#text_part0014.html_ch03lev2sec12" class="calibre4">Calling
Functions</a></p>
<p><a href="#text_part0014.html_ch03lev2sec13" class="calibre4">Function
Calls, Macro Calls, and Special Forms</a></p>
<p><a href="#text_part0014.html_ch03lev2sec14" class="calibre4">Defining
Functions</a></p>
<p><a href="#text_part0014.html_ch03lev2sec15"
class="calibre4">Anonymous Functions</a></p>
<p><a href="#text_part0014.html_ch03lev2sec16"
class="calibre4">Returning Functions</a></p>
<p><a href="#text_part0014.html_ch03lev1sec4" class="calibre4">Pulling
It All Together</a></p>
<p><a href="#text_part0014.html_ch03lev2sec17" class="calibre4">The
Shire’s Next Top Model</a></p>
<p><a href="#text_part0014.html_ch03lev2sec18"
class="calibre4">let</a></p>
<p><a href="#text_part0014.html_ch03lev2sec19"
class="calibre4">loop</a></p>
<p><a href="#text_part0014.html_ch03lev2sec20" class="calibre4">Regular
Expressions</a></p>
<p><a href="#text_part0014.html_ch03lev2sec21"
class="calibre4">Symmetrizer</a></p>
<p><a href="#text_part0014.html_ch03lev2sec22" class="calibre4">Better
Symmetrizer with reduce</a></p>
<p><a href="#text_part0014.html_ch03lev2sec23" class="calibre4">Hobbit
Violence</a></p>
<p><a href="#text_part0014.html_ch03lev1sec5"
class="calibre4">Summary</a></p>
<p><a href="#text_part0014.html_ch03lev1sec6"
class="calibre4"><strong>Exercises</strong></a></p>
<p><a href="#text_part0015.html_ch04" class="calibre1"><strong>4: Core
Functions in Depth</strong></a></p>
<p><a href="#text_part0015.html_ch04lev1sec1"
class="calibre4">Programming to Abstractions</a></p>
<p><a href="#text_part0015.html_ch04lev2sec1" class="calibre4">Treating
Lists, Vectors, Sets, and Maps as Sequences</a></p>
<p><a href="#text_part0015.html_ch04lev2sec2" class="calibre4">first,
rest, and cons</a></p>
<p><a href="#text_part0015.html_ch04lev2sec3"
class="calibre4">Abstraction Through Indirection</a></p>
<p><a href="#text_part0015.html_ch04lev1sec2" class="calibre4">Seq
Function Examples</a></p>
<p><a href="#text_part0015.html_ch04lev2sec4"
class="calibre4">map</a></p>
<p><a href="#text_part0015.html_ch04lev2sec5"
class="calibre4">reduce</a></p>
<p><a href="#text_part0015.html_ch04lev2sec6" class="calibre4">take,
drop, take-while, and drop-while</a></p>
<p><span id="text_part0006.html_page_xiii" class="calibre4"></span><a
href="#text_part0015.html_ch04lev2sec7" class="calibre4">filter and
some</a></p>
<p><a href="#text_part0015.html_ch04lev2sec8" class="calibre4">sort and
sort-by</a></p>
<p><a href="#text_part0015.html_ch04lev2sec9"
class="calibre4">concat</a></p>
<p><a href="#text_part0015.html_ch04lev1sec3" class="calibre4">Lazy
Seqs</a></p>
<p><a href="#text_part0015.html_ch04lev2sec10"
class="calibre4">Demonstrating Lazy Seq Efficiency</a></p>
<p><a href="#text_part0015.html_ch04lev2sec11" class="calibre4">Infinite
Sequences</a></p>
<p><a href="#text_part0015.html_ch04lev1sec4" class="calibre4">The
Collection Abstraction</a></p>
<p><a href="#text_part0015.html_ch04lev2sec12"
class="calibre4">into</a></p>
<p><a href="#text_part0015.html_ch04lev2sec13"
class="calibre4">conj</a></p>
<p><a href="#text_part0015.html_ch04lev1sec5" class="calibre4">Function
Functions</a></p>
<p><a href="#text_part0015.html_ch04lev2sec14"
class="calibre4">apply</a></p>
<p><a href="#text_part0015.html_ch04lev2sec15"
class="calibre4">partial</a></p>
<p><a href="#text_part0015.html_ch04lev2sec16"
class="calibre4">complement</a></p>
<p><a href="#text_part0015.html_ch04lev1sec6" class="calibre4">A Vampire
Data Analysis Program for the FWPD</a></p>
<p><a href="#text_part0015.html_ch04lev1sec7"
class="calibre4">Summary</a></p>
<p><a href="#text_part0015.html_ch04lev1sec8"
class="calibre4"><strong>Exercises</strong></a></p>
<p><a href="#text_part0016.html_ch05" class="calibre1"><strong>5:
Functional Programming</strong></a></p>
<p><a href="#text_part0016.html_ch05lev1sec1" class="calibre4">Pure
Functions: What and Why</a></p>
<p><a href="#text_part0016.html_ch05lev2sec1" class="calibre4">Pure
Functions Are Referentially Transparent</a></p>
<p><a href="#text_part0016.html_ch05lev2sec2" class="calibre4">Pure
Functions Have No Side Effects</a></p>
<p><a href="#text_part0016.html_ch05lev1sec2" class="calibre4">Living
with Immutable Data Structures</a></p>
<p><a href="#text_part0016.html_ch05lev2sec3" class="calibre4">Recursion
Instead of for/while</a></p>
<p><a href="#text_part0016.html_ch05lev2sec4" class="calibre4">Function
Composition Instead of Attribute Mutation</a></p>
<p><a href="#text_part0016.html_ch05lev1sec3" class="calibre4">Cool
Things to Do with Pure Functions</a></p>
<p><a href="#text_part0016.html_ch05lev2sec5"
class="calibre4">comp</a></p>
<p><a href="#text_part0016.html_ch05lev2sec6"
class="calibre4">memoize</a></p>
<p><a href="#text_part0016.html_ch05lev1sec4" class="calibre4">Peg
Thing</a></p>
<p><a href="#text_part0016.html_ch05lev2sec7"
class="calibre4">Playing</a></p>
<p><a href="#text_part0016.html_ch05lev2sec8" class="calibre4">Code
Organization</a></p>
<p><a href="#text_part0016.html_ch05lev2sec9" class="calibre4">Creating
the Board</a></p>
<p><a href="#text_part0016.html_ch05lev2sec10" class="calibre4">Moving
Pegs</a></p>
<p><a href="#text_part0016.html_ch05lev2sec11"
class="calibre4">Rendering and Printing the Board</a></p>
<p><a href="#text_part0016.html_ch05lev2sec12" class="calibre4">Player
Interaction</a></p>
<p><a href="#text_part0016.html_ch05lev1sec5"
class="calibre4">Summary</a></p>
<p><a href="#text_part0016.html_ch05lev1sec6"
class="calibre4"><strong>Exercises</strong></a></p>
<p><a href="#text_part0017.html_ch06" class="calibre1"><strong>6:
Organizing Your Project: A Librarian’s Tale</strong></a></p>
<p><a href="#text_part0017.html_ch06lev1sec1" class="calibre4">Your
Project as a Library</a></p>
<p><a href="#text_part0017.html_ch06lev1sec2" class="calibre4">Storing
Objects with def</a></p>
<p><a href="#text_part0017.html_ch06lev1sec3" class="calibre4">Creating
and Switching to Namespaces</a></p>
<p><a href="#text_part0017.html_ch06lev2sec1"
class="calibre4">refer</a></p>
<p><a href="#text_part0017.html_ch06lev2sec2"
class="calibre4">alias</a></p>
<p><a href="#text_part0017.html_ch06lev1sec4" class="calibre4">Real
Project Organization</a></p>
<p><a href="#text_part0017.html_ch06lev2sec3" class="calibre4">The
Relationship Between File Paths and Namespace Names</a></p>
<p><a href="#text_part0017.html_ch06lev2sec4" class="calibre4">Requiring
and Using Namespaces</a></p>
<p><a href="#text_part0017.html_ch06lev2sec5" class="calibre4">The ns
Macro</a></p>
<p><a href="#text_part0017.html_ch06lev1sec5" class="calibre4">To Catch
a Burglar</a></p>
<p><a href="#text_part0017.html_ch06lev1sec6"
class="calibre4">Summary</a></p>
<p><span id="text_part0006.html_page_xiv" class="calibre1"></span><a
href="#text_part0018.html_ch07" class="calibre1"><strong>7: Clojure
Alchemy: Reading, Evaluation, and Macros</strong></a></p>
<p><a href="#text_part0018.html_ch07lev1sec1" class="calibre4">An
Overview of Clojure’s Evaluation Model</a></p>
<p><a href="#text_part0018.html_ch07lev1sec2" class="calibre4">The
Reader</a></p>
<p><a href="#text_part0018.html_ch07lev2sec1"
class="calibre4">Reading</a></p>
<p><a href="#text_part0018.html_ch07lev2sec2" class="calibre4">Reader
Macros</a></p>
<p><a href="#text_part0018.html_ch07lev1sec3" class="calibre4">The
Evaluator</a></p>
<p><a href="#text_part0018.html_ch07lev2sec3" class="calibre4">These
Things Evaluate to Themselves</a></p>
<p><a href="#text_part0018.html_ch07lev2sec4"
class="calibre4">Symbols</a></p>
<p><a href="#text_part0014.html_ch03lev2sec9"
class="calibre4">Lists</a></p>
<p><a href="#text_part0018.html_ch07lev2sec6"
class="calibre4">Macros</a></p>
<p><a href="#text_part0018.html_ch07lev2sec7" class="calibre4">Syntactic
Abstraction and the -&gt; Macro</a></p>
<p><a href="#text_part0018.html_ch07lev1sec4"
class="calibre4">Summary</a></p>
<p><a href="#text_part0018.html_ch07lev1sec5"
class="calibre4"><strong>Exercises</strong></a></p>
<p><a href="#text_part0019.html_ch08" class="calibre1"><strong>8:
Writing Macros</strong></a></p>
<p><a href="#text_part0019.html_ch08lev1sec1" class="calibre4">Macros
Are Essential</a></p>
<p><a href="#text_part0019.html_ch08lev1sec2" class="calibre4">Anatomy
of a Macro</a></p>
<p><a href="#text_part0019.html_ch08lev1sec3" class="calibre4">Building
Lists for Evaluation</a></p>
<p><a href="#text_part0019.html_ch08lev2sec1"
class="calibre4">Distinguishing Symbols and Values</a></p>
<p><a href="#text_part0019.html_ch08lev2sec2" class="calibre4">Simple
Quoting</a></p>
<p><a href="#text_part0019.html_ch08lev2sec3" class="calibre4">Syntax
Quoting</a></p>
<p><a href="#text_part0019.html_ch08lev1sec4" class="calibre4">Using
Syntax Quoting in a Macro</a></p>
<p><a href="#text_part0019.html_ch08lev1sec5"
class="calibre4">Refactoring a Macro and Unquote Splicing</a></p>
<p><a href="#text_part0019.html_ch08lev1sec6" class="calibre4">Things to
Watch Out For</a></p>
<p><a href="#text_part0019.html_ch08lev2sec4" class="calibre4">Variable
Capture</a></p>
<p><a href="#text_part0019.html_ch08lev2sec5" class="calibre4">Double
Evaluation</a></p>
<p><a href="#text_part0019.html_ch08lev2sec6" class="calibre4">Macros
All the Way Down</a></p>
<p><a href="#text_part0019.html_ch08lev1sec7" class="calibre4">Brews for
the Brave and True</a></p>
<p><a href="#text_part0019.html_ch08lev2sec7"
class="calibre4">Validation Functions</a></p>
<p><a href="#text_part0019.html_ch08lev2sec8"
class="calibre4">if-valid</a></p>
<p><a href="#text_part0019.html_ch08lev1sec8"
class="calibre4">Summary</a></p>
<p><a href="#text_part0019.html_ch08lev1sec9"
class="calibre4"><strong>Exercises</strong></a></p>
<p><a href="#text_part0020.html_part03" class="calibre1"><strong>Part
III: Advanced Topics</strong></a></p>
<p><a href="#text_part0021.html_ch09" class="calibre1"><strong>9: The
Sacred Art of Concurrent and Parallel Programming</strong></a></p>
<p><a href="#text_part0021.html_ch09lev1sec1"
class="calibre4">Concurrency and Parallelism Concepts</a></p>
<p><a href="#text_part0021.html_ch09lev2sec1" class="calibre4">Managing
Multiple Tasks vs. Executing Tasks Simultaneously</a></p>
<p><a href="#text_part0021.html_ch09lev2sec2" class="calibre4">Blocking
and Asynchronous Tasks</a></p>
<p><a href="#text_part0021.html_ch09lev2sec3"
class="calibre4">Concurrent Programming and Parallel Programming</a></p>
<p><a href="#text_part0021.html_ch09lev1sec2" class="calibre4">Clojure
Implementation: JVM Threads</a></p>
<p><a href="#text_part0021.html_ch09lev2sec4" class="calibre4">What’s a
Thread?</a></p>
<p><a href="#text_part0021.html_ch09lev2sec5" class="calibre4">The Three
Goblins: Reference Cells, Mutual Exclusion, and Dwarven
Berserkers</a></p>
<p><span id="text_part0006.html_page_xv" class="calibre4"></span><a
href="#text_part0021.html_ch09lev1sec3" class="calibre4">Futures,
Delays, and Promises</a></p>
<p><a href="#text_part0021.html_ch09lev2sec6"
class="calibre4">Futures</a></p>
<p><a href="#text_part0021.html_ch09lev2sec7"
class="calibre4">Delays</a></p>
<p><a href="#text_part0021.html_ch09lev2sec8"
class="calibre4">Promises</a></p>
<p><a href="#text_part0021.html_ch09lev2sec9" class="calibre4">Rolling
Your Own Queue</a></p>
<p><a href="#text_part0021.html_ch09lev1sec4"
class="calibre4">Summary</a></p>
<p><a href="#text_part0021.html_ch09lev1sec5"
class="calibre4"><strong>Exercises</strong></a></p>
<p><a href="#text_part0022.html_ch10" class="calibre1"><strong>10:
Clojure Metaphysics: Atoms, Refs, Vars, and Cuddle
Zombies</strong></a></p>
<p><a href="#text_part0022.html_ch10lev1sec1"
class="calibre4">Object-Oriented Metaphysics</a></p>
<p><a href="#text_part0022.html_ch10lev1sec2" class="calibre4">Clojure
Metaphysics</a></p>
<p><a href="#text_part0022.html_ch10lev1sec3"
class="calibre4">Atoms</a></p>
<p><a href="#text_part0022.html_ch10lev1sec4" class="calibre4">Watches
and Validators</a></p>
<p><a href="#text_part0022.html_ch10lev2sec1"
class="calibre4">Watches</a></p>
<p><a href="#text_part0022.html_ch10lev2sec2"
class="calibre4">Validators</a></p>
<p><a href="#text_part0022.html_ch10lev1sec5"
class="calibre4">Refs</a></p>
<p><a href="#text_part0022.html_ch10lev2sec3" class="calibre4">Modeling
Sock Transfers</a></p>
<p><a href="#text_part0022.html_ch10lev2sec4"
class="calibre4">commute</a></p>
<p><a href="#text_part0022.html_ch10lev1sec6"
class="calibre4">Vars</a></p>
<p><a href="#text_part0022.html_ch10lev2sec5" class="calibre4">Dynamic
Binding</a></p>
<p><a href="#text_part0022.html_ch10lev2sec6" class="calibre4">Altering
the Var Root</a></p>
<p><a href="#text_part0022.html_ch10lev1sec7" class="calibre4">Stateless
Concurrency and Parallelism with pmap</a></p>
<p><a href="#text_part0022.html_ch10lev1sec8"
class="calibre4">Summary</a></p>
<p><a href="#text_part0022.html_ch10lev1sec9"
class="calibre4"><strong>Exercises</strong></a></p>
<p><a href="#text_part0023.html_ch11" class="calibre1"><strong>11:
Mastering Concurrent Processes with core.async</strong></a></p>
<p><a href="#text_part0023.html_ch11lev1sec1" class="calibre4">Getting
Started with Processes</a></p>
<p><a href="#text_part0023.html_ch11lev2sec1"
class="calibre4">Buffering</a></p>
<p><a href="#text_part0023.html_ch11lev2sec2" class="calibre4">Blocking
and Parking</a></p>
<p><a href="#text_part0023.html_ch11lev2sec3"
class="calibre4">thread</a></p>
<p><a href="#text_part0023.html_ch11lev1sec2" class="calibre4">The Hot
Dog Machine Process You’ve Been Longing For</a></p>
<p><a href="#text_part0023.html_ch11lev2sec4"
class="calibre4">alts!!</a></p>
<p><a href="#text_part0023.html_ch11lev2sec5"
class="calibre4">Queues</a></p>
<p><a href="#text_part0023.html_ch11lev1sec3" class="calibre4">Escape
Callback Hell with Process Pipelines</a></p>
<p><a href="#text_part0023.html_ch11lev1sec4"
class="calibre4">Additional Resources</a></p>
<p><a href="#text_part0023.html_ch11lev1sec5"
class="calibre4">Summary</a></p>
<p><a href="#text_part0024.html_ch12" class="calibre1"><strong>12:
Working with the JVM</strong></a></p>
<p><a href="#text_part0024.html_ch12lev1sec1" class="calibre4">The
JVM</a></p>
<p><a href="#text_part0024.html_ch12lev1sec2" class="calibre4">Writing,
Compiling, and Running a Java Program</a></p>
<p><a href="#text_part0024.html_ch12lev2sec1"
class="calibre4">Object-Oriented Programming in the World’s Tiniest
Nutshell</a></p>
<p><a href="#text_part0024.html_ch12lev2sec2" class="calibre4">Ahoy,
World</a></p>
<p><a href="#text_part0024.html_ch12lev1sec3" class="calibre4">Packages
and Imports</a></p>
<p><a href="#text_part0024.html_ch12lev1sec4" class="calibre4">JAR
Files</a></p>
<p><a href="#text_part0024.html_ch12lev1sec5"
class="calibre4">clojure.jar</a></p>
<p><a href="#text_part0024.html_ch12lev1sec6" class="calibre4">Clojure
App JARs</a></p>
<p><span id="text_part0006.html_page_xvi" class="calibre4"></span><a
href="#text_part0024.html_ch12lev1sec7" class="calibre4">Java
Interop</a></p>
<p><a href="#text_part0024.html_ch12lev2sec3" class="calibre4">Interop
Syntax</a></p>
<p><a href="#text_part0024.html_ch12lev2sec4" class="calibre4">Creating
and Mutating Objects</a></p>
<p><a href="#text_part0024.html_ch12lev2sec5"
class="calibre4">Importing</a></p>
<p><a href="#text_part0024.html_ch12lev1sec8" class="calibre4">Commonly
Used Java Classes</a></p>
<p><a href="#text_part0024.html_ch12lev2sec6" class="calibre4">The
System Class</a></p>
<p><a href="#text_part0024.html_ch12lev2sec7" class="calibre4">The Date
Class</a></p>
<p><a href="#text_part0024.html_ch12lev1sec9" class="calibre4">Files and
Input/Output</a></p>
<p><a href="#text_part0024.html_ch12lev1sec10"
class="calibre4">Resources</a></p>
<p><a href="#text_part0024.html_ch12lev1sec11"
class="calibre4">Summary</a></p>
<p><a href="#text_part0025.html_ch13" class="calibre1"><strong>13:
Creating and Extending Abstractions with Multimethods, Protocols, and
Records</strong></a></p>
<p><a href="#text_part0025.html_ch13lev1sec1"
class="calibre4">Polymorphism</a></p>
<p><a href="#text_part0025.html_ch13lev2sec1"
class="calibre4">Multimethods</a></p>
<p><a href="#text_part0025.html_ch13lev2sec2"
class="calibre4">Protocols</a></p>
<p><a href="#text_part0025.html_ch13lev1sec2"
class="calibre4">Records</a></p>
<p><a href="#text_part0025.html_ch13lev1sec3" class="calibre4">Further
Study</a></p>
<p><a href="#text_part0025.html_ch13lev1sec4"
class="calibre4">Summary</a></p>
<p><a href="#text_part0025.html_ch13lev1sec5"
class="calibre4"><strong>Exercises</strong></a></p>
<p><a href="#text_part0026.html_app01" class="calibre1"><strong>A:
Building and Developing with Leiningen</strong></a></p>
<p><a href="#text_part0026.html_app01lev1sec1" class="calibre4">The
Artifact Ecosystem</a></p>
<p><a href="#text_part0026.html_app01lev2sec1"
class="calibre4">Identification</a></p>
<p><a href="#text_part0026.html_app01lev2sec2"
class="calibre4">Dependencies</a></p>
<p><a href="#text_part0026.html_app01lev2sec3"
class="calibre4">Plug-Ins</a></p>
<p><a href="#text_part0026.html_app01lev1sec2"
class="calibre4">Summary</a></p>
<p><a href="#text_part0027.html_app02" class="calibre1"><strong>B: Boot,
the Fancy Clojure Build Framework</strong></a></p>
<p><a href="#text_part0027.html_app02lev1sec1" class="calibre4">Boot’s
Abstractions</a></p>
<p><a href="#text_part0027.html_app02lev1sec2"
class="calibre4">Tasks</a></p>
<p><a href="#text_part0027.html_app02lev1sec3" class="calibre4">The
REPL</a></p>
<p><a href="#text_part0027.html_app02lev1sec4"
class="calibre4">Composition and Coordination</a></p>
<p><a href="#text_part0027.html_app02lev2sec1" class="calibre4">Handlers
and Middleware</a></p>
<p><a href="#text_part0027.html_app02lev2sec2" class="calibre4">Tasks
Are Middleware Factories</a></p>
<p><a href="#text_part0027.html_app02lev1sec5"
class="calibre4">Filesets</a></p>
<p><a href="#text_part0027.html_app02lev1sec6" class="calibre4">Next
Steps</a></p>
<p><a href="#text_part0028.html_app03"
class="calibre1"><strong>Farewell!</strong></a></p>
<p><a href="#text_part0029.html_index"
class="calibre1"><strong>Index</strong></a></p>
<p><span id="text_part0007.html"></span></p>
<h2 class="h1" id="text_part0007.html_pref03"><span
id="text_part0007.html_page_xvii"
class="calibre1"></span><strong>Foreword</strong></h2>
<p>As you read this hilarious book, you will at some point experience a
very serious moment. It is the moment you admit to yourself that
programming is more enjoyable after knowing some Clojure. It is also the
moment that your investment in this book, in money and time, comes back
to you—with interest.</p>
<p>Humor has a certain relationship to seriousness. It is appropriate to
joke about serious things, but only after the right amount of time has
passed. For example, it took years for me to be able to crack a smile
when I remember my favorite uncle’s last words: “Hold my beer.”</p>
<p>This book works in the opposite way. It points out really funny
things for the right amount of time <em>before</em>, and perhaps even
<em>during</em>, the serious event—that moment you realize you enjoy
programming more because of Clojure. It does this without obscuring the
deep, technical aspects of Clojure programming that you will learn.</p>
<p>This approach is refreshing because most of the programming books
I’ve read are drier than a camel’s fart. We are fortunate that Daniel is
a brilliant programmer and writer and that his wife Jess is an equally
brilliant illustrator. We are especially fortunate that they both went
insane and decided to write a book at exactly the same time.</p>
<p>Clojure is the topic of this book, but in a way it—or perhaps its
creator, Rich Hickey—is also one of the authors, since Clojure is the
most elegant <span id="text_part0007.html_page_xviii"
class="calibre4"></span>programming language ever designed. Like the
concept of brunch, Clojure is so elegant that it’s difficult to tell
anyone anything about it without somehow improving them.</p>
<p>Elegance is a quality regularly ascribed to many dialects in the
family of programming languages known collectively as Lisp, of which
Clojure is one. All Lisps descend from a set of simple and beautiful
discoveries made by the mathematician John McCarthy in 1958.</p>
<p>Since 1958, there have been many Lisps and Lisp books. There are many
more Lisps and books to come. As artifacts of the past and future, each
are right for the unique combination of constraints and desires faced
and fancied by their authors, in their respective times.</p>
<p>I find Clojure, and this particular book about it, especially right
for the present. I hope you will too.</p>
<p>Alan Dipert</p>
<p><span id="text_part0008.html"></span></p>
<h2 class="h1" id="text_part0008.html_pref04"><span
id="text_part0008.html_page_xix"
class="calibre1"></span><strong>Acknowledgments</strong></h2>
<p>So many people helped me birth this weird baby, and I am humbled and
grateful for all their support.</p>
<p>First, thanks to Jess, my wife, for doing the illustrations that
complete this book, giving it the visual character I had hoped for.
Thanks, too, for the support and for putting up with me when I was in
crazy-eyed writer mode. (P.S. It feels bizarre to thank my wife via a
programming book’s front matter.)</p>
<p>Thanks to my friends and colleagues at McKinsey who read early
revisions and encouraged me to keep writing. Foremost among them are Pat
Shaughnessy, Alex Rothenberg, Thomas Newton, Jalil Fanaian, Chris
Parker, Mark Daggett, Christian Lilley, and Mike Morreale. Y’all are so
great; please move to Durham.</p>
<p>Thanks to my friend Bridget Hillyer for being a constant source of
support and positivity. I always feel like you have my back, and it
means a lot to me! Thanks, too, to my friend Joe Jackson, for reading,
listening to me blather, and offering feedback, and for making me feel
cool by gushing about this book to other people in front of me. Alan
Dipert, friend, tech reviewer, and now coworker, I give thee a million
thanks for your excellent technical editing and for introducing me to
Clojure in the first place.</p>
<p>I don’t know if every writer continually asks himself, “Why the hell
am I doing this? Is anyone even going to read it?” but I certainly did.
So I want to <span id="text_part0008.html_page_xx"
class="calibre4"></span>thank all the friendly folks who wrote to me and
suggested edits while the initial web version of this book was being
written. That positive feedback made me feel confident that I was doing
something worthwhile. By the same token, thanks to everyone who bought
the Leanpub version!</p>
<p>A big thank you to Clojure community leaders Eric Normand, David
Nolen, and Alex Miller for giving this book positive press. See you at
the next Conj!</p>
<p>Finally, a bazillion thank yous to the magnificent folks at No Starch
Press for all your help in shaping this book into something I’m
immensely proud of. Thank you for your high standards. Thank you for
continually pushing for greater clarity, and for even suggesting jokes.
(Seph’s “ball of wax” edit still makes me crack up.) Seph Kramer, Riley
Hoffman, Hayley Baker, Alison Law, Tyler Ortman, Anne Marie Walker:
thank you!</p>
<p><span id="text_part0009.html"></span></p>
<h2 class="h1" id="text_part0009.html_ch00"><span
id="text_part0009.html_page_xxi"
class="calibre1"></span><strong>Introduction</strong></h2>
<div class="image">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>Deep in your innermost being, you’ve always known you were destined
to learn Clojure. Every time you held your keyboard aloft, crying out in
anguish over an incomprehensible class hierarchy; every time you lay
awake at night, disturbing your loved ones with sobs over a
mutation-induced heisenbug; every time a race condition caused you to
pull out more of your ever-dwindling hair, some secret part of you has
known that <em>there has to be a better way</em>.</p>
<p>Now, at long last, the instructional material you have in front of
your face will unite you with the programming language you’ve been
longing for.</p>
<h3 class="h2" id="text_part0009.html_ch00lev1sec1"><span
id="text_part0009.html_page_xxii"
class="calibre1"></span><strong>Learning a New Programming Language: A
Journey Through the Four Labyrinths</strong></h3>
<p>To wield Clojure to its fullest, you’ll need to find your way through
the four labyrinths that face every programmer learning a new
language:</p>
<p><strong>The Forest of Tooling</strong> A friendly and efficient
programming environment makes it easy to try your ideas. You’ll learn
how to set up your environment.</p>
<p><strong>The Mountain of Language</strong> As you ascend, you’ll gain
knowledge of Clojure’s syntax, semantics, and data structures. You’ll
learn how to use one of the mightiest programming tools, the macro, and
learn how to simplify your life with Clojure’s concurrency
constructs.</p>
<p><strong>The Cave of Artifacts</strong> In its depths you’ll learn to
build, run, and distribute your own programs, and how to use code
libraries. You’ll also learn Clojure’s relationship to the Java Virtual
Machine (JVM).</p>
<p><strong>The Cloud Castle of Mindset</strong> In its rarefied air,
you’ll come to know the why and how of Lisp and functional programming.
You’ll learn about the philosophy of simplicity that permeates Clojure,
and how to solve problems like a Clojurist.</p>
<p>Make no mistake, you will work. But this book will make the work feel
exhilarating, not exhausting. That’s because this book follows three
guidelines:</p>
<p>• It takes the dessert-first approach, giving you the development
tools and language details you need to start playing with real programs
immediately.</p>
<p>• It assumes zero experience with the JVM, functional programming, or
Lisp. It covers these topics in detail so you’ll feel confident about
what you’re doing when you build and run Clojure programs.</p>
<p>• It eschews <em>real-world</em> examples in favor of more
interesting exercises, like <em>assaulting hobbits</em> and <em>tracking
glittery vampires</em>.</p>
<p>By the end, you’ll be able to use Clojure, one of the most exciting
and fun programming languages in existence!</p>
<h3 class="h2" id="text_part0009.html_ch00lev1sec2"><strong>How This
Book Is Organized</strong></h3>
<p>This book is split into three parts to better guide you through your
valiant quest, brave fledgling Clojurist.</p>
<h4 class="h2" id="text_part0009.html_ch00lev2sec1"><em><strong>Part I:
Environment Setup</strong></em></h4>
<p>To stay motivated and learn efficiently, you need to actually write
code and build executables. These chapters take you on a quick tour of
the tools you’ll need to easily write programs. That way you can focus
on learning Clojure, not fiddling with your environment.</p>
<p><span id="text_part0009.html_page_xxiii"
class="calibre4"></span><strong><a href="#text_part0011.html_ch01"
class="calibre4">Chapter 1</a>: Building, Running, and the
REPL</strong></p>
<p>There’s something powerful and motivating about getting a real
program running. Once you can do that, you’re free to experiment, and
you can actually share your work!</p>
<p>In this short chapter, you’ll invest a small amount of time to become
familiar with a quick way to build and run Clojure programs. You’ll
learn how to experiment with code in a running Clojure process using a
read-eval-print loop (REPL). This will tighten your feedback loop and
help you learn more efficiently.</p>
<p><strong><a href="#text_part0012.html_ch02" class="calibre4">Chapter
2</a>: How to Use Emacs, an Excellent Clojure Editor</strong></p>
<p>A quick feedback loop is crucial for learning. In this chapter, I
cover Emacs from the ground up to guarantee you have an efficient
Emacs/Clojure workflow.</p>
<h4 class="h2" id="text_part0009.html_ch00lev2sec2"><em><strong>Part II:
Language Fundamentals</strong></em></h4>
<p>These chapters give you a solid foundation on which to continue
learning Clojure. You’ll start by learning Clojure’s basics (syntax,
semantics, and data structures) so you can <em>do things</em>. Then
you’ll take a step back to examine Clojure’s most used functions in
detail and learn how to solve problems with them using the
<em>functional programming</em> mindset.</p>
<p><strong><a href="#text_part0014.html_ch03" class="calibre4">Chapter
3</a>: Do Things: A Clojure Crash Course</strong></p>
<p>This is where you’ll start to really dig into Clojure. It’s also
where you’ll need to close your windows because you’ll start shouting,
“<em>HOLY MOLEY THAT’S SPIFFY!</em>” at the top of your lungs and won’t
stop until you’ve hit this book’s index.</p>
<p>You’ve undoubtedly heard of Clojure’s awesome concurrency support and
other stupendous features, but Clojure’s most salient characteristic is
that it is a Lisp. You’ll explore this Lisp core, which is composed of
two parts: functions and data.</p>
<p><strong><a href="#text_part0015.html_ch04" class="calibre4">Chapter
4</a>: Core Functions in Depth</strong></p>
<p>In this chapter, you’ll learn about a couple of Clojure’s underlying
concepts. This will give you the grounding you need to read the
documentation for functions you haven’t used before and to understand
what’s happening when you try them.</p>
<p>You’ll also see usage examples of the functions you’ll be reaching
for the most. This will give you a solid foundation for writing your own
code and for reading and learning from other people’s projects. And
remember how I mentioned tracking glittery vampires? You’ll do that in
this chapter (unless you already do it in your spare time).</p>
<p><strong><a href="#text_part0016.html_ch05" class="calibre4">Chapter
5</a>: Functional Programming</strong></p>
<p>In this chapter, you’ll take your concrete experience with functions
and data structures and integrate it with a new mindset: the functional
programming mindset. You’ll show off your knowledge by constructing the
hottest new game that’s sweeping the nation: Peg Thing!</p>
<p><span id="text_part0009.html_page_xxiv"
class="calibre4"></span><strong><a href="#text_part0017.html_ch06"
class="calibre4">Chapter 6</a>: Organizing Your Project: A Librarian’s
Tale</strong></p>
<p>This chapter explains what namespaces are and how to use them to
organize your code. I don’t want to give away too much, but it also
involves an international cheese thief.</p>
<p><strong><a href="#text_part0018.html_ch07" class="calibre4">Chapter
7</a>: Clojure Alchemy: Reading, Evaluation, and Macros</strong></p>
<p>In this chapter, we’ll take a step back and describe how Clojure runs
your code. This will give you the conceptual structure you need to truly
understand how Clojure works and how it’s different from other, non-Lisp
languages. With this structure in place, I’ll introduce the macro, one
of the most powerful tools in existence.</p>
<p><strong><a href="#text_part0019.html_ch08" class="calibre4">Chapter
8</a>: Writing Macros</strong></p>
<p>This chapter thoroughly examines how to write macros, starting with
basic examples and advancing in complexity. You’ll close by donning your
make-believe cap, pretending that you run an online potion store and
using macros to validate customer orders.</p>
<h4 class="h2" id="text_part0009.html_ch00lev2sec3"><em><strong>Part
III: Advanced Topics</strong></em></h4>
<p>These chapters cover Clojure’s extra-fun topics: concurrency, Java
interop, and abstraction. Although you can write programs without
understanding these tools and concepts, they’re intellectually rewarding
and give you tremendous power as a programmer. One of the reasons people
say that learning Clojure makes you a better programmer is that it makes
the concepts covered in these chapters easy to understand and practical
to use.</p>
<p><strong><a href="#text_part0021.html_ch09" class="calibre4">Chapter
9</a>: The Sacred Art of Concurrent and Parallel
Programming</strong></p>
<p>In this chapter, you’ll learn what concurrency and parallelism are
and why they matter. You’ll learn about the challenges you’ll face when
writing parallel programs and about how Clojure’s design helps to
mitigate them. You’ll use futures, delays, and promises to safely write
parallel programs.</p>
<p><strong><a href="#text_part0022.html_ch10" class="calibre4">Chapter
10</a>: Clojure Metaphysics: Atoms, Refs, Vars, and Cuddle
Zombies</strong></p>
<p>This chapter goes into great detail about Clojure’s approach to
managing state and how that simplifies concurrent programming. You’ll
learn how to use atoms, refs, and vars, three constructs for managing
state, and you’ll learn how to do stateless parallel computation with
<span class="literal1">pmap</span>. And there will be cuddle
zombies.</p>
<p><strong><a href="#text_part0023.html_ch11" class="calibre4">Chapter
11</a>: Mastering Concurrent Processes with core.async</strong></p>
<p>In this chapter, you’ll ponder the idea that everything in the
universe is a hot dog vending machine. By which I mean you’ll learn how
to model systems of independently running processes that communicate
with each other over channels using the core.async library.</p>
<p><span id="text_part0009.html_page_xxv"
class="calibre4"></span><strong><a href="#text_part0024.html_ch12"
class="calibre4">Chapter 12</a>: Working with the JVM</strong></p>
<p>This chapter is like a cross between a phrase book and cultural
introduction to the Land of Java. It gives you an overview of what the
JVM is, how it runs programs, and how to compile programs for it. It
also gives you a brief tour of frequently used Java classes and methods,
and explains how to interact with them from Clojure. More than that, it
shows you how to think about and understand Java so you can incorporate
any Java library into your Clojure program.</p>
<p><strong><a href="#text_part0025.html_ch13" class="calibre4">Chapter
13</a>: Creating and Extending Abstractions with Multimethods,
Protocols, and Records</strong></p>
<p>In <a href="#text_part0015.html_ch04" class="calibre4">Chapter 4</a>
you learn that Clojure is written in terms of abstractions. This chapter
serves as an introduction to the world of creating and implementing your
own abstractions. You’ll learn the basics of multimethods, protocols,
and records.</p>
<p><strong>Appendix A: Building and Developing with
Leiningen</strong></p>
<p>This appendix clarifies some of the finer points of working with
Leiningen, like what Maven is and how to figure out the version numbers
of Java libraries so that you can use them.</p>
<p><strong>Appendix B: Boot, the Fancy Clojure Build
Framework</strong></p>
<p>Boot is an alternative to Leiningen that provides the same
functionally, but with the added bonus that it’s easier to extend and
write composable tasks. This appendix explains Boot’s underlying
concepts and guides you through writing your first tasks.</p>
<h3 class="h2" id="text_part0009.html_ch00lev1sec3"><strong>The
Code</strong></h3>
<p>You can download all the source code from the book at <em><a
href="http://www.nostarch.com/clojure/"
class="calibre4">http://www.nostarch.com/clojure/</a></em>. The code is
organized by chapter.</p>
<p><a href="#text_part0011.html_ch01" class="calibre4">Chapter 1</a>
describes the different ways that you can run Clojure code, including
how to use a REPL. I recommend running most of the examples in the REPL
as you encounter them, especially in <a href="#text_part0014.html_ch03"
class="calibre4">Chapters 3</a> through <a
href="#text_part0019.html_ch08" class="calibre4">8</a>. This will help
you get used to writing and understanding Lisp code, and it will help
you retain everything you’re learning. But for the examples that are
long, it’s best to write your code to a file, and then run the code you
wrote in a REPL.</p>
<h3 class="h2" id="text_part0009.html_ch00lev1sec4"><strong>The Journey
Begins!</strong></h3>
<p>Are you ready, brave reader? Are you ready to meet your true destiny?
Grab your best pair of parentheses: you’re about to embark on the
journey of a lifetime! <span id="text_part0009.html_page_xxvi"
class="calibre4"></span></p>
<p><span id="text_part0010.html"></span></p>
<h1 class="part" id="text_part0010.html_part01"><span
id="text_part0010.html_page_1" class="calibre1"></span><strong><span
class="big">Part I</span></strong><br />
<strong>Environment Setup</strong><span id="text_part0010.html_page_2"
class="calibre1"></span></h1>
<p><span id="text_part0011.html"></span></p>
<h2 class="h1" id="text_part0011.html_ch01"><span
id="text_part0011.html_page_3" class="calibre1"></span><strong><span
class="big1">1</span></strong><br />
<strong>Building, Running, and the REPL</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>In this chapter, you’ll invest a small amount of time up front to get
familiar with a quick, foolproof way to build and run Clojure programs.
It feels great to get a real program running. Reaching that milestone
frees you up to experiment, share your work, and gloat to your
colleagues who are still using last decade’s languages. This will help
keep you motivated!</p>
<p>You’ll also learn how to instantly run code within a running Clojure
process using a <em>Read-Eval-Print Loop (REPL)</em>, which allows you
to quickly test your understanding of the language and learn more
efficiently.</p>
<p><span id="text_part0011.html_page_4" class="calibre4"></span>But
first, I’ll briefly introduce Clojure. Next, I’ll cover Leiningen, the
de facto standard build tool for Clojure. By the end of the chapter,
you’ll know how to do the following:</p>
<p>• Create a new Clojure project with Leiningen</p>
<p>• Build the project to create an executable JAR file</p>
<p>• Execute the JAR file</p>
<p>• Execute code in a Clojure REPL</p>
<h3 class="h2" id="text_part0011.html_ch01lev1sec1"><strong>First Things
First: What Is Clojure?</strong></h3>
<p>Clojure was forged in a mythic volcano by Rich Hickey. Using an alloy
of Lisp, functional programming, and a lock of his own epic hair, he
crafted a language that’s delightful yet powerful. Its Lisp heritage
gives you the power to write code more expressively than is possible in
most non-Lisp languages, and its distinct take on functional programming
will sharpen your thinking as a programmer. Plus, Clojure gives you
better tools for tackling complex domains (like concurrent programming)
that are traditionally known to drive developers into years of
therapy.</p>
<p>When talking about Clojure, though, it’s important to keep in mind
the distinction between the Clojure language and the Clojure compiler.
The Clojure language is a Lisp dialect with a functional emphasis whose
syntax and semantics are independent of any implementation. The compiler
is an executable JAR file, <em>clojure.jar</em>, which takes code
written in the Clojure language and compiles it to Java Virtual Machine
(JVM) bytecode. You’ll see <em>Clojure</em> used to refer to both the
language and the compiler, which can be confusing if you’re not aware
that they’re separate things. But now that you’re aware, you’ll be
fine.</p>
<p>This distinction is necessary because, unlike most programming
languages like Ruby, Python, C, and a bazillion others, Clojure is a
<em>hosted language</em>. Clojure programs are executed within a JVM and
rely on the JVM for core features like threading and garbage collection.
Clojure also targets JavaScript and the Microsoft Common Language
Runtime (CLR), but this book only focuses on the JVM implementation.</p>
<p>We’ll explore the relationship between Clojure and the JVM more later
on, but for now the main concepts you need to understand are these:</p>
<p>• JVM processes execute Java bytecode.</p>
<p>• Usually, the Java Compiler produces Java bytecode from Java source
code.</p>
<p>• JAR files are collections of Java bytecode.</p>
<p>• Java programs are usually distributed as JAR files.</p>
<p>• The Java program <em>clojure.jar</em> reads Clojure source code and
produces Java bytecode.</p>
<p>• That Java bytecode is then executed by the same JVM process already
running <em>clojure.jar</em>.</p>
<p><span id="text_part0011.html_page_5" class="calibre4"></span>Clojure
continues to evolve. As of this writing, it’s at version 1.7.0, and
development is going strong. If you’re reading this book in the far
future and Clojure has a higher version number, don’t worry! This book
covers Clojure’s fundamentals, which shouldn’t change from one version
to the next. There’s no need for your robot butler to return this book
to the bookstore.</p>
<p>Now that you know what Clojure is, let’s actually build a freakin’
Clojure program!</p>
<h3 class="h2"
id="text_part0011.html_ch01lev1sec2"><strong>Leiningen</strong></h3>
<p>These days, most Clojurists use Leiningen to build and manage their
projects. You can read a full description of Leiningen in <a
href="#text_part0026.html_app01" class="calibre4">Appendix A</a>, but
for now we’ll focus on using it for four tasks:</p>
<p>1. Creating a new Clojure project</p>
<p>2. Running the Clojure project</p>
<p>3. Building the Clojure project</p>
<p>4. Using the REPL</p>
<p>Before continuing, make sure you have Java version 1.6 or later
installed. You can check your version by running <span
class="literal1">java -version</span> in your terminal, and download the
latest Java Runtime Environment (JRE) from <em><a
href="http://www.oracle.com/technetwork/java/javase/downloads/index.html"
class="calibre4">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></em>.
Then, install Leiningen using the instructions on the Leiningen home
page at <em><a href="http://leiningen.org/"
class="calibre4">http://leiningen.org/</a></em> (Windows users, note
there’s a Windows installer). When you install Leiningen, it
automatically downloads the Clojure compiler, <em>clojure.jar</em>.</p>
<h4 class="h2" id="text_part0011.html_ch01lev2sec1"><em><strong>Creating
a New Clojure Project</strong></em></h4>
<p>Creating a new Clojure project is very simple. A single Leiningen
command creates a project skeleton. Later, you’ll learn how to do tasks
like incorporate Clojure libraries, but for now, these instructions will
enable you to execute the code you write.</p>
<p>Go ahead and create your first Clojure project by typing the
following in your terminal:</p>
<pre class="programs"><code>lein new app clojure-noob</code></pre>
<p>This command should create a directory structure that looks similar
to this (it’s okay if there are some differences):</p>
<pre class="programs"><code>   | .gitignore
   | doc
   | | intro.md
 ➊ | project.clj
   | README.md
 ➋ | resources
   | src

   | | clojure_noob
 ➌ | | | core.clj
 ➍ | test
   | | clojure_noob
   | | | core_test.clj</code></pre>
<p>This project skeleton isn’t inherently special or Clojure-y. It’s
just a convention used by Leiningen. You’ll be using Leiningen to build
and run Clojure apps, and Leiningen expects your app to have this
structure. The first file of note is <em>project.clj</em> at <span
class="ent">➊</span>, which is a configuration file for Leiningen. It
helps Leiningen answer such questions as “What dependencies does this
project have?” and “When this Clojure program runs, what function should
run first?” In general, you’ll save your your source code in
<em>src/&lt;project_name&gt;</em>. In this case, the file
<em>src/clojure_noob/core.clj</em> at <span class="ent">➌</span> is
where you’ll be writing your Clojure code for a while. The <em>test</em>
directory at <span class="ent">➍</span> obviously contains tests, and
<em>resources</em> at <span class="ent">➋</span> is where you store
assets like images.</p>
<h4 class="h2" id="text_part0011.html_ch01lev2sec2"><em><strong>Running
the Clojure Project</strong></em></h4>
<p>Now let’s actually run the project. Open
<em>src/clojure_noob/core.clj</em> in your favorite editor. You should
see this:</p>
<pre class="programs"><code>➊ (ns clojure-noob.core
     (:gen-class))
➋ (defn -main
     &quot;I don&#39;t do a whole lot...yet.&quot;
     [&amp; args]
➌   (println &quot;Hello, World!&quot;))</code></pre>
<p>The lines at <span class="ent">➊</span> declare a namespace, which
you don’t need to worry about right now. The <span
class="literal1">-main</span> function at <span class="ent">➋</span> is
the <em>entry point</em> to your program, a topic that is covered in <a
href="#text_part0026.html_app01" class="calibre4">Appendix A</a>. For
now, replace the text <span class="literal1">"Hello, World!"</span> at
<span class="ent">➌</span> with <span class="literal1">"I'm a little
teapot!"</span>. The full line should read <span
class="literal1">(println "I'm a little teapot!"))</span>.</p>
<p>Next, navigate to the <em>clojure_noob</em> directory in your
terminal and enter:</p>
<pre class="programs"><code>lein run</code></pre>
<p>You should see the output <span class="literal1">"I'm a little
teapot!"</span> Congratulations, little teapot, you wrote and executed a
program!</p>
<div class="image">
<img src="images_00008.jpeg" class="calibre3" alt="image" />
</div>
<p>You’ll learn more about what’s actually happening in the program as
you read through the book, but for now all you need to know is that you
created a function, <span class="literal1">-main</span>, and that
function runs when you execute <span class="literal1">lein run</span> at
the command line.</p>
<h4 class="h2" id="text_part0011.html_ch01lev2sec3"><span
id="text_part0011.html_page_7"
class="calibre1"></span><em><strong>Building the Clojure
Project</strong></em></h4>
<p>Using <span class="literal1">lein run</span> is great for trying out
your code, but what if you want to share your work with people who don’t
have Leiningen installed? To do that, you can create a stand-alone file
that anyone with Java installed (which is basically everyone) can
execute. To create the file, run this:</p>
<pre class="programs"><code>lein uberjar</code></pre>
<p>This command creates the file <em>target/uberjar/clojure-noob-0.1.0
-SNAPSHOT-standalone.jar</em>. You can make Java execute it by running
this:</p>
<pre class="programs"><code>java -jar target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar</code></pre>
<p>Look at that! The file <em>target/uberjar/clojure-noob-0.1.0-SNAPSHOT
-standalone.jar</em> is your new, award-winning Clojure program, which
you can distribute and run on almost any platform.</p>
<p>You now have all the basic details you need to build, run, and
distribute (very) basic Clojure programs. In later chapters, you’ll
learn more details about what Leiningen is doing when you run the
preceding commands, gaining a complete understanding of Clojure’s
relationship to the JVM and how you can run production code.</p>
<p>Before we move on to <a href="#text_part0012.html_ch02"
class="calibre4">Chapter 2</a> and discuss the wonder and glory of
Emacs, let’s go over another important tool: the REPL.</p>
<h4 class="h2" id="text_part0011.html_ch01lev2sec4"><em><strong>Using
the REPL</strong></em></h4>
<p>The REPL is a tool for experimenting with code. It allows you to
interact with a running program and quickly try out ideas. It does this
by presenting you with a prompt where you can enter code. It then
<em>reads</em> your input, <em>evaluates</em> it, <em>prints</em> the
result, and <em>loops</em>, presenting you with a prompt again.</p>
<p>This process enables a quick feedback cycle that isn’t possible in
most other languages. I strongly recommend that you use it frequently
because you’ll be able to quickly check your understanding of Clojure as
you learn. Besides that, REPL development is an essential part of the
Lisp experience, and you’d really be missing out if you didn’t use
it.</p>
<p>To start a REPL, run this:</p>
<pre class="programs"><code>lein repl</code></pre>
<p>The output should look like this:</p>
<pre class="programs"><code>nREPL server started on port 28925
REPL-y 0.1.10
Clojure 1.7.0
    Exit: Control+D or (exit) or (quit)
Commands: (user/help)
    Docs: (doc function-name-here)
          (find-doc &quot;part-of-name-here&quot;)

  Source: (source function-name-here)
          (user/sourcery function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
Examples from clojuredocs.org: [clojuredocs or cdoc]
          (user/clojuredocs name-here)
          (user/clojuredocs &quot;ns-here&quot; &quot;name-here&quot;)
clojure-noob.core=&gt;</code></pre>
<p>The last line, <span class="literal1">clojure-noob.core=&gt;</span>,
tells you that you’re in the <span class="literal1">clojure
-noob.core</span> namespace. You’ll learn about namespaces later, but
for now notice that the namespace basically matches the name of your
<em>src/clojure_noob/core.clj</em> file. Also, notice that the REPL
shows the version as <em>Clojure 1.7.0</em>, but as mentioned earlier,
everything will work okay no matter which version you use.</p>
<p>The prompt also indicates that your code is loaded in the REPL, and
you can execute the functions that are defined. Right now only one
function, <span class="literal1">-main</span>, is defined. Go ahead and
execute it now:</p>
<pre class="programs"><code>clojure-noob.core=&gt; (-main)
I&#39;m a little teapot!
nil</code></pre>
<p>Well done! You just used the REPL to evaluate a function call. Try a
few more basic Clojure functions:</p>
<pre class="programs"><code>clojure-noob.core=&gt; (+ 1 2 3 4)
10
clojure-noob.core=&gt; (* 1 2 3 4)
24
clojure-noob.core=&gt; (first [1 2 3 4])
1</code></pre>
<p>Awesome! You added some numbers, multiplied some numbers, and took
the first element from a vector. You also had your first encounter with
weird Lisp syntax! All Lisps, Clojure included, employ <em>prefix
notation</em>, meaning that the operator always comes first in an
expression. If you’re unsure about what that means, don’t worry. You’ll
learn all about Clojure’s syntax soon.</p>
<p>Conceptually, the REPL is similar to Secure Shell (SSH). In the same
way that you can use SSH to interact with a remote server, the Clojure
REPL allows you to interact with a running Clojure process. This feature
can be very powerful because you can even attach a REPL to a live
production app and modify your program as it runs. For now, though,
you’ll be using the REPL to build your knowledge of Clojure syntax and
semantics.</p>
<p>One more note: going forward, this book will present code without
REPL prompts, but please do try the code! Here’s an example:</p>
<pre class="programs"><code>(do (println &quot;no prompt here!&quot;)
   (+ 1 3))

; =&gt; no prompt here!
; =&gt; 4</code></pre>
<p>When you see code snippets like this, lines that begin with <span
class="literal1">; =&gt;</span> indicate the output of the code being
run. In this case, the text <span class="literal1">no prompt here</span>
should be printed, and the return value of the code is <span
class="literal1">4</span>.</p>
<h3 class="h2" id="text_part0011.html_ch01lev1sec3"><strong>Clojure
Editors</strong></h3>
<p>At this point you should have the basic knowledge you need to begin
learning the Clojure language without having to fuss with an editor or
integrated development environment (IDE). But if you do want a good
tutorial on a powerful editor, <a href="#text_part0012.html_ch02"
class="calibre4">Chapter 2</a> covers Emacs, the most popular editor
among Clojurists. You absolutely do not need to use Emacs for Clojure
development, but Emacs offers tight integration with the Clojure REPL
and is well-suited to writing Lisp code. What’s most important, however,
is that you use whatever works for you.</p>
<p>If Emacs isn’t your cup of tea, here are some resources for setting
up other text editors and IDEs for Clojure development:</p>
<p>• This YouTube video will show you how to set up Sublime Text 2 for
Clojure development: <em><a
href="http://www.youtube.com/watch?v=wBl0rYXQdGg/"
class="calibre4">http://www.youtube.com/watch?v=wBl0rYXQdGg/</a></em>.</p>
<p>• Vim has good tools for Clojure development. This article is a good
starting point: <em><a
href="http://mybuddymichael.com/writings/writing-clojure-with-vim-in-2013.html"
class="calibre4">http://mybuddymichael.com/writings/writing-clojure-with-vim-in-2013.html</a></em>.</p>
<p>• Counterclockwise is a highly recommended Eclipse plug-in: <em><a
href="https://github.com/laurentpetit/ccw/wiki/GoogleCodeHome"
class="calibre4">https://github.com/laurentpetit/ccw/wiki/GoogleCodeHome</a></em>.</p>
<p>• Cursive Clojure is the recommended IDE for those who use IntelliJ:
<em><a href="https://cursiveclojure.com/"
class="calibre4">https://cursiveclojure.com/</a></em>.</p>
<p>• Nightcode is a simple, free IDE written in Clojure: <em><a
href="https://github.com/oakes/Nightcode/"
class="calibre4">https://github.com/oakes/Nightcode/</a></em>.</p>
<h3 class="h2"
id="text_part0011.html_ch01lev1sec4"><strong>Summary</strong></h3>
<p>I’m so proud of you, little teapot. You’ve run your first Clojure
program! Not only that, but you’ve become acquainted with the REPL, one
of the most important tools for developing Clojure software. Amazing! It
brings to mind the immortal lines from “Long Live” by one of my personal
heroes:</p>
<p>You held your head like a hero<br />
On a history book page<br />
It was the end of a decade<br />
But the start of an age</p>
<p>—Taylor Swift</p>
<p>Bravo!<span id="text_part0011.html_page_10"
class="calibre4"></span></p>
<p><span id="text_part0012.html"></span></p>
<h2 class="h1" id="text_part0012.html_ch02"><span
id="text_part0012.html_page_11" class="calibre1"></span><strong><span
class="big1">2</span></strong><br />
<strong>How to Use Emacs, an Excellent Clojure Editor</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>On your journey to Clojure mastery, your editor will be your closest
ally. I highly recommend working with Emacs, but you can, of course, use
any editor you want. If you don’t follow the thorough Emacs instructions
in this chapter, or if you choose to use a different editor, it’s
worthwhile to at least invest some time in setting up your editor to
work with a REPL.</p>
<p>The reason I recommend Emacs is that it offers tight integration with
a Clojure REPL, which allows you to instantly try out your code as you
write. That kind of tight feedback loop will be useful while learning
Clojure and, later, when writing real Clojure programs. Emacs is also
great for working with any Lisp dialect; in fact, Emacs is written in a
Lisp dialect called Emacs Lisp (elisp).</p>
<p><span id="text_part0012.html_page_12" class="calibre4"></span>By the
end of this chapter, your Emacs setup will look something like <a
href="#text_part0012.html_ch2fig1" class="calibre4">Figure 2-1</a>.</p>
<div class="image">
<img src="images_00009.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0012.html_ch2fig1"
class="calibre4"></span><em>Figure 2-1: A typical Emacs setup for
working with Clojure—code on one side, REPL on the other</em></p>
<p>To get there, you’ll start by installing Emacs and setting up a
new-person-friendly Emacs configuration. Then you’ll learn the basics:
how to open, edit, and save files, and how to interact with Emacs using
essential key bindings. Finally, you’ll learn how to actually edit
Clojure code and interact with the REPL.</p>
<h3 class="h2"
id="text_part0012.html_ch02lev1sec1"><strong>Installation</strong></h3>
<p>You should use the latest major version of Emacs, Emacs 24, for the
platform you’re working on:</p>
<p><strong>OS X</strong> Install vanilla Emacs as a Mac app from <em><a
href="http://emacsformacosx.com/"
class="calibre4">http://emacsformacosx.com/</a></em>. Other options,
like Aquamacs, are supposed to make Emacs more “Mac-like,” but they’re
problematic in the long run because they’re set up so differently from
standard Emacs that it’s difficult to use the Emacs manual or follow
along with tutorials.</p>
<p><strong>Ubuntu</strong> Follow the instructions at <em><a
href="https://launchpad.net/~cassou/+archive/emacs"
class="calibre4">https://launchpad.net/~cassou/+archive/emacs</a></em>.</p>
<p><strong>Windows</strong> You can find a binary at <em><a
href="http://ftp.gnu.org/gnu/emacs/windows/"
class="calibre4">http://ftp.gnu.org/gnu/emacs/windows/</a></em>. After
you download and unzip the latest version, you can run the Emacs
executable under <em>bin\runemeacs.exe</em>.</p>
<p>After you’ve installed Emacs, open it. You should see something like
<a href="#text_part0012.html_ch2fig2" class="calibre4">Figure
2-2</a>.</p>
<div class="image">
<span id="text_part0012.html_page_13" class="calibre4"></span><img
src="images_00010.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0012.html_ch2fig2"
class="calibre4"></span><em>Figure 2-2: The screen Emacs displays when
you open it for the first time</em></p>
<p>Welcome to the cult of Emacs! You’ve made Richard Stallman proud!</p>
<h3 class="h2"
id="text_part0012.html_ch02lev1sec2"><strong>Configuration</strong></h3>
<p>I’ve created a repository of all the files you need to configure
Emacs for Clojure, available in this book’s resources at <em><a
href="https://www.nostarch.com/clojure/"
class="calibre4">https://www.nostarch.com/clojure/</a></em>. Do the
following to delete your existing Emacs configuration and install the
Clojure-friendly one:</p>
<p>1. Close Emacs.</p>
<p>2. Delete <em>~/.emacs</em> or <em>~/.emacs.d</em> if they exist.
This is where Emacs looks for configuration files, and deleting these
files and directories will ensure that you start with a clean slate.</p>
<p>3. Download the Emacs configuration zip file from the book’s resource
page and unzip it. Its contents should be a folder,
<em>emacs-for-clojure-book1</em>. Run <span class="literal1"><strong>mv
path/to/emacs-for-clojure-book1 ~/.emacs.d</strong></span>.</p>
<p>4. Create the file <em>~/.lein/profiles.clj</em> and add this line to
it:</p>
<pre class="programs"><code>{:user {:plugins [[cider/cider-nrepl &quot;0.8.1&quot;]]}}</code></pre>
<p>5. Open Emacs.</p>
<p>When you open Emacs, you should see a lot of activity as Emacs
downloads a bunch of useful packages. Once the activity stops, go ahead
and just quit Emacs, and then open it again. After you do so, you should
see a window like the one in <a href="#text_part0012.html_ch2fig3"
class="calibre4">Figure 2-3</a>.</p>
<div class="image">
<span id="text_part0012.html_page_14" class="calibre4"></span><img
src="images_00011.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0012.html_ch2fig3"
class="calibre4"></span><em>Figure 2-3: How Emacs looks after installing
your sweet new configuration</em></p>
<p>Now that we’ve got everything set up, let’s learn how to use
Emacs!</p>
<h3 class="h2" id="text_part0012.html_ch02lev1sec3"><strong>Emacs Escape
Hatch</strong></h3>
<p>Before we dig in to the fun stuff, you need to know an important
Emacs key binding: <span class="small">CTRL</span>-G. This key binding
quits whatever Emacs command you’re trying to run. So if things aren’t
going right, hold down <span class="small">CTRL</span>, press G, and
then try again. It won’t close Emacs or make you lose any work; it’ll
just cancel your current action.</p>
<h3 class="h2" id="text_part0012.html_ch02lev1sec4"><strong>Emacs
Buffers</strong></h3>
<p>All editing happens in an Emacs <em>buffer</em>. When you first start
Emacs, a buffer named <span class="literal1">*scratch*</span> is open.
Emacs will always show you the name of the current buffer at the bottom
of the window, as shown in <a href="#text_part0012.html_ch2fig4"
class="calibre4">Figure 2-4</a>.</p>
<div class="image">
<img src="images_00012.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0012.html_ch2fig4"
class="calibre4"></span><em>Figure 2-4: Emacs will always show you the
name of the current buffer.</em></p>
<p>By default, the <span class="literal1">*scratch*</span> buffer
handles parentheses and indentation in a way that’s optimal for Lisp
development but is inconvenient for writing plain text. Let’s create a
fresh buffer so we can play around without having unexpected things
happen. To create a buffer, do this:</p>
<p>1. Hold down <span class="small">CTRL</span> and press X.</p>
<p>2. Release <span class="small">CTRL</span>.</p>
<p>3. Press B.</p>
<p><span id="text_part0012.html_page_15" class="calibre4"></span>We can
express the same sequence in a more compact format: <strong>C-x
b</strong>. After performing this key sequence, you’ll see a prompt at
the bottom of the application, as shown in <a
href="#text_part0012.html_ch2fig5" class="calibre4">Figure 2-5</a>.</p>
<div class="image">
<img src="images_00013.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0012.html_ch2fig5"
class="calibre4"></span><em>Figure 2-5: The minibuffer is where Emacs
prompts you for input.</em></p>
<p>This area is called the <em>minibuffer</em>, and it is where Emacs
prompts you for input. Right now it’s prompting us for a buffer name.
You can enter the name of a buffer that is already open, or you can
enter a new buffer name. Type in <span
class="literal1"><strong>emacs-fun-times</strong></span> and press <span
class="small">ENTER</span>. You should now see a completely blank buffer
and can just start typing. You’ll find that keys mostly work the way
you’d expect. Characters appear as you type them. The up, down, left,
and right arrow keys move you as you’d expect, and <span
class="small">ENTER</span> creates a new line.</p>
<p>You’ll also notice that you’re not suddenly sporting a bushy Unix
beard or Birkenstocks (unless you had them to begin with). This should
help ease any lingering trepidation you feel about using Emacs. When
you’re done messing around, go ahead and <em>kill</em> the buffer by
typing <strong>C-x k enter</strong>. (It might come as a surprise, but
Emacs is actually quite violent, making ample use of the term
<em>kill</em>.)</p>
<p>Now that you’ve killed the <span
class="literal1">emacs-fun-times</span> buffer, you should be back in
the <span class="literal1">*scratch*</span> buffer. In general, you can
create as many new buffers as you want with <strong>C-x b</strong>. You
can also quickly switch between buffers using the same command. When you
create a new buffer this way, it exists only in memory until you save it
as a file; buffers aren’t necessarily backed by files, and creating a
buffer doesn’t necessarily create a file. Let’s learn about working with
files.</p>
<h3 class="h2" id="text_part0012.html_ch02lev1sec5"><strong>Working with
Files</strong></h3>
<p>The key binding for opening a file in Emacs is <strong>C-x
C-f</strong>. Notice that you’ll need to hold down <span
class="small">CTRL</span> when pressing both X and F. After you do that,
you’ll get another minibuffer prompt. Navigate to
<em>~/.emacs.d/customizations/ui.el</em>, which customizes the way Emacs
looks and how you can interact with it. Emacs opens the file in a new
buffer with the same name as the filename. Let’s go to line 37 and
uncomment it by removing the leading semicolons.</p>
<p>It will look like this:</p>
<pre class="programs"><code>(setq initial-frame-alist &#39;((top . 0) (left . 0) (width . 120) (height . 80)))</code></pre>
<p>Then change the values for <span class="literal1">width</span> and
<span class="literal1">height</span>, which set the dimensions in
<em>characters</em> for the active window. By changing these values, you
can set the <span id="text_part0012.html_page_16"
class="calibre4"></span>Emacs window to open at a certain size every
time it starts. Try something small at first, like 80 and 20:</p>
<pre class="programs"><code>(setq initial-frame-alist &#39;((top . 0) (left . 0) (width . 80) (height . 20)))</code></pre>
<p>Now save your file with the following key binding: <strong>C-x
C-s</strong>. You should get a message at the bottom of Emacs like <span
class="literal1">Wrote/Users/snuffleupagus/.emacs.d/customizations/ui.el</span>.
You can also try saving your buffer using the key binding you use in
other applications (for example, <span class="small">CTRL</span>-S or
<img src="images_00014.jpeg" class="calibre3" alt="image" />-S). The
Emacs configuration you downloaded should allow that to work, but if it
doesn’t, it’s no big deal.</p>
<p>After saving the file, quit Emacs and start it again. I bet it’s very
tiny! See my example in <a href="#text_part0012.html_ch2fig6"
class="calibre4">Figure 2-6</a>.</p>
<div class="image">
<img src="images_00015.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0012.html_ch2fig6"
class="calibre4"></span><em>Figure 2-6: You can configure Emacs to set
its height and width every time you open it.</em></p>
<p>Go through that same process a couple of times until Emacs starts at
a size that you like. Or just comment out those lines again and be done
with it (in which case Emacs will open at its default width and
height).</p>
<p>If you’re done editing <em>ui.el</em>, you can close its buffer with
<strong>C-x k</strong>. Either way, you’re done saving your first file
in Emacs! If something crazy happens, you can follow the instructions in
“<a href="#text_part0012.html_ch02lev1sec2"
class="calibre4">Configuration</a>” on <a
href="#text_part0012.html_page_13" class="calibre4">page 13</a> to get
Emacs working again.</p>
<p>If you want to create a new file, just use <strong>C-x C-f</strong>
and enter the new file’s path in the minibuffer. As soon as you save the
buffer, Emacs will create a file with the buffer’s contents at the path
you entered.</p>
<p>Let’s recap:</p>
<p>1. In Emacs, editing takes place in buffers.</p>
<p>2. To switch to a buffer, use <strong>C-x b</strong> and enter the
buffer name in the minibuffer.</p>
<p>3. To create a new buffer, use <strong>C-x b</strong> and enter a new
buffer name.</p>
<p><span id="text_part0012.html_page_17" class="calibre4"></span>4. To
open a file, use <strong>C-x C-f</strong> and navigate to the file.</p>
<p>5. To save a buffer to a file, use <strong>C-x C-s</strong>.</p>
<p>6. To create a new file, use <strong>C-x C-f</strong> and enter the
new file’s path. When you save the buffer, Emacs will create the file on
the filesystem.</p>
<h3 class="h2" id="text_part0012.html_ch02lev1sec6"><strong>Key Bindings
and Modes</strong></h3>
<p>You’ve already come a long way! You can now use Emacs like a very
basic editor. This should help you get by if you ever need to use Emacs
on a server or are forced into pairing with an Emacs nerd.</p>
<p>However, to really be productive, it’ll be useful for you to know
some <em>key</em> details about key bindings (ha-ha!). Then I’ll
introduce Emacs modes. After that, I’ll cover some core terminology and
go over a bunch of super useful key bindings.</p>
<h4 class="h2" id="text_part0012.html_ch02lev2sec1"><em><strong>Emacs Is
a Lisp Interpreter</strong></em></h4>
<p>The term <em>key binding</em> derives from the fact that Emacs binds
<em>keystrokes</em> to <em>commands</em>, which are just elisp functions
(I’ll use <em>command</em> and <em>function</em> interchangeably). For
example, <strong>C-x b</strong> is bound to the function <span
class="literal1">switch-to-buffer</span>. Likewise, <strong>C-x
C-s</strong> is bound to <span class="literal1">save-file</span>.</p>
<p>But Emacs goes even further than that. Even simple keystrokes like
<strong>f</strong> and <strong>a</strong> are bound to a function, in
this case <span class="literal1">self-insert-command</span>, the command
for adding characters to the buffer you’re editing.</p>
<p>From Emacs’s point of view, all functions are created equal, and you
can redefine all functions, even core functions like <span
class="literal1">save-file</span>. You probably won’t <em>want</em> to
redefine core functions, but you can.</p>
<p>You can redefine functions because, at its core, Emacs is
<em>just</em> a Lisp interpreter that happens to load code-editing
facilities. Most of Emacs is written in elisp, so from the perspective
of Emacs, <span class="literal1">save-file</span> is just a function, as
is <span class="literal1">switch-to-buffer</span> and almost any other
command you can run. Not only that, but any functions you create are
treated the same way as built-in functions. You can even use Emacs to
execute elisp, modifying Emacs as it runs.</p>
<p>The freedom to modify Emacs using a powerful programming language is
what makes Emacs so flexible and why people like me are so crazy about
it. Yes, it has a lot of surface-level complexity that can take time to
learn. But underlying Emacs is the elegant simplicity of Lisp and the
infinite tinkerability that comes with it. This tinkerability isn’t
limited to just creating and redefining functions. You can also create,
redefine, and remove key bindings. Conceptually, key bindings are just
an entry in a lookup table associating keystrokes with functions, and
that lookup table is completely modifiable.</p>
<p>You can also run commands by name, without a specific key binding,
using <strong>M-x</strong> <span
class="literal1"><em><strong>function-name</strong></em></span> (for
example, <strong>M-x</strong> <span
class="literal1"><strong>save-buffer</strong></span>). <em>M</em> stands
for <em>meta</em>, a key that modern keyboards don’t possess but which
is mapped to <span class="small">ALT</span> on Windows and Linux and
<span class="small">OPTION</span> on Macs. <strong>M-x</strong> runs the
<span class="literal1">smex</span> command, which prompts you for the
name of another command to be run.</p>
<p>Now that you understand key bindings and functions, you’ll be able to
understand what modes are and how they work.</p>
<h4 class="h2" id="text_part0012.html_ch02lev2sec2"><span
id="text_part0012.html_page_18"
class="calibre1"></span><em><strong>Modes</strong></em></h4>
<p>An Emacs <em>mode</em> is a collection of key bindings and functions
that are packaged together to help you be productive when editing
different types of files. (Modes also do things like tell Emacs how to
do syntax highlighting, but that’s of secondary importance, and I won’t
cover that here.)</p>
<p>For example, when you’re editing a Clojure file, you’ll want to load
Clojure mode. Right now I’m writing a Markdown file and using Markdown
mode, which has lots of useful key bindings specific to working with
Markdown. When editing Clojure, it’s best to have a set of
Clojurespecific key bindings, like <strong>C-c C-k</strong> to load the
current buffer into a REPL and compile it.</p>
<p>Modes come in two flavors: <em>major</em> modes and <em>minor</em>
modes. Markdown mode and Clojure mode are major modes. Major modes are
usually set by Emacs when you open a file, but you can also set the mode
explicitly by running the relevant Emacs command, for example with
<strong>M-x</strong> <span
class="literal1"><strong>clojure-mode</strong></span> or
<strong>M-x</strong> <span
class="literal1"><strong>major-mode</strong></span>. Only one major mode
is active at a time.</p>
<p>Whereas major modes specialize Emacs for a certain file type or
language, minor modes usually provide functionality that’s useful across
file types. For example, abbrev mode “automatically expands text based
on pre-defined abbreviation definitions” (per the Emacs manual<sup><span
id="text_part0012.html_fn_01" class="calibre4"></span><a
href="#text_part0030.html_fn01" class="calibre4">1</a></sup>). You can
have multiple minor modes active at the same time.</p>
<p>You can see which modes are active on the <em>mode line</em>, as
shown in <a href="#text_part0012.html_ch2fig7" class="calibre4">Figure
2-7</a>.</p>
<div class="image">
<img src="images_00016.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0012.html_ch2fig7"
class="calibre4"></span><em>Figure 2-7: The mode line shows you which
modes are active.</em></p>
<p><span id="text_part0012.html_page_19" class="calibre4"></span>If you
open a file and Emacs doesn’t load a major mode for it, chances are that
one exists. You’ll just need to download its package. Speaking of which
. . .</p>
<h4 class="h2"
id="text_part0012.html_ch02lev2sec3"><em><strong>Installing
Packages</strong></em></h4>
<p>Many modes are distributed as <em>packages</em>, which are just
bundles of elisp files stored in a package repository. Emacs 24, which
you installed at the beginning of this chapter, makes it very easy to
browse and install packages. <strong>M-x</strong> <span
class="literal1"><strong>package-list-packages</strong></span> will show
you almost every package available; just make sure you run
<strong>M-x</strong> <span
class="literal1"><strong>package-refresh-contents</strong></span> first
so you get the latest list. You can install packages with
<strong>M-x</strong> <span
class="literal1"><strong>package-install</strong></span>.</p>
<p>You can also customize Emacs by loading your own elisp files or files
you find on the Internet. The “Beginner’s Guide to Emacs” (found at
<em><a
href="http://www.masteringemacs.org/articles/2010/10/04/beginners-guide-to-emacs/"
class="calibre4">http://www.masteringemacs.org/articles/2010/10/04/beginners-guide-to-emacs/</a></em>)
has a good description of how to load customizations under the section
“Loading New Packages” toward the bottom of the article.</p>
<h3 class="h2" id="text_part0012.html_ch02lev1sec7"><strong>Core Editing
Terminology and Key Bindings</strong></h3>
<p>If all you want to do is use Emacs like a text editor, you can skip
this section entirely! But you’ll be missing out on some great stuff. In
this section, we’ll go over key Emacs terms; how to select, cut, copy,
and paste text; how to select, cut, copy, and paste text (see what I did
there? Ha ha ha!); and how to move through the buffer efficiently.</p>
<div class="image">
<img src="images_00017.jpeg" class="calibre3" alt="image" />
</div>
<p>To get started, open a new buffer in Emacs and name it
<em>jack-handy</em>. Then enter the following Jack Handy quotations:</p>
<pre class="programs"><code>If you were a pirate, you know what would be the one thing that would really make you mad? Treasure chests with no handles. How the hell are you supposed to carry it?!

The face of a child can say it all, especially the mouth part of the face.

To me, boxing is like a ballet, except there&#39;s no music, no choreography, and the dancers hit each other.</code></pre>
<p>Use this example to experiment with navigation and editing in this
section.</p>
<h4 class="h2" id="text_part0012.html_ch02lev2sec4"><span
id="text_part0012.html_page_20"
class="calibre1"></span><em><strong>Point</strong></em></h4>
<p>If you’ve been following along, you should see a red-orange rectangle
in your Emacs buffer. This is the <em>cursor</em>, and it’s the
graphical representation of the <em>point</em>. Point is where all the
magic happens: you insert text at point, and most editing commands
happen in relation to point. And even though your cursor appears to rest
on top of a character, point is actually located between that character
and the previous one.</p>
<p>For example, place your cursor over the <em>f</em> in <em>If you were
a pirate</em>. Point is located between <em>I</em> and <em>f</em>. Now,
if you use <strong>C-k</strong>, all the text from the letter <em>f</em>
onward will disappear. <strong>C-k</strong> runs the command <span
class="literal1">kill-line</span>, which <em>kills</em> all text after
point on the current line (I’ll talk more about killing later). Undo
that change with <strong>C-/</strong>. Also, try your normal OS key
binding for undo; that should work as well.</p>
<h4 class="h2"
id="text_part0012.html_ch02lev2sec5"><em><strong>Movement</strong></em></h4>
<p>You can use your arrow keys to move point just like any other editor,
but many key bindings allow you to navigate more efficiently, as shown
in <a href="#text_part0012.html_ch2tab1" class="calibre4">Table
2-1</a>.</p>
<p><span id="text_part0012.html_ch2tab1"
class="calibre4"></span><strong>Table 2-1:</strong> Key Bindings for
Navigating Text</p>
<table class="topbot" data-border="0" data-cellpadding="0"
data-cellspacing="0" width="100%">
<thead class="calibre12">
<tr class="calibre13">
<th class="table_th" data-valign="top"><p><strong>Keys</strong></p></th>
<th class="table_th"
data-valign="top"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-a</strong></p></td>
<td class="table1" data-valign="top"><p>Move to beginning of
line.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>M-m</strong></p></td>
<td class="table1" data-valign="top"><p>Move to first non-whitespace
character on the line.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-e</strong></p></td>
<td class="table1" data-valign="top"><p>Move to end of line.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-f</strong></p></td>
<td class="table1" data-valign="top"><p>Move forward one
character.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-b</strong></p></td>
<td class="table1" data-valign="top"><p>Move backward one
character.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>M-f</strong></p></td>
<td class="table1" data-valign="top"><p>Move forward one word (I use
this a lot).</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>M-b</strong></p></td>
<td class="table1" data-valign="top"><p>Move backward one word (I use
this a lot, too).</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-s</strong></p></td>
<td class="table1" data-valign="top"><p>Regex search for text in current
buffer and move to it. Press <strong>C-s</strong> again to move to next
match.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-r</strong></p></td>
<td class="table1" data-valign="top"><p>Same as <strong>C-s</strong>,
but search in reverse.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>M-&lt;</strong></p></td>
<td class="table1" data-valign="top"><p>Move to beginning of
buffer.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>M-&gt;</strong></p></td>
<td class="table1" data-valign="top"><p>Move to end of buffer.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>M-g g</strong></p></td>
<td class="table1" data-valign="top"><p>Go to line.</p></td>
</tr>
</tbody>
</table>
<p>Go ahead and try out these key bindings in your <em>jack-handy</em>
buffer!</p>
<h4 class="h2"
id="text_part0012.html_ch02lev2sec6"><em><strong>Selection with
Regions</strong></em></h4>
<p>In Emacs, we don’t <em>select</em> text. We create <em>regions</em>,
and we do so by setting the <em>mark</em> with <strong>C-spc</strong>
(<span class="small">CTRL</span>-spacebar). Then, when you move point,
everything between mark and point is the region. It’s very similar to
<span class="small">SHIFT</span>-selecting text for basic purposes.</p>
<p><span id="text_part0012.html_page_21" class="calibre4"></span>For
example, do the following in your <em>jack-handy</em> buffer:</p>
<p>1. Go to the beginning of the file.</p>
<p>2. Use <strong>C-spc</strong>.</p>
<p>3. Use <strong>M-f</strong> twice. You should see a highlighted
region encompassing <em>If you</em>.</p>
<p>4. Press backspace. That should delete <em>If you</em>.</p>
<p>One cool thing about using mark instead of Shift-selecting text is
that you’re free to use all of Emacs’s movement commands after you set
the mark. For example, you could set a mark and then use
<strong>C-s</strong> to search for some bit of text hundreds of lines
down in your buffer. Doing so would create a very large region, and you
wouldn’t have to strain your pinky holding down <span
class="small">SHIFT</span>.</p>
<p>Regions also let you confine an operation to a limited area of the
buffer. Try this:</p>
<p>1. Create a region encompassing <em>The face of a child can say it
all</em>.</p>
<p>2. Use <strong>M-x</strong> <span
class="literal1"><strong>replace-string</strong></span> and replace
<em>face</em> with <em>head</em>.</p>
<p>This will perform the replacement within the current region rather
than the entire buffer after point, which is the default behavior.</p>
<h4 class="h2" id="text_part0012.html_ch02lev2sec7"><em><strong>Killing
and the Kill Ring</strong></em></h4>
<p>In most applications we can <em>cut</em> text, which is only mildly
violent. We can also <em>copy</em> and <em>paste</em>. Cutting and
copying add the selection to the clipboard, and pasting copies the
contents of the clipboard to the current application. In Emacs, we take
the homicidal approach and <em>kill</em> regions, adding them to the
<em>kill ring</em>. Don’t you feel <em>braver</em> and <em>truer</em>
knowing that you’re laying waste to untold kilobytes of text? We can
then <em>yank</em>, inserting the most recently killed text at point. We
can also <em>copy</em> text to the kill ring without actually killing
it.</p>
<p>Why bother with all this morbid terminology? Well, first, so you
won’t be frightened when you hear someone talking about killing things
in Emacs. But more important, Emacs allows you to do tasks that you
can’t do with the typical cut/copy/paste clipboard featureset.</p>
<p>Emacs stores multiple blocks of text on the kill ring, and you can
cycle through them. This is cool because you can cycle through to
retrieve text you killed a long time ago. Let’s see this in action:</p>
<p>1. Create a region over the word <em>Treasure</em> in the first
line.</p>
<p>2. Use <strong>M-w</strong>, which is bound to the <span
class="literal1">kill-ring-save</span> command. In general,
<strong>M-w</strong> is like copying. It adds the region to the kill
ring without deleting it from your buffer.</p>
<p>3. Move point to the word <em>choreography</em> on the last line.</p>
<p>4. Use <strong>M-d</strong>, which is bound to the <span
class="literal1">kill-word</span> command. This adds
<em>choreography</em> to the kill ring and deletes it from your
buffer.</p>
<p><span id="text_part0012.html_page_22" class="calibre4"></span>5. Use
<strong>C-y</strong>. This will yank the text you just killed,
<em>choreography</em>, inserting it at point.</p>
<p>6. Use <strong>M-y</strong>. This will remove <em>choreography</em>
and yank the next item on the kill ring, <em>Treasure</em>.</p>
<p>You can see some useful kill/yank key bindings in <a
href="#text_part0012.html_ch2tab2" class="calibre4">Table 2-2</a>.</p>
<p><span id="text_part0012.html_ch2tab2"
class="calibre4"></span><strong>Table 2-2:</strong> Key Bindings for
Killing and Yanking Text</p>
<table class="topbot" data-border="0" data-cellpadding="0"
data-cellspacing="0" width="100%">
<thead class="calibre12">
<tr class="calibre13">
<th class="table_th" data-valign="top"><p><strong>Keys</strong></p></th>
<th class="table_th"
data-valign="top"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-w</strong></p></td>
<td class="table1" data-valign="top"><p>Kill region.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>M-w</strong></p></td>
<td class="table1" data-valign="top"><p>Copy region to kill
ring.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-y</strong></p></td>
<td class="table1" data-valign="top"><p>Yank.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>M-y</strong></p></td>
<td class="table1" data-valign="top"><p>Cycle through kill ring after
yanking.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>M-d</strong></p></td>
<td class="table1" data-valign="top"><p>Kill word.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-k</strong></p></td>
<td class="table1" data-valign="top"><p>Kill line.</p></td>
</tr>
</tbody>
</table>
<h4 class="h2" id="text_part0012.html_ch02lev2sec8"><em><strong>Editing
and Help</strong></em></h4>
<p><a href="#text_part0012.html_ch2tab3" class="calibre4">Table 2-3</a>
shows some additional, useful, editing key bindings you should know
about for dealing with spacing and expanding text.</p>
<p><span id="text_part0012.html_ch2tab3"
class="calibre4"></span><strong>Table 2-3:</strong> Other Useful Editing
Key Bindings</p>
<table class="topbot" data-border="0" data-cellpadding="0"
data-cellspacing="0" width="100%">
<thead class="calibre12">
<tr class="calibre13">
<th class="table_th" data-valign="top"><p><strong>Keys</strong></p></th>
<th class="table_th"
data-valign="top"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>Tab</strong></p></td>
<td class="table1" data-valign="top"><p>Indent line.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-j</strong></p></td>
<td class="table1" data-valign="top"><p>New line and indent, equivalent
to <span class="small">ENTER</span> followed by <span
class="small">TAB</span>.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>M-/</strong></p></td>
<td class="table1" data-valign="top"><p>Hippie expand; cycles through
possible expansions of the text before point.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>M-\</strong></p></td>
<td class="table1" data-valign="top"><p>Delete all spaces and tabs
around point. (I use this one a lot.)</p></td>
</tr>
</tbody>
</table>
<p>Emacs also has excellent built-in help. The two key bindings shown in
<a href="#text_part0012.html_ch2tab4" class="calibre4">Table 2-4</a>
will serve you well.</p>
<p><span id="text_part0012.html_ch2tab4"
class="calibre4"></span><strong>Table 2-4:</strong> Key Bindings for
Built-in Help</p>
<table class="topbot" data-border="0" data-cellpadding="0"
data-cellspacing="0" width="100%">
<thead class="calibre12">
<tr class="calibre13">
<th class="table_th" data-valign="top"><p><strong>Keys</strong></p></th>
<th class="table_th"
data-valign="top"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-h k
<em>key-binding</em></strong></p></td>
<td class="table1" data-valign="top"><p>Describe the function bound to
the key binding. To get this to work, you actually perform the key
sequence after typing <strong>C-h k</strong>.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-h f</strong></p></td>
<td class="table1" data-valign="top"><p>Describe function.</p></td>
</tr>
</tbody>
</table>
<p>The help text appears in a new <em>window</em>, a concept I will
cover later in the chapter. For now, you can close help windows by
pressing <strong>C-x o q</strong>.</p>
<h3 class="h2" id="text_part0012.html_ch02lev1sec8"><span
id="text_part0012.html_page_23" class="calibre1"></span><strong>Using
Emacs with Clojure</strong></h3>
<p>Next, I’ll explain how to use Emacs to efficiently develop a Clojure
application. You’ll learn how to start a REPL process that’s connected
to Emacs and how to work with Emacs windows. Then I’ll cover a
cornucopia of useful key bindings for evaluating expressions, compiling
files, and performing other handy tasks. Finally, I’ll show you how to
handle Clojure errors and introduce some features of Paredit, an
optional minor mode, which is useful for writing and editing code in
Lisp-style languages.</p>
<p>If you want to start digging in to Clojure code, please do skip
ahead! You can always return later.</p>
<h4 class="h2" id="text_part0012.html_ch02lev2sec9"><em><strong>Fire Up
Your REPL!</strong></em></h4>
<p>As you learned in <a href="#text_part0011.html_ch01"
class="calibre4">Chapter 1</a>, a REPL allows you to interactively write
and run Clojure code. The REPL is a running Clojure program that gives
you a prompt and then reads your input, evaluates it, prints the result,
and loops back to the prompt. In <a href="#text_part0011.html_ch01"
class="calibre4">Chapter 1</a>, you started the REPL in a terminal
window with <span class="literal1">lein repl</span>. In this section,
you’ll start a REPL directly in Clojure.</p>
<p>To connect Emacs to a REPL, you’ll use the Emacs package CIDER,
available at <em><a href="https://github.com/clojure-emacs/cider/"
class="calibre4">https://github.com/clojure-emacs/cider/</a></em>. If
you followed the configuration instructions earlier in this chapter, you
should already have it installed, but you can also install it by running
<strong>M-x</strong> <span
class="literal1"><strong>package-install</strong></span>, entering <span
class="literal1"><strong>cider</strong></span>, and pressing <span
class="small">ENTER</span>.</p>
<p>CIDER allows you to start a REPL within Emacs and provides you with
key bindings that allow you to interact with the REPL more efficiently.
Go ahead and start a REPL session now. Using Emacs, open the file
<em>clojure-noob/src/clojure_noob/core.clj</em>, which you created in <a
href="#text_part0011.html_ch01" class="calibre4">Chapter 1</a>. Next,
use <strong>M-x</strong> <span
class="literal1"><strong>cider-jack-in</strong></span>. This starts the
REPL and creates a new buffer where you can interact with it. After a
short wait (it should be less than a minute), you should see something
like <a href="#text_part0012.html_ch2fig8" class="calibre4">Figure
2-8</a>.</p>
<div class="image">
<img src="images_00018.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0012.html_ch2fig8"
class="calibre4"></span><em>Figure 2-8: What your Emacs should look like
after running M-x <span class="literal1">cider-jack-in</span></em></p>
<p><span id="text_part0012.html_page_24" class="calibre4"></span>Now we
have two windows: our <em>core.clj</em> file is open on the left, and
the REPL is running on the right. If you’ve never seen Emacs split in
half like this, don’t worry! I’ll talk about how Emacs splits windows in
a second. In the meantime, try evaluating some code in the REPL. Type in
the following bolded lines. The result that you should see printed in
the REPL when you press <span class="small">ENTER</span> is shown after
each line of code. Don’t worry about the code at this time; I’ll cover
all these functions in the next chapter.</p>
<pre class="programs"><code>(+ 1 2 3 4)
; =&gt; 10
(map inc [1 2 3 4])
; =&gt; (2 3 4 5)
(reduce + [5 6 100])
; =&gt; 111</code></pre>
<p>Pretty nifty! You can use this REPL just as you used <span
class="literal1">lein repl</span> in the first chapter. You can also do
a whole lot more, but before I go into that, I’ll explain how to work
with split-screen Emacs.</p>
<h4 class="h2"
id="text_part0012.html_ch02lev2sec10"><em><strong>Interlude: Emacs
Windows and Frames</strong></em></h4>
<p>Let’s take a quick detour to talk about how Emacs handles frames and
windows, and to go over some useful window-related key bindings. Feel
free to skip this section if you’re already familiar with Emacs
windows.</p>
<p>Emacs was invented in, like, 1802 or something, so it uses
terminology slightly different from what you’re used to. What you would
normally refer to as a <em>window</em>, Emacs calls a <em>frame</em>,
and the frame can be split into multiple <em>windows</em>. Splitting
into multiple windows allows you to view more than one buffer at a time.
You already saw this happen when you ran <span
class="literal1">cider-jack-in</span> (see <a
href="#text_part0012.html_ch2fig9" class="calibre4">Figure 2-9</a>).</p>
<div class="image">
<img src="images_00019.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0012.html_ch2fig9"
class="calibre4"></span><em>Figure 2-9: In Emacs, a frame contains
windows.</em></p>
<p><span id="text_part0012.html_page_25" class="calibre4"></span><a
href="#text_part0012.html_ch2tab5" class="calibre4">Table 2-5</a> shows
several key bindings for working with the frame and windows.</p>
<p><span id="text_part0012.html_ch2tab5"
class="calibre4"></span><strong>Table 2-5:</strong> Emacs Window Key
Bindings</p>
<table class="topbot" data-border="0" data-cellpadding="0"
data-cellspacing="0" width="100%">
<thead class="calibre12">
<tr class="calibre13">
<th class="table_th" data-valign="top"><p><strong>Keys</strong></p></th>
<th class="table_th"
data-valign="top"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-x o</strong></p></td>
<td class="table1" data-valign="top"><p>Switch cursor to another window.
Try this now to switch between your Clojure file and the REPL.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-x 1</strong></p></td>
<td class="table1" data-valign="top"><p>Delete all other windows,
leaving only the current window in the frame. This doesn’t close your
buffers, and it won’t cause you to lose any work.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-x 2</strong></p></td>
<td class="table1" data-valign="top"><p>Split frame above and
below.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-x 3</strong></p></td>
<td class="table1" data-valign="top"><p>Split frame side by
side.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-x 0</strong></p></td>
<td class="table1" data-valign="top"><p>Delete current window.</p></td>
</tr>
</tbody>
</table>
<p>I encourage you to try the Emacs window key bindings. For example,
put your cursor in the left window, the one with the Clojure file, and
use <strong>C-x 1</strong>. The other window should disappear, and you
should see only the Clojure code. Then do the following:</p>
<p>• Use <strong>C-x 3</strong> to split the window side by side
again.</p>
<p>• Use <strong>C-x o</strong> to switch to the right window.</p>
<p>• Use <strong>C-x b</strong> <span
class="literal1"><strong>*cider-repl*</strong></span> to switch to the
CIDER buffer in the right window.</p>
<p>Once you’ve experimented a bit, set up Emacs so that it contains two
side-by-side windows with Clojure code on the left and the CIDER buffer
on the right, as in the previous images. If you’re interested in
learning more about windows and frames, the Emacs manual has a ton of
info: see <em><a
href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows"
class="calibre4">http://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows</a></em>.</p>
<p>Now that you can navigate Emacs windows, it’s time to learn some
Clojure development key bindings!</p>
<h4 class="h2" id="text_part0012.html_ch02lev2sec11"><em><strong>A
Cornucopia of Useful Key Bindings</strong></em></h4>
<p>Now you’re ready to learn some key bindings that will reveal the true
power of using Emacs for Clojure projects. These commands will let you
evaluate, tweak, compile, and run code with just a few dainty
keystrokes. Let’s start by going over how to quickly evaluate an
expression.</p>
<p>At the bottom of <em>core.clj</em>, add the following:</p>
<pre class="programs"><code>(println &quot;Cleanliness is next to godliness&quot;)</code></pre>
<p>Now use <strong>C-e</strong> to navigate to the end of the line, and
then use <strong>C-x C-e</strong>. The text <span
class="literal1">Cleanliness is next to godliness</span> should appear
in the CIDER buffer, as shown in <a href="#text_part0012.html_ch2fig10"
class="calibre4">Figure 2-10</a>.</p>
<div class="image">
<span id="text_part0012.html_page_26" class="calibre4"></span><img
src="images_00020.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0012.html_ch2fig10"
class="calibre4"></span><em>Figure 2-10: Instantly evaluating code from
another buffer in the REPL</em></p>
<p>The key binding <strong>C-x C-e</strong> runs the command <span
class="literal1">cider-eval-last-expression</span>. As the name
suggests, this command sends the expression immediately preceding point
to the REPL, which then evaluates the expression. You can also try
<strong>C-u C-x C-e</strong>, which prints the result of the evaluation
after point.</p>
<p>Now let’s try to run the <span class="literal1">-main</span> function
we wrote in <a href="#text_part0011.html_ch01" class="calibre4">Chapter
1</a> so we can let the world know that we’re little teapots.</p>
<p>In the <em>core.clj</em> buffer, use <strong>C-c M-n</strong>. This
key binding sets the namespace to the namespace listed at the top of
your current file, so the prompt in the right window should now read
<span class="literal1">clojure-noob.core&gt;</span>. I haven’t gone into
detail about namespaces yet, but for now it’s enough to know that a
namespace is an organizational mechanism that allows us to avoid naming
conflicts. Next, enter <span
class="literal1"><strong>(-main)</strong></span> at the prompt. The REPL
should print <span class="literal1">I'm a little teapot!</span> How
exciting!</p>
<p>Now let’s create a new function and run it. At the bottom of
<em>core.clj</em>, add the following:</p>
<pre class="programs"><code>(defn train
  []
  (println &quot;Choo choo!&quot;))</code></pre>
<p>When you’re done, save your file and use <strong>C-c C-k</strong> to
compile your current file within the REPL session. (You have to compile
your code for the REPL to be aware of your changes.) Now if you run
<span class="literal1">(train)</span> in the REPL, it will echo back
<span class="literal1">Choo choo!</span>.</p>
<p>While still in the REPL, try <strong>C-</strong>↑ (<span
class="small">CTRL</span> plus the up arrow key). <strong>C-</strong>↑
and <strong>C-</strong>↓ cycle through your REPL history, which includes
all the Clojure expressions that you’ve asked the REPL to evaluate.</p>
<p>Note for Mac users: by default, OS X maps <strong>C-</strong>↑,
<strong>C-</strong>↓, <strong>C-</strong>←, and <strong>C-</strong>→ to
Mission Control commands. You can change your Mac key bindings by
opening System Preferences, and then going to Keyboard ▸ Shortcuts ▸
Mission Control.</p>
<p>Finally, try this:</p>
<p>1. Type <span class="literal1"><strong>(-main</strong></span> at the
REPL prompt. Note the lack of a closing parenthesis.</p>
<p>2. Press <strong>C-enter</strong>.</p>
<p><span id="text_part0012.html_page_27" class="calibre4"></span>CIDER
should close the parenthesis and evaluate the expression. This is just a
nice little convenience that CIDER provides for dealing with so many
parentheses.</p>
<p>CIDER also has a few key bindings that are great when you’re learning
Clojure. Pressing <strong>C-c C-d C-d</strong> will display
documentation for the symbol under point, which can be a huge
time-saver. When you’re done with the documentation, press
<strong>q</strong> to close the documentation buffer. The key binding
<strong>M-.</strong> will navigate to the source code for the symbol
under point, and <strong>M-,</strong> will return you to your original
buffer and position. Finally, <strong>C-c C-d C-a</strong> lets you
search for arbitrary text across function names and documentation. This
is a great way to find a function when you can’t exactly remember its
name.</p>
<p>The CIDER README (<em><a
href="https://github.com/clojure-emacs/cider/"
class="calibre4">https://github.com/clojure-emacs/cider/</a></em>) has a
comprehensive list of key bindings that you can learn over time, but for
now, <a href="#text_part0012.html_ch2tab6" class="calibre4">Tables
2-6</a> and <a href="#text_part0012.html_ch2tab7"
class="calibre4">2-7</a> contain a summary of the key bindings we just
went over.</p>
<p><span id="text_part0012.html_ch2tab6"
class="calibre4"></span><strong>Table 2-6:</strong> Clojure Buffer Key
Bindings</p>
<table class="topbot" data-border="0" data-cellpadding="0"
data-cellspacing="0" width="100%">
<thead class="calibre12">
<tr class="calibre13">
<th class="table_th" data-valign="top"><p><strong>Keys</strong></p></th>
<th class="table_th"
data-valign="top"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-c
M-n</strong></p></td>
<td class="table1" data-valign="top"><p>Switch to namespace of current
buffer.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-x
C-e</strong></p></td>
<td class="table1" data-valign="top"><p>Evaluate expression immediately
preceding point.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-c
C-k</strong></p></td>
<td class="table1" data-valign="top"><p>Compile current buffer.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-c C-d
C-d</strong></p></td>
<td class="table1" data-valign="top"><p>Display documentation for symbol
under point.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>M-. and
M-,</strong></p></td>
<td class="table1" data-valign="top"><p>Navigate to source code for
symbol under point and return to your original buffer.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-c C-d
C-a</strong></p></td>
<td class="table1" data-valign="top"><p>Apropros search; find arbitrary
text across function names and documentation.</p></td>
</tr>
</tbody>
</table>
<p><span id="text_part0012.html_ch2tab7"
class="calibre4"></span><strong>Table 2-7:</strong> CIDER Buffer Key
Bindings</p>
<table class="topbot" data-border="0" data-cellpadding="0"
data-cellspacing="0" width="100%">
<thead class="calibre12">
<tr class="calibre13">
<th class="table_th" data-valign="top"><p><strong>Keys</strong></p></th>
<th class="table_th"
data-valign="top"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-</strong>↑<strong>,
C-</strong>↓</p></td>
<td class="table1" data-valign="top"><p>Cycle through REPL
history.</p></td>
</tr>
<tr class="calibre13">
<td class="table1"
data-valign="top"><p><strong>C-enter</strong></p></td>
<td class="table1" data-valign="top"><p>Close parentheses and
evaluate.</p></td>
</tr>
</tbody>
</table>
<h4 class="h2" id="text_part0012.html_ch02lev2sec12"><em><strong>How to
Handle Errors</strong></em></h4>
<p>In this section, you’ll write some buggy code so you can see how
Emacs responds to it and how you can recover from the error and continue
on your merry way. You’ll do this in both the REPL buffer and the
<em>core.clj</em> buffer. Let’s start with the REPL. At the prompt, type
<span class="literal1"><strong>(map)</strong></span> and press <span
class="small">ENTER</span>. You should see something like <a
href="#text_part0012.html_ch2fig11" class="calibre4">Figure
2-11</a>.</p>
<div class="image">
<span id="text_part0012.html_page_28" class="calibre4"></span><img
src="images_00021.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0012.html_ch2fig11"
class="calibre4"></span><em>Figure 2-11: This is what happens when you
run bad code in the REPL.</em></p>
<p>As you can see, calling <span class="literal1">map</span> with no
arguments causes Clojure to lose its mind—it shows an <span
class="literal1">ArityException</span> error message in your REPL buffer
and fills your left window with text that looks like the ravings of a
madman. These ravings are the <em>stack trace</em>, which shows the
function that actually threw the exception, along with which function
called <em>that</em> function, down the stack of function calls.</p>
<p>Clojure’s stack traces can be difficult to decipher when you’re just
starting, but after a while you’ll learn to get useful information from
them. CIDER gives you a hand by allowing you to filter stack traces,
which reduces noise so you can zero in on the cause of your exception.
Line 2 of the <span class="literal1">*cider-error*</span> buffer has the
filters Clojure, Java, REPL, Tooling, Duplicates, and All. You can click
each option to activate that filter. You can also click each stack trace
line to jump to the corresponding source code.</p>
<p>Here’s how to close the stack trace in the left window:</p>
<p>1. Use <strong>C-x o</strong> to switch to the window.</p>
<p>2. Press <strong>q</strong> to close the stack trace and go back to
CIDER.</p>
<p>If you want to view the error again, you can switch to the <span
class="literal1">*cider-error*</span> buffer. You can also get error
messages when trying to compile files. To see this, go to the
<em>core.clj</em> buffer, write some buggy code, and compile:</p>
<p>1. Add <span class="literal1">(map)</span> to the end.</p>
<p>2. Use <strong>C-c C-k</strong> to compile.</p>
<p>You should see a <span class="literal1">*cider-error*</span> buffer
similar to the one you saw earlier. Again, press <strong>q</strong> to
close the stack trace.</p>
<h4 class="h2"
id="text_part0012.html_ch02lev2sec13"><em><strong>Paredit</strong></em></h4>
<p>While writing code in the Clojure buffer, you may have noticed some
unexpected things happening. For example, every time you type a left
parenthesis, a right parenthesis immediately gets inserted.</p>
<p>This occurs thanks to <em>paredit-mode</em>, a minor mode that turns
Lisp’s profusion of parentheses from a liability into an asset. Paredit
ensures that all parentheses, double quotes, and brackets are closed,
relieving you of that odious burden.</p>
<p><span id="text_part0012.html_page_29" class="calibre4"></span>Paredit
also offers key bindings to easily navigate and alter the structure
created by all those parentheses. In the next section, I’ll go over the
most useful key bindings, but you can also check out a comprehensive
cheat sheet at <em><a
href="https://github.com/georgek/paredit-cheatsheet/blob/master/paredit-cheatsheet.pdf"
class="calibre4">https://github.com/georgek/paredit-cheatsheet/blob/master/paredit-cheatsheet.pdf</a></em>
(in the cheat sheet, the red pipe represents point).</p>
<p>However, if you’re not used to it, paredit can sometimes be annoying.
I think it’s more than worth your while to take some time to learn it,
but you can always disable it with <strong>M-x</strong> <span
class="literal1"><strong>paredit-mode</strong></span>, which toggles the
mode on and off.</p>
<p>The following section shows you the most useful key bindings.</p>
<h5 class="h3" id="text_part0012.html_ch02lev3sec1"><strong>Wrapping and
Slurping</strong></h5>
<p><em>Wrapping</em> surrounds the expression after point with
parentheses. <em>Slurping</em> moves a closing parenthesis to include
the next expression to the right. For example, say we start with
this:</p>
<pre class="programs"><code>(+ 1 2 3 4)</code></pre>
<p>and we want to get this:</p>
<pre class="programs"><code>(+ 1 (* 2 3) 4)</code></pre>
<p>We can wrap the <span class="literal1">2</span>, add an asterisk, and
then slurp the <span class="literal1">3</span>. First, place point,
which is represented here as a vertical pipe, <span
class="literal1">|</span>:</p>
<pre class="programs"><code>(+ 1 |2 3 4)</code></pre>
<p>Then type <strong>M-(</strong>, the binding for
<em>paredit-wrap-round</em>, getting this result:</p>
<pre class="programs"><code>(+ 1 (|2) 3 4)</code></pre>
<p>Add the asterisk and a space:</p>
<pre class="programs"><code>(+ 1 (* |2) 3 4)</code></pre>
<p>To slurp in the <span class="literal1">3</span>, press
<strong>C-</strong>→:</p>
<pre class="programs"><code>(+ 1 (* |2 3) 4)</code></pre>
<p>This makes it easy to add and extend parentheses without wasting
precious moments holding down arrow keys to move point.</p>
<h5 class="h3"
id="text_part0012.html_ch02lev3sec2"><strong>Barfing</strong></h5>
<p>Suppose, in the preceding example, you accidentally slurped the four.
To unslurp it (also known as <em>barfing</em>), place your cursor (<span
class="literal1">|</span>) anywhere in the inner parentheses:</p>
<pre class="programs"><code>(+ 1 (|* 2 3 4))</code></pre>
<p><span id="text_part0012.html_page_30" class="calibre4"></span>Then
use <strong>C-</strong>←:</p>
<pre class="programs"><code>(+ 1 (|* 2 3) 4)</code></pre>
<p>Ta-da! Now you know how to expand and contract parentheses at
will.</p>
<h5 class="h3"
id="text_part0012.html_ch02lev3sec3"><strong>Navigation</strong></h5>
<p>Often when writing in a Lisp dialect, you’ll work with expressions
like this:</p>
<pre class="programs"><code>(map (comp record first)
     (d/q &#39;[:find ?post
            :in $ ?search
            :where
            [(fulltext $ :post/content ?search)
             [[?post ?content]]]]
          (db/db)
          (:q params)))</code></pre>
<p>With this kind of expression, it’s useful to jump quickly from one
subexpression to the next. If you put point right before an opening
parenthesis, <strong>C-M-f</strong> will take you to the closing
parenthesis. Similarly, if point is right after a closing parenthesis,
<strong>C-M-b</strong> will take you to the opening parenthesis.</p>
<p><a href="#text_part0012.html_ch2tab8" class="calibre4">Table 2-8</a>
summarizes the paredit key bindings you just learned.</p>
<p><span id="text_part0012.html_ch2tab8"
class="calibre4"></span><strong>Table 2-8:</strong> Paredit Key
Bindings</p>
<table class="topbot" data-border="0" data-cellpadding="0"
data-cellspacing="0" width="100%">
<thead class="calibre12">
<tr class="calibre13">
<th class="table_th" data-valign="top"><p><strong>Keys</strong></p></th>
<th class="table_th"
data-valign="top"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>M-x</strong> <span
class="literal1"><strong>paredit-mode</strong></span></p></td>
<td class="table1" data-valign="top"><p>Toggle paredit mode.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>M-(</strong></p></td>
<td class="table1" data-valign="top"><p>Surround expression after point
in parentheses (paredit-wrap-round).</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-</strong>←</p></td>
<td class="table1" data-valign="top"><p>Slurp; move closing parenthesis
to the right to include next expression.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-</strong>→</p></td>
<td class="table1" data-valign="top"><p>Barf; move closing parenthesis
to the left to exclude last expression.</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p><strong>C-M-f</strong>,
<strong>C-M-b</strong></p></td>
<td class="table1" data-valign="top"><p>Move to the opening/closing
parenthesis.</p></td>
</tr>
</tbody>
</table>
<h3 class="h2" id="text_part0012.html_ch02lev1sec9"><strong>Continue
Learning</strong></h3>
<p>Emacs is one of the longest-lived editors, and its adherents often
approach fanaticism in their enthusiasm for it. It can be awkward to use
at first, but stick with it and you will be amply rewarded over your
lifetime.</p>
<p>Whenever I open Emacs, I feel inspired. Like a craftsman entering his
workshop, I feel a realm of possibility open before me. I feel the
comfort of an environment that has evolved over time to fit me
perfectly—an assortment of packages and key bindings that help me bring
ideas to life day after day.</p>
<p><span id="text_part0012.html_page_31" class="calibre4"></span>These
resources will help you as you continue on your Emacs journey:</p>
<p>• <em>The Emacs Manual</em> provides excellent, comprehensive
instructions. Spend some time with it every morning! Download the PDF
and read it on the go: <em><a
href="http://www.gnu.org/software/emacs/manual/html_node/emacs/index.html#Top"
class="calibre4">http://www.gnu.org/software/emacs/manual/html_node/emacs/index.html#Top</a></em>.</p>
<p>• <em>The Emacs Reference Card</em> is a handy cheat sheet: <em><a
href="http://www.ic.unicamp.br/~helio/disciplinas/MC102/Emacs_Reference_Card.pdf"
class="calibre4">http://www.ic.unicamp.br/~helio/disciplinas/MC102/Emacs_Reference_Card.pdf</a></em>.</p>
<p>• <em>Mastering Emacs</em> by Mickey Petersen is one of the best
Emacs resources available. Start with the reading guide: <em><a
href="http://www.masteringemacs.org/reading-guide/"
class="calibre4">http://www.masteringemacs.org/reading-guide/</a></em>.</p>
<p>• For the more visually minded folks, I recommend the hand-drawn “How
to Learn Emacs: A Beginner’s Guide to Emacs 24 or Later” by Sacha Chua:
<em><a
href="http://sachachua.com/blog/wp-content/uploads/2013/05/How-to-Learn-Emacs8.png"
class="calibre4">http://sachachua.com/blog/wp-content/uploads/2013/05/How-to-Learn-Emacs8.png</a></em>.</p>
<p>• Just press <strong>C-h t</strong> for the built-in tutorial.</p>
<h3 class="h2"
id="text_part0012.html_ch02lev1sec10"><strong>Summary</strong></h3>
<p>Whew! You’ve covered a lot of ground. You now know about Emacs’s true
nature as a Lisp interpreter. Key bindings act as shortcuts to execute
elisp functions, and modes are collections of key bindings and
functions. You learned how to interact with Emacs on its own terms and
mastered buffers, windows, regions, killing, and yanking. Finally, you
learned how to easily work with Clojure using CIDER and paredit.</p>
<p>With all of this hard-won Emacs knowledge under your belt, it’s time
to start learning Clojure in earnest!<span
id="text_part0012.html_page_32" class="calibre4"></span></p>
<p><span id="text_part0013.html"></span></p>
<h1 class="part" id="text_part0013.html_part02"><span
id="text_part0013.html_page_33" class="calibre1"></span><strong><span
class="big">Part II</span></strong><br />
<strong>Language Fundamentals</strong><span
id="text_part0013.html_page_34" class="calibre1"></span></h1>
<p><span id="text_part0014.html"></span></p>
<h2 class="h1" id="text_part0014.html_ch03"><span
id="text_part0014.html_page_35" class="calibre1"></span><strong><span
class="big1">3</span></strong><br />
<strong>Do Things: A Clojure Crash Course</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>It’s time to learn how to actually <em>do things</em> with Clojure!
Hot damn! Although you’ve undoubtedly heard of Clojure’s awesome
concurrency support and other stupendous features, Clojure’s most
salient characteristic is that it is a Lisp. In this chapter, you’ll
explore the elements that compose this Lisp core: syntax, functions, and
data. Together they will give you a solid foundation for representing
and solving problems in Clojure.</p>
<p>After laying this groundwork, you will be able to write some super
important code. In the last section, you’ll tie everything together by
creating a model of a hobbit and writing a function to hit it in a
random spot. Super! Important!</p>
<p><span id="text_part0014.html_page_36" class="calibre4"></span>As you
move through the chapter, I recommend that you type the examples in a
REPL and run them. Programming in a new language is a skill, and just
like yodeling or synchronized swimming, you have to practice to learn
it. By the way, <em>Synchronized Swimming for Yodelers for the Brave and
True</em> will be published in August of 20never. Keep an eye out for
it!</p>
<h3 class="h2"
id="text_part0014.html_ch03lev1sec1"><strong>Syntax</strong></h3>
<p>Clojure’s syntax is simple. Like all Lisps, it employs a uniform
structure, a handful of special operators, and a constant supply of
parentheses delivered from the parenthesis mines hidden beneath the
Massachusetts Institute of Technology, where Lisp was born.</p>
<h4 class="h2"
id="text_part0014.html_ch03lev2sec1"><em><strong>Forms</strong></em></h4>
<p>All Clojure code is written in a uniform structure. Clojure
recognizes two kinds of structures:</p>
<p>• Literal representations of data structures (like numbers, strings,
maps, and vectors)</p>
<p>• Operations</p>
<p>We use the term <em>form</em> to refer to valid code. I’ll also
sometimes use <em>expression</em> to refer to Clojure forms. But don’t
get too hung up on the terminology. Clojure <em>evaluates</em> every
form to produce a value. These literal representations are all valid
forms:</p>
<pre class="programs"><code>1
&quot;a string&quot;
[&quot;a&quot; &quot;vector&quot; &quot;of&quot; &quot;strings&quot;]</code></pre>
<p>Your code will rarely contain free-floating literals, of course,
because they don’t actually do anything on their own. Instead, you’ll
use literals in operations. Operations are how you <em>do things</em>.
All operations take the form <em>opening parenthesis, operator,
operands, closing parenthesis</em>:</p>
<pre class="programs"><code>(operator operand1 operand2 ... operandn)</code></pre>
<p>Notice that there are no commas. Clojure uses whitespace to separate
operands, and it treats commas as whitespace. Here are some example
operations:</p>
<pre class="programs"><code>(+ 1 2 3)
; =&gt; 6


(str &quot;It was the panda &quot; &quot;in the library &quot; &quot;with a dust buster&quot;)
; =&gt; &quot;It was the panda in the library with a dust buster&quot;</code></pre>
<p><span id="text_part0014.html_page_37" class="calibre4"></span>In the
first operation, the operator <span class="literal1">+</span> adds the
operands <span class="literal1">1</span>, <span
class="literal1">2</span>, and <span class="literal1">3</span>. In the
second operation, the operator <span class="literal1">str</span>
concatenates three strings to form a new string. Both are valid forms.
Here’s something that is not a form because it doesn’t have a closing
parenthesis:</p>
<pre class="programs"><code>(+</code></pre>
<div class="image">
<img src="images_00022.jpeg" class="calibre3" alt="image" />
</div>
<p>Clojure’s structural uniformity is probably different from what
you’re used to. In other languages, different operations might have
different structures depending on the operator and the operands. For
example, JavaScript employs a smorgasbord of infix notation, dot
operators, and parentheses:</p>
<pre class="programs"><code>1 + 2 + 3
&quot;It was the panda &quot;.concat(&quot;in the library &quot;, &quot;with a dust buster&quot;)</code></pre>
<p>Clojure’s structure is very simple and consistent by comparison. No
matter which operator you’re using or what kind of data you’re operating
on, the structure is the same.</p>
<h4 class="h2" id="text_part0014.html_ch03lev2sec2"><em><strong>Control
Flow</strong></em></h4>
<p>Let’s look at three basic control flow operators: <span
class="literal1">if</span>, <span class="literal1">do</span>, and <span
class="literal1">when</span>. Throughout the book you’ll encounter more,
but these will get you started.</p>
<h5 class="h3"
id="text_part0014.html_ch03lev3sec1"><strong>if</strong></h5>
<p>This is the general structure for an <span class="literal1">if</span>
expression:</p>
<pre class="programs"><code>(if boolean-form
  then-form
  optional-else-form)</code></pre>
<p>A Boolean form is just a form that evaluates to a truthy or falsey
value. You’ll learn about truthiness and falsiness in the next section.
Here are a couple of <span class="literal1">if</span> examples:</p>
<pre class="programs"><code>(if true
  &quot;By Zeus&#39;s hammer!&quot;
  &quot;By Aquaman&#39;s trident!&quot;)
; =&gt; &quot;By Zeus&#39;s hammer!&quot;


(if false
  &quot;By Zeus&#39;s hammer!&quot;
  &quot;By Aquaman&#39;s trident!&quot;)
; =&gt; &quot;By Aquaman&#39;s trident!&quot;</code></pre>
<p><span id="text_part0014.html_page_38" class="calibre4"></span>The
first example returns <span class="literal1">"By Zeus's hammer!"</span>
because the Boolean form evaluates to <span
class="literal1">true</span>, a truthy value, and the second example
returns <span class="literal1">"By Aquaman's trident!"</span> because
its Boolean form, <span class="literal1">false</span>, evaluates to a
falsey value.</p>
<p>You can also omit the <span class="literal1">else</span> branch. If
you do that and the Boolean expression is false, Clojure returns <span
class="literal1">nil</span>, like this:</p>
<pre class="programs"><code>(if false
  &quot;By Odin&#39;s Elbow!&quot;)
; =&gt; nil</code></pre>
<p>Notice that <span class="literal1">if</span> uses operand position to
associate operands with the <span class="literal1">then</span> and <span
class="literal1">else</span> branches: the first operand is the <span
class="literal1">then</span> branch, and the second operand is the
(optional) <span class="literal1">else</span> branch. As a result, each
branch can have only one form. This is different from most languages.
For example, you can write this in Ruby:</p>
<pre class="programs"><code>if true
  doer.do_thing(1)
  doer.do_thing(2)
else
  other_doer.do_thing(1)
  other_doer.do_thing(2)
end</code></pre>
<p>To get around this apparent limitation, you can use the <span
class="literal1">do</span> operator.</p>
<h5 class="h3"
id="text_part0014.html_ch03lev3sec2"><strong>do</strong></h5>
<p>The <span class="literal1">do</span> operator lets you <em>wrap
up</em> multiple forms in parentheses and run each of them. Try the
following in your REPL:</p>
<pre class="programs"><code>(if true
  (do (println &quot;Success!&quot;)
      &quot;By Zeus&#39;s hammer!&quot;)
  (do (println &quot;Failure!&quot;)
      &quot;By Aquaman&#39;s trident!&quot;))
; =&gt; Success!
; =&gt; &quot;By Zeus&#39;s hammer!&quot;</code></pre>
<p>This operator lets you do multiple things in each of the <span
class="literal1">if</span> expression’s branches. In this case, two
things happen: <span class="literal1">Success!</span> is printed in the
REPL, and <span class="literal1">"By Zeus's hammer!"</span> is returned
as the value of the entire <span class="literal1">if</span>
expression.</p>
<h5 class="h3"
id="text_part0014.html_ch03lev3sec3"><strong>when</strong></h5>
<p>The <span class="literal1">when</span> operator is like a combination
of <span class="literal1">if</span> and <span
class="literal1">do</span>, but with no <span
class="literal1">else</span> branch. Here’s an example:</p>
<pre class="programs"><code>(when true
  (println &quot;Success!&quot;)
  &quot;abra cadabra&quot;)

; =&gt; Success!
; =&gt; &quot;abra cadabra&quot;</code></pre>
<p>Use <span class="literal1">when</span> if you want to do multiple
things when some condition is true, and you always want to return <span
class="literal1">nil</span> when the condition is false.</p>
<h5 class="h3" id="text_part0014.html_ch03lev3sec4"><strong>nil, true,
false, Truthiness, Equality, and Boolean Expressions</strong></h5>
<p>Clojure has <span class="literal1">true</span> and <span
class="literal1">false</span> values. <span class="literal1">nil</span>
is used to indicate <em>no value</em> in Clojure. You can check if a
value is <span class="literal1">nil</span> with the appropriately named
<span class="literal1">nil?</span> function:</p>
<pre class="programs"><code>(nil? 1)
; =&gt; false


(nil? nil)
; =&gt; true</code></pre>
<p>Both <span class="literal1">nil</span> and <span
class="literal1">false</span> are used to represent logical falsiness,
whereas all other values are logically truthy. <em>Truthy</em> and
<em>falsey</em> refer to how a value is treated in a Boolean expression,
like the first expression passed to <span
class="literal1">if</span>:</p>
<pre class="programs"><code>(if &quot;bears eat beets&quot;
  &quot;bears beets Battlestar Galactica&quot;)
; =&gt; &quot;bears beets Battlestar Galactica&quot;


(if nil
  &quot;This won&#39;t be the result because nil is falsey&quot;
  &quot;nil is falsey&quot;)
; =&gt; &quot;nil is falsey&quot;</code></pre>
<p>In the first example, the string <span class="literal1">"bears eat
beets"</span> is considered truthy, so the <span
class="literal1">if</span> expression evaluates to <span
class="literal1">"bears beets Battlestar Galactica"</span>. The second
example shows a falsey value as falsey.</p>
<p>Clojure’s equality operator is <span class="literal1">=</span>:</p>
<pre class="programs"><code>(= 1 1)
; =&gt; true


(= nil nil)
; =&gt; true


(= 1 2)
; =&gt; false</code></pre>
<p>Some other languages require you to use different operators when
comparing values of different types. For example, you might have to use
some kind of special string equality operator made just for strings. But
you don’t need anything weird or tedious like that to test for equality
when using Clojure’s built-in data structures.</p>
<p><span id="text_part0014.html_page_40" class="calibre4"></span>Clojure
uses the Boolean operators <span class="literal1">or</span> and <span
class="literal1">and</span>. <span class="literal1">or</span> returns
either the first truthy value or the last value. <span
class="literal1">and</span> returns the first falsey value or, if no
values are falsey, the last truthy value. Let’s look at <span
class="literal1">or</span> first:</p>
<pre class="programs"><code>(or false nil :large_I_mean_venti :why_cant_I_just_say_large)
; =&gt; :large_I_mean_venti


(or (= 0 1) (= &quot;yes&quot; &quot;no&quot;))
; =&gt; false


(or nil)
; =&gt; nil</code></pre>
<p>In the first example, the return value is <span
class="literal1">:large_I_mean_venti</span> because it’s the first
truthy value. The second example has no truthy values, so <span
class="literal1">or</span> returns the last value, which is <span
class="literal1">false</span>. In the last example, once again no truthy
values exist, and <span class="literal1">or</span> returns the last
value, which is <span class="literal1">nil</span>. Now let’s look at
<span class="literal1">and</span>:</p>
<pre class="programs"><code>(and :free_wifi :hot_coffee)
; =&gt; :hot_coffee


(and :feelin_super_cool nil false)
; =&gt; nil</code></pre>
<p>In the first example, <span class="literal1">and</span> returns the
last truthy value, <span class="literal1">:hot_coffee</span>. In the
second example, <span class="literal1">and</span> returns <span
class="literal1">nil</span>, which is the first falsey value.</p>
<h4 class="h2" id="text_part0014.html_ch03lev2sec3"><em><strong>Naming
Values with def</strong></em></h4>
<p>You use <span class="literal1">def</span> to <em>bind</em> a name to
a value in Clojure:</p>
<pre class="programs"><code>(def failed-protagonist-names
  [&quot;Larry Potter&quot; &quot;Doreen the Explorer&quot; &quot;The Incredible Bulk&quot;])


failed-protagonist-names
; =&gt; [&quot;Larry Potter&quot; &quot;Doreen the Explorer&quot; &quot;The Incredible Bulk&quot;]</code></pre>
<div class="image">
<img src="images_00023.jpeg" class="calibre3" alt="image" />
</div>
<p>In this case, you’re binding the name <span
class="literal1">failed-protagonist-names</span> to a vector containing
three strings (you’ll learn about vectors in “<a
href="#text_part0014.html_ch03lev2sec8" class="calibre4">Vectors</a>” on
<a href="#text_part0014.html_page_45" class="calibre4">page 45</a>).</p>
<p>Notice that I’m using the term <em>bind</em>, whereas in other
languages you’d say you’re <em>assigning</em> a value to a
<em>variable</em>. Those other languages typically encourage you to
perform multiple assignments to the same variable.</p>
<p><span id="text_part0014.html_page_41" class="calibre4"></span>For
example, in Ruby you might perform multiple assignments to a variable to
build up its value:</p>
<pre class="programs"><code>severity = :mild
error_message = &quot;OH GOD! IT&#39;S A DISASTER! WE&#39;RE &quot;
if severity == :mild
  error_message = error_message + &quot;MILDLY INCONVENIENCED!&quot;
else
  error_message = error_message + &quot;DOOOOOOOMED!&quot;
end</code></pre>
<p>You might be tempted to do something similar in Clojure:</p>
<pre class="programs"><code>(def severity :mild)
(def error-message &quot;OH GOD! IT&#39;S A DISASTER! WE&#39;RE &quot;)
(if (= severity :mild)
  (def error-message (str error-message &quot;MILDLY INCONVENIENCED!&quot;))
  (def error-message (str error-message &quot;DOOOOOOOMED!&quot;)))</code></pre>
<p>However, changing the value associated with a name like this can make
it harder to understand your program’s behavior because it’s more
difficult to know which value is associated with a name or why that
value might have changed. Clojure has a set of tools for dealing with
change, which you’ll learn about in <a href="#text_part0022.html_ch10"
class="calibre4">Chapter 10</a>. As you learn Clojure, you’ll find that
you’ll rarely need to alter a name/value association. Here’s one way you
could write the preceding code:</p>
<pre class="programs"><code>(defn error-message
  [severity]
  (str &quot;OH GOD! IT&#39;S A DISASTER! WE&#39;RE &quot;
       (if (= severity :mild)
         &quot;MILDLY INCONVENIENCED!&quot;
         &quot;DOOOOOOOMED!&quot;)))


(error-message :mild)
; =&gt; &quot;OH GOD! IT&#39;S A DISASTER! WE&#39;RE MILDLY INCONVENIENCED!&quot;</code></pre>
<p>Here, you create a function, <span
class="literal1">error-message</span>, which accepts a single argument,
<span class="literal1">severity</span>, and uses that to determine which
string to return. You then call the function with <span
class="literal1">:mild</span> for the severity. You’ll learn all about
creating functions in “<a href="#text_part0014.html_ch03lev1sec3"
class="calibre4">Functions</a>” on <a href="#text_part0014.html_page_48"
class="calibre4">page 48</a>; in the meantime, you should treat <span
class="literal1">def</span> as if it’s defining constants. In the next
few chapters, you’ll learn how to work with this apparent limitation by
embracing the functional programming paradigm.</p>
<h3 class="h2" id="text_part0014.html_ch03lev1sec2"><strong>Data
Structures</strong></h3>
<p>Clojure comes with a handful of data structures that you’ll use the
majority of the time. If you’re coming from an object-oriented
background, you’ll be surprised at how much you can do with the
seemingly basic types presented here.</p>
<p><span id="text_part0014.html_page_42" class="calibre4"></span>All of
Clojure’s data structures are immutable, meaning you can’t change them
in place. For example, in Ruby you could do the following to reassign
the failed protagonist name at index 0:</p>
<pre class="programs"><code>failed_protagonist_names = [
  &quot;Larry Potter&quot;,
  &quot;Doreen the Explorer&quot;,
  &quot;The Incredible Bulk&quot;
]
failed_protagonist_names[0] = &quot;Gary Potter&quot;


failed_protagonist_names
# =&gt; [
#   &quot;Gary Potter&quot;,
#   &quot;Doreen the Explorer&quot;,
#   &quot;The Incredible Bulk&quot;
# ]</code></pre>
<p>Clojure has no equivalent for this. You’ll learn more about why
Clojure was implemented this way in <a href="#text_part0022.html_ch10"
class="calibre4">Chapter 10</a>, but for now it’s fun to learn just how
to do things without all that philosophizing. Without further ado, let’s
look at numbers in Clojure.</p>
<h4 class="h2"
id="text_part0014.html_ch03lev2sec4"><em><strong>Numbers</strong></em></h4>
<p>Clojure has pretty sophisticated numerical support. I won’t spend
much time dwelling on the boring technical details (like coercion and
contagion), because that will get in the way of <em>doing things</em>.
If you’re interested in said boring details, check out the documentation
at <em><a
href="http://clojure.org/data_structures#Data%20Structures-Numbers"
class="calibre4">http://clojure.org/data_structures#Data%20Structures-Numbers</a></em>.
Suffice it to say, Clojure will merrily handle pretty much anything you
throw at it.</p>
<p>In the meantime, we’ll work with integers and floats. We’ll also work
with ratios, which Clojure can represent directly. Here’s an integer, a
float, and a ratio, respectively:</p>
<pre class="programs"><code>93
1.2
1/5</code></pre>
<h4 class="h2"
id="text_part0014.html_ch03lev2sec5"><em><strong>Strings</strong></em></h4>
<p>Strings represent text. The name comes from the ancient Phoenicians,
who one day invented the alphabet after an accident involving yarn. Here
are some examples of string literals:</p>
<pre class="programs"><code>&quot;Lord Voldemort&quot;
&quot;\&quot;He who must not be named\&quot;&quot;
&quot;\&quot;Great cow of Moscow!\&quot; - Hermes Conrad&quot;</code></pre>
<p><span id="text_part0014.html_page_43" class="calibre4"></span>Notice
that Clojure only allows double quotes to delineate strings. <span
class="literal1">'Lord Voldemort'</span>, for example, is not a valid
string. Also notice that Clojure doesn’t have string interpolation. It
only allows concatenation via the <span class="literal1">str</span>
function:</p>
<div class="image">
<img src="images_00024.jpeg" class="calibre3" alt="image" />
</div>
<pre class="programs"><code>(def name &quot;Chewbacca&quot;)
(str &quot;\&quot;Uggllglglglglglglglll\&quot; - &quot; name)
; =&gt; &quot;Uggllglglglglglglglll&quot; - Chewbacca</code></pre>
<h4 class="h2"
id="text_part0014.html_ch03lev2sec6"><em><strong>Maps</strong></em></h4>
<p>Maps are similar to dictionaries or hashes in other languages.
They’re a way of associating some value with some other value. The two
kinds of maps in Clojure are hash maps and sorted maps. I’ll only cover
the more basic hash maps. Let’s look at some examples of map literals.
Here’s an empty map:</p>
<pre class="programs"><code>{}</code></pre>
<p>In this example, <span class="literal1">:first-name</span> and <span
class="literal1">:last-name</span> are keywords (I’ll cover those in the
next section):</p>
<pre class="programs"><code>{:first-name &quot;Charlie&quot;
 :last-name &quot;McFishwich&quot;}</code></pre>
<p>Here we associate <span class="literal1">"string-key"</span> with the
<span class="literal1">+</span> function:</p>
<pre class="programs"><code>{&quot;string-key&quot; +}</code></pre>
<p>Maps can be nested:</p>
<pre class="programs"><code>{:name {:first &quot;John&quot; :middle &quot;Jacob&quot; :last &quot;Jingleheimerschmidt&quot;}}</code></pre>
<p>Notice that map values can be of any type—strings, numbers, maps,
vectors, even functions. Clojure don’t care!</p>
<p>Besides using map literals, you can use the <span
class="literal1">hash-map</span> function to create a map:</p>
<pre class="programs"><code>(hash-map :a 1 :b 2)
; =&gt; {:a 1 :b 2}</code></pre>
<p>You can look up values in maps with the <span
class="literal1">get</span> function:</p>
<pre class="programs"><code>(get {:a 0 :b 1} :b)
; =&gt; 1


(get {:a 0 :b {:c &quot;ho hum&quot;}} :b)
; =&gt; {:c &quot;ho hum&quot;}</code></pre>
<p><span id="text_part0014.html_page_44" class="calibre4"></span>In both
of these examples, we asked <span class="literal1">get</span> for the
value of the <span class="literal1">:b</span> key in the given map—in
the first case it returns <span class="literal1">1</span>, and in the
second case it returns the nested map <span class="literal1">{:c "ho
hum"}</span>.</p>
<p><span class="literal1">get</span> will return <span
class="literal1">nil</span> if it doesn’t find your key, or you can give
it a default value to return, such as <span
class="literal1">"unicorns?"</span>:</p>
<pre class="programs"><code>(get {:a 0 :b 1} :c)
; =&gt; nil


(get {:a 0 :b 1} :c &quot;unicorns?&quot;)
; =&gt; &quot;unicorns?&quot;</code></pre>
<p>The <span class="literal1">get-in</span> function lets you look up
values in nested maps:</p>
<pre class="programs"><code>(get-in {:a 0 :b {:c &quot;ho hum&quot;}} [:b :c])
; =&gt; &quot;ho hum&quot;</code></pre>
<p>Another way to look up a value in a map is to treat the map like a
function with the key as its argument:</p>
<pre class="programs"><code>({:name &quot;The Human Coffeepot&quot;} :name)
; =&gt; &quot;The Human Coffeepot&quot;</code></pre>
<p>Another cool thing you can do with maps is use keywords as functions
to look up their values, which leads to the next subject, keywords.</p>
<h4 class="h2"
id="text_part0014.html_ch03lev2sec7"><em><strong>Keywords</strong></em></h4>
<p>Clojure keywords are best understood by seeing how they’re used.
They’re primarily used as keys in maps, as you saw in the preceding
section. Here are some more examples of keywords:</p>
<pre class="programs"><code>:a
:rumplestiltsken
:34
:_?</code></pre>
<p>Keywords can be used as functions that look up the corresponding
value in a data structure. For example, you can look up <span
class="literal1">:a</span> in a map:</p>
<pre class="programs"><code>(:a {:a 1 :b 2 :c 3})
; =&gt; 1</code></pre>
<p>This is equivalent to:</p>
<pre class="programs"><code>(get {:a 1 :b 2 :c 3} :a)
; =&gt; 1</code></pre>
<p>You can provide a default value, as with <span
class="literal1">get</span>:</p>
<pre class="programs"><code>(:d {:a 1 :b 2 :c 3} &quot;No gnome knows homes like Noah knows&quot;)
; =&gt; &quot;No gnome knows homes like Noah knows&quot;</code></pre>
<p><span id="text_part0014.html_page_45" class="calibre4"></span>Using a
keyword as a function is pleasantly succinct, and Real Clojurists do it
all the time. You should do it too!</p>
<h4 class="h2"
id="text_part0014.html_ch03lev2sec8"><em><strong>Vectors</strong></em></h4>
<p>A vector is similar to an array, in that it’s a 0-indexed collection.
For example, here’s a vector literal:</p>
<pre class="programs"><code>[3 2 1]</code></pre>
<p>Here we’re returning the 0th element of a vector:</p>
<pre class="programs"><code>(get [3 2 1] 0)
; =&gt; 3</code></pre>
<p>Here’s another example of getting by index:</p>
<pre class="programs"><code>(get [&quot;a&quot; {:name &quot;Pugsley Winterbottom&quot;} &quot;c&quot;] 1)
; =&gt; {:name &quot;Pugsley Winterbottom&quot;}</code></pre>
<p>You can see that vector elements can be of any type, and you can mix
types. Also notice that we’re using the same <span
class="literal1">get</span> function as we use when looking up values in
maps.</p>
<p>You can create vectors with the <span class="literal1">vector</span>
function:</p>
<pre class="programs"><code>(vector &quot;creepy&quot; &quot;full&quot; &quot;moon&quot;)
; =&gt; [&quot;creepy&quot; &quot;full&quot; &quot;moon&quot;]</code></pre>
<p>You can use the <span class="literal1">conj</span> function to add
additional elements to the vector. Elements are added to the
<em>end</em> of a vector:</p>
<pre class="programs"><code>(conj [1 2 3] 4)
; =&gt; [1 2 3 4]</code></pre>
<p>Vectors aren’t the only way to store sequences; Clojure also has
<em>lists</em>.</p>
<h4 class="h2"
id="text_part0014.html_ch03lev2sec9"><em><strong>Lists</strong></em></h4>
<p>Lists are similar to vectors in that they’re linear collections of
values. But there are some differences. For example, you can’t retrieve
list elements with <span class="literal1">get</span>. To write a list
literal, just insert the elements into parentheses and use a single
quote at the beginning:</p>
<pre class="programs"><code>&#39;(1 2 3 4)
; =&gt; (1 2 3 4)</code></pre>
<p><span id="text_part0014.html_page_46" class="calibre4"></span>Notice
that when the REPL prints out the list, it doesn’t include the single
quote. We’ll come back to why that happens later, in <a
href="#text_part0018.html_ch07" class="calibre4">Chapter 7</a>. If you
want to retrieve an element from a list, you can use the <span
class="literal1">nth</span> function:</p>
<pre class="programs"><code>(nth &#39;(:a :b :c) 0)
; =&gt; :a


(nth &#39;(:a :b :c) 2)
; =&gt; :c</code></pre>
<p>I don’t cover performance in detail in this book because I don’t
think it’s useful to focus on it until after you’ve become familiar with
a language. However, it’s good to know that using <span
class="literal1">nth</span> to retrieve an element from a list is slower
than using <span class="literal1">get</span> to retrieve an element from
a vector. This is because Clojure has to traverse all <em>n</em>
elements of a list to get to the <em>n</em>th, whereas it only takes a
few hops at most to access a vector element by its index.</p>
<p>List values can have any type, and you can create lists with the
<span class="literal1">list</span> function:</p>
<pre class="programs"><code>(list 1 &quot;two&quot; {3 4})
; =&gt; (1 &quot;two&quot; {3 4})</code></pre>
<p>Elements are added to the <em>beginning</em> of a list:</p>
<pre class="programs"><code>(conj &#39;(1 2 3) 4)
; =&gt; (4 1 2 3)</code></pre>
<p>When should you use a list and when should you use a vector? A good
rule of thumb is that if you need to easily add items to the beginning
of a sequence or if you’re writing a macro, you should use a list.
Otherwise, you should use a vector. As you learn more, you’ll get a good
feel for when to use which.</p>
<h4 class="h2"
id="text_part0014.html_ch03lev2sec10"><em><strong>Sets</strong></em></h4>
<p>Sets are collections of unique values. Clojure has two kinds of sets:
hash sets and sorted sets. I’ll focus on hash sets because they’re used
more often. Here’s the literal notation for a hash set:</p>
<pre class="programs"><code>#{&quot;kurt vonnegut&quot; 20 :icicle}</code></pre>
<p>You can also use <span class="literal1">hash-set</span> to create a
set:</p>
<pre class="programs"><code>(hash-set 1 1 2 2)
; =&gt; #{1 2}</code></pre>
<p>Note that multiple instances of a value become one unique value in
the set, so we’re left with a single <span class="literal1">1</span> and
a single <span class="literal1">2</span>. If you try to add a value
<span id="text_part0014.html_page_47" class="calibre4"></span>to a set
that already contains that value (such as <span
class="literal1">:b</span> in the following code), it will still have
only one of that value:</p>
<pre class="programs"><code>(conj #{:a :b} :b)
; =&gt; #{:a :b}</code></pre>
<p>You can also create sets from existing vectors and lists by using the
<span class="literal1">set</span> function:</p>
<pre class="programs"><code>(set [3 3 3 4 4])
; =&gt; #{3 4}</code></pre>
<p>You can check for set membership using the <span
class="literal1">contains?</span> function, by using <span
class="literal1">get</span>, or by using a keyword as a function with
the set as its argument. <span class="literal1">contains?</span> returns
<span class="literal1">true</span> or <span
class="literal1">false</span>, whereas <span class="literal1">get</span>
and keyword lookup will return the value if it exists, or <span
class="literal1">nil</span> if it doesn’t.</p>
<p>Here’s how you’d use <span class="literal1">contains?</span>:</p>
<pre class="programs"><code>(contains? #{:a :b} :a)
; =&gt; true


(contains? #{:a :b} 3)
; =&gt; false


(contains? #{nil} nil)
; =&gt; true</code></pre>
<p>Here’s how you’d use a keyword:</p>
<pre class="programs"><code>(:a #{:a :b})
; =&gt; :a</code></pre>
<p>And here’s how you’d use <span class="literal1">get</span>:</p>
<pre class="programs"><code>(get #{:a :b} :a)
; =&gt; :a


(get #{:a nil} nil)
; =&gt; nil


(get #{:a :b} &quot;kurt vonnegut&quot;)
; =&gt; nil</code></pre>
<p>Notice that using <span class="literal1">get</span> to test whether a
set contains <span class="literal1">nil</span> will always return <span
class="literal1">nil</span>, which is confusing. <span
class="literal1">contains?</span> may be the better option when you’re
testing specifically for set membership.</p>
<h4 class="h2" id="text_part0014.html_ch03lev2sec11"><span
id="text_part0014.html_page_48"
class="calibre1"></span><em><strong>Simplicity</strong></em></h4>
<p>You may have noticed that the treatment of data structures so far
doesn’t include a description of how to create new types or classes. The
reason is that Clojure’s emphasis on simplicity encourages you to reach
for the builtin data structures first.</p>
<p>If you come from an object-oriented background, you might think that
this approach is weird and backward. However, what you’ll find is that
your data does not have to be tightly bundled with a class for it to be
useful and intelligible. Here’s an epigram loved by Clojurists that
hints at the Clojure philosophy:</p>
<p>It is better to have 100 functions operate on one data structure than
10 functions on 10 data structures.</p>
<p>—Alan Perlis</p>
<p>You’ll learn more about this aspect of Clojure’s philosophy in the
coming chapters. For now, keep an eye out for the ways that you gain
code reusability by sticking to basic data structures.</p>
<p>This concludes our Clojure data structures primer. Now it’s time to
dig in to functions and learn how to use these data structures!</p>
<h3 class="h2"
id="text_part0014.html_ch03lev1sec3"><strong>Functions</strong></h3>
<p>One of the reasons people go nuts over Lisps is that these languages
let you build programs that behave in complex ways, yet the primary
building block—the function—is so simple. This section initiates you
into the beauty and elegance of Lisp functions by explaining the
following:</p>
<p>• Calling functions</p>
<p>• How functions differ from macros and special forms</p>
<p>• Defining functions</p>
<p>• Anonymous functions</p>
<p>• Returning functions</p>
<h4 class="h2" id="text_part0014.html_ch03lev2sec12"><em><strong>Calling
Functions</strong></em></h4>
<p>By now you’ve seen many examples of function calls:</p>
<pre class="programs"><code>(+ 1 2 3 4)
(* 1 2 3 4)
(first [1 2 3 4])</code></pre>
<p>Remember that all Clojure operations have the same syntax: opening
parenthesis, operator, operands, closing parenthesis. <em>Function
call</em> is just another term for an operation where the operator is a
function or a <em>function expression</em> (an expression that returns a
function).</p>
<p><span id="text_part0014.html_page_49" class="calibre4"></span>This
lets you write some pretty interesting code. Here’s a function
expression that returns the <span class="literal1">+</span> (addition)
function:</p>
<pre class="programs"><code>(or + -)
; =&gt; #&lt;core$_PLUS_ clojure.core$_PLUS_@76dace31&gt;</code></pre>
<p>That return value is the string representation of the addition
function. Because the return value of <span class="literal1">or</span>
is the first truthy value, and here the addition function is truthy, the
addition function is returned. You can also use this expression as the
operator in another expression:</p>
<pre class="programs"><code>((or + -) 1 2 3)
; =&gt; 6</code></pre>
<p>Because <span class="literal1">(or + -)</span> returns <span
class="literal1">+</span>, this expression evaluates to the sum of <span
class="literal1">1</span>, <span class="literal1">2</span>, and <span
class="literal1">3</span>, returning <span
class="literal1">6</span>.</p>
<p>Here are a couple more valid function calls that each return <span
class="literal1">6</span>:</p>
<pre class="programs"><code>((and (= 1 1) +) 1 2 3)
; =&gt; 6


((first [+ 0]) 1 2 3)
; =&gt; 6</code></pre>
<p>In the first example, the return value of <span
class="literal1">and</span> is the first falsey value or the last truthy
value. In this case, <span class="literal1">+</span> is returned because
it’s the last truthy value, and is then applied to the arguments <span
class="literal1">1 2 3</span>, returning <span
class="literal1">6</span>. In the second example, the return value of
<span class="literal1">first</span> is the first element in a sequence,
which is <span class="literal1">+</span> in this case.</p>
<p>However, these aren’t valid function calls, because numbers and
strings aren’t functions:</p>
<pre class="programs"><code>(1 2 3 4)
(&quot;test&quot; 1 2 3)</code></pre>
<p>If you run these in your REPL, you’ll get something like this:</p>
<pre class="programs"><code>ClassCastException java.lang.String cannot be cast to clojure.lang.IFn
user/eval728 (NO_SOURCE_FILE:1)</code></pre>
<p>You’re likely to see this error many times as you continue with
Clojure: <em>&lt;x&gt; cannot be cast to clojure.lang.IFn</em> just
means that you’re trying to use something as a function when it’s
not.</p>
<p>Function flexibility doesn’t end with the function expression!
Syntactically, functions can take any expressions as arguments—including
<em>other functions</em>. Functions that can either take a function as
an argument or return a function are called <em>higher-order
functions</em>. Programming languages with higher-order functions are
said to support <em>first-class functions</em> because you can treat
functions as values in the same way you treat more familiar data types
like numbers and vectors.</p>
<p><span id="text_part0014.html_page_50" class="calibre4"></span>Take
the <span class="literal1">map</span> function (not to be confused with
the map data structure), for instance. <span class="literal1">map</span>
creates a new list by applying a function to each member of a
collection. Here, the <span class="literal1">inc</span> function
increments a number by 1:</p>
<pre class="programs"><code>(inc 1.1)
; =&gt; 2.1


(map inc [0 1 2 3])
; =&gt; (1 2 3 4)</code></pre>
<p>(Note that <span class="literal1">map</span> doesn’t return a vector,
even though we supplied a vector as an argument. You’ll learn why in <a
href="#text_part0015.html_ch04" class="calibre4">Chapter 4</a>. For now,
just trust that this is okay and expected.)</p>
<p>Clojure’s support for first-class functions allows you to build more
powerful abstractions than you can in languages without them. Those
unfamiliar with this kind of programming think of functions as allowing
you to generalize operations over data instances. For example, the <span
class="literal1">+</span> function abstracts addition over any specific
numbers.</p>
<p>By contrast, Clojure (and all Lisps) allows you to create functions
that generalize over processes. <span class="literal1">map</span> allows
you to generalize the process of transforming a collection by applying a
function—any function—over any collection.</p>
<p>The last detail that you need know about function calls is that
Clojure evaluates all function arguments recursively before passing them
to the function. Here’s how Clojure would evaluate a function call whose
arguments are also function calls:</p>
<pre class="programs"><code>(+ (inc 199) (/ 100 (- 7 2)))
(+ 200 (/ 100 (- 7 2))) ; evaluated &quot;(inc 199)&quot;
(+ 200 (/ 100 5)) ; evaluated (- 7 2)
(+ 200 20) ; evaluated (/ 100 5)
220 ; final evaluation</code></pre>
<p>The function call kicks off the evaluation process, and all subforms
are evaluated before applying the <span class="literal1">+</span>
function.</p>
<h4 class="h2"
id="text_part0014.html_ch03lev2sec13"><em><strong>Function Calls, Macro
Calls, and Special Forms</strong></em></h4>
<p>In the previous section, you learned that function calls are
expressions that have a function expression as the operator. The two
other kinds of expressions are <em>macro calls</em> and <em>special
forms</em>. You’ve already seen a couple of special forms: definitions
and <span class="literal1">if</span> expressions.</p>
<p>You’ll learn everything there is to know about macro calls and
special forms in <a href="#text_part0018.html_ch07"
class="calibre4">Chapter 7</a>. For now, the main feature that makes
special forms “special” is that, unlike function calls, <em>they don’t
always evaluate all of their operands</em>.</p>
<p><span id="text_part0014.html_page_51" class="calibre4"></span>Take
<span class="literal1">if</span>, for example. This is its general
structure:</p>
<pre class="programs"><code>(if boolean-form
  then-form
  optional-else-form)</code></pre>
<p>Now imagine you had an <span class="literal1">if</span> statement
like this:</p>
<pre class="programs"><code>(if good-mood
  (tweet walking-on-sunshine-lyrics)
  (tweet mopey-country-song-lyrics))</code></pre>
<p>Clearly, in an <span class="literal1">if</span> expression like this,
we want Clojure to evaluate only one of the two branches. If Clojure
evaluated both <span class="literal1">tweet</span> function calls, your
Twitter followers would end up very confused.</p>
<p>Another feature that differentiates special forms is that you can’t
use them as arguments to functions. In general, special forms implement
core Clojure functionality that just can’t be implemented with
functions. Clojure has only a handful of special forms, and it’s pretty
amazing that such a rich language is implemented with such a small set
of building blocks.</p>
<p>Macros are similar to special forms in that they evaluate their
operands differently from function calls, and they also can’t be passed
as arguments to functions. But this detour has taken long enough; it’s
time to learn how to define functions!</p>
<h4 class="h2"
id="text_part0014.html_ch03lev2sec14"><em><strong>Defining
Functions</strong></em></h4>
<p>Function definitions are composed of five main parts:</p>
<p>• <span class="literal1">defn</span></p>
<p>• Function name</p>
<p>• A docstring describing the function (optional)</p>
<p>• Parameters listed in brackets</p>
<p>• Function body</p>
<p>Here’s an example of a function definition and a sample call of the
function:</p>
<pre class="programs"><code>➊ (defn too-enthusiastic
➋   &quot;Return a cheer that might be a bit too enthusiastic&quot;
➌   [name]
➍   (str &quot;OH. MY. GOD! &quot; name &quot; YOU ARE MOST DEFINITELY LIKE THE BEST &quot;
     &quot;MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE&quot;))


   (too-enthusiastic &quot;Zelda&quot;)
   ; =&gt; &quot;OH. MY. GOD! Zelda YOU ARE MOST DEFINITELY LIKE THE BEST MAN SLASH WOMAN
   EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE&quot;</code></pre>
<p><span id="text_part0014.html_page_52" class="calibre4"></span>At
<span class="ent">➊</span>, <span
class="literal1">too-enthusiastic</span> is the name of the function,
and it’s followed by a descriptive docstring at <span
class="ent">➋</span>. The parameter, <span class="literal1">name</span>,
is given at <span class="ent">➌</span>, and the function body at <span
class="ent">➍</span> takes the parameter and does what it says on the
tin—returns a cheer that might be a bit too enthusiastic.</p>
<p>Let’s dive deeper into the docstring, parameters, and function
body.</p>
<h5 class="h3" id="text_part0014.html_ch03lev3sec5"><strong>The
Docstring</strong></h5>
<p>The <em>docstring</em> is a useful way to describe and document your
code. You can view the docstring for a function in the REPL with <span
class="literal1">(doc</span> <em>fn-name</em><span
class="literal1">)</span>—for example, <span class="literal1">(doc
map)</span>. The docstring also comes into play if you use a tool to
generate documentation for your code.</p>
<h5 class="h3" id="text_part0014.html_ch03lev3sec6"><strong>Parameters
and Arity</strong></h5>
<p>Clojure functions can be defined with zero or more parameters. The
values you pass to functions are called <em>arguments</em>, and the
arguments can be of any type. The number of parameters is the function’s
<em>arity</em>. Here are some function definitions with different
arities:</p>
<pre class="programs"><code>(defn no-params
  []
  &quot;I take no parameters!&quot;)
(defn one-param
  [x]
  (str &quot;I take one parameter: &quot; x))
(defn two-params
  [x y]
  (str &quot;Two parameters! That&#39;s nothing! Pah! I will smoosh them &quot;
  &quot;together to spite you! &quot; x y))</code></pre>
<p>In these examples, <span class="literal1">no-params</span> is a
0-arity function, <span class="literal1">one-param</span> is 1-arity,
and <span class="literal1">two-params</span> is 2-arity.</p>
<p>Functions also support <em>arity overloading</em>. This means that
you can define a function so a different function body will run
depending on the arity. Here’s the general form of a multiple-arity
function definition. Notice that each arity definition is enclosed in
parentheses and has an argument list:</p>
<pre class="programs"><code>(defn multi-arity
  ;; 3-arity arguments and body
  ([first-arg second-arg third-arg]
     (do-things first-arg second-arg third-arg))
  ;; 2-arity arguments and body
  ([first-arg second-arg]
     (do-things first-arg second-arg))
  ;; 1-arity arguments and body
  ([first-arg]
     (do-things first-arg)))</code></pre>
<p><span id="text_part0014.html_page_53" class="calibre4"></span>Arity
overloading is one way to provide default values for arguments. In the
following example, <span class="literal1">"karate"</span> is the default
argument for the <span class="literal1">chop-type</span> parameter:</p>
<pre class="programs"><code>(defn x-chop
  &quot;Describe the kind of chop you&#39;re inflicting on someone&quot;
  ([name chop-type]
     (str &quot;I &quot; chop-type &quot; chop &quot; name &quot;! Take that!&quot;))
  ([name]
     (x-chop name &quot;karate&quot;)))</code></pre>
<p>If you call <span class="literal1">x-chop</span> with two arguments,
the function works just as it would if it weren’t a multiple-arity
function:</p>
<pre class="programs"><code>(x-chop &quot;Kanye West&quot; &quot;slap&quot;)
; =&gt; &quot;I slap chop Kanye West! Take that!&quot;</code></pre>
<div class="image">
<img src="images_00025.jpeg" class="calibre3" alt="image" />
</div>
<p>If you call <span class="literal1">x-chop</span> with only one
argument, <span class="literal1">x-chop</span> will actually call itself
with the second argument <span class="literal1">"karate"</span>
supplied:</p>
<pre class="programs"><code>(x-chop &quot;Kanye East&quot;)
; =&gt; &quot;I karate chop Kanye East! Take that!&quot;</code></pre>
<p>It might seem unusual to define a function in terms of itself like
this. If so, great! You’re learning a new way to do things!</p>
<p>You can also make each arity do something completely unrelated:</p>
<pre class="programs"><code>(defn weird-arity
  ([]
     &quot;Destiny dressed you this morning, my friend, and now Fear is
     trying to pull off your pants. If you give up, if you give in,
     you&#39;re gonna end up naked with Fear just standing there laughing
     at your dangling unmentionables! - the Tick&quot;)
  ([number]
     (inc number)))</code></pre>
<p>The 0-arity body returns a wise quote, and the 1-arity body
increments a number. Most likely, you wouldn’t want to write a function
like this, because it would be confusing to have two function bodies
that are completely unrelated.</p>
<p><span id="text_part0014.html_page_54" class="calibre4"></span>Clojure
also allows you to define variable-arity functions by including a
<em>rest parameter</em>, as in “put the rest of these arguments in a
list with the following name.” The rest parameter is indicated by an
ampersand (<span class="literal1">&amp;</span>), as shown at <span
class="ent">➊</span>:</p>
<div class="image">
<img src="images_00026.jpeg" class="calibre3" alt="image" />
</div>
<pre class="programs"><code>   (defn codger-communication
     [whippersnapper]
     (str &quot;Get off my lawn, &quot; whippersnapper &quot;!!!&quot;))


   (defn codger
➊    [&amp; whippersnappers]
     (map codger-communication whippersnappers))


   (codger &quot;Billy&quot; &quot;Anne-Marie&quot; &quot;The Incredible Bulk&quot;)
   ; =&gt; (&quot;Get off my lawn, Billy!!!&quot;
         &quot;Get off my lawn, Anne-Marie!!!&quot;
         &quot;Get off my lawn, The Incredible Bulk!!!&quot;)</code></pre>
<p>As you can see, when you provide arguments to variable-arity
functions, the arguments are treated as a list. You can mix rest
parameters with normal parameters, but the rest parameter has to come
last:</p>
<pre class="programs"><code>(defn favorite-things
  [name &amp; things]
  (str &quot;Hi, &quot; name &quot;, here are my favorite things: &quot;
       (clojure.string/join &quot;, &quot; things)))


(favorite-things &quot;Doreen&quot; &quot;gum&quot; &quot;shoes&quot; &quot;kara-te&quot;)
; =&gt; &quot;Hi, Doreen, here are my favorite things: gum, shoes, kara-te&quot;</code></pre>
<p>Finally, Clojure has a more sophisticated way of defining parameters,
called <em>destructuring</em>, which deserves its own subsection.</p>
<h5 class="h3"
id="text_part0014.html_ch03lev3sec7"><strong>Destructuring</strong></h5>
<p>The basic idea behind destructuring is that it lets you concisely
bind names to values within a collection. Let’s look at a basic
example:</p>
<pre class="programs"><code>;; Return the first element of a collection
(defn my-first
  [[first-thing]] ; Notice that first-thing is within a vector
  first-thing)


(my-first [&quot;oven&quot; &quot;bike&quot; &quot;war-axe&quot;])
; =&gt; &quot;oven&quot;</code></pre>
<p>Here, the <span class="literal1">my-first</span> function associates
the symbol <span class="literal1">first-thing</span> with the first
element of the vector that was passed in as an argument. You tell <span
class="literal1">my-first</span> to do this by placing the symbol <span
class="literal1">first-thing</span> within a vector.</p>
<p>That vector is like a huge sign held up to Clojure that says, “Hey!
This function is going to receive a list or a vector as an argument.
Make my life easier by taking apart the argument’s structure for me and
associating <span id="text_part0014.html_page_55"
class="calibre4"></span>meaningful names with different parts of the
argument!” When destructuring a vector or list, you can name as many
elements as you want and also use rest parameters:</p>
<pre class="programs"><code>(defn chooser
  [[first-choice second-choice &amp; unimportant-choices]]
  (println (str &quot;Your first choice is: &quot; first-choice))
  (println (str &quot;Your second choice is: &quot; second-choice))
  (println (str &quot;We&#39;re ignoring the rest of your choices. &quot;
                &quot;Here they are in case you need to cry over them: &quot;
                (clojure.string/join &quot;, &quot; unimportant-choices))))


(chooser [&quot;Marmalade&quot;, &quot;Handsome Jack&quot;, &quot;Pigpen&quot;, &quot;Aquaman&quot;])
; =&gt; Your first choice is: Marmalade
; =&gt; Your second choice is: Handsome Jack
; =&gt; We&#39;re ignoring the rest of your choices. Here they are in case \
     you need to cry over them: Pigpen, Aquaman</code></pre>
<p>Here, the rest parameter <span
class="literal1">unimportant-choices</span> handles any number of
additional choices from the user after the first and second.</p>
<p>You can also destructure maps. In the same way that you tell Clojure
to destructure a vector or list by providing a vector as a parameter,
you destructure maps by providing a map as a parameter:</p>
<pre class="programs"><code>   (defn announce-treasure-location
➊    [{lat :lat lng :lng}]
     (println (str &quot;Treasure lat: &quot; lat))
     (println (str &quot;Treasure lng: &quot; lng)))


   (announce-treasure-location {:lat 28.22 :lng 81.33})
   ; =&gt; Treasure lat: 100
   ; =&gt; Treasure lng: 50</code></pre>
<p>Let’s look at the line at <span class="ent">➊</span> in more detail.
This is like telling Clojure, “Yo! Clojure! Do me a flava and associate
the name <span class="literal1">lat</span> with the value corresponding
to the key <span class="literal1">:lat</span>. Do the same thing with
<span class="literal1">lng</span> and <span
class="literal1">:lng</span>, okay?”</p>
<p>We often want to just break keywords out of a map, so there’s a
shorter syntax for that. This has the same result as the previous
example:</p>
<pre class="programs"><code>(defn announce-treasure-location
  [{:keys [lat lng]}]
  (println (str &quot;Treasure lat: &quot; lat))
  (println (str &quot;Treasure lng: &quot; lng)))</code></pre>
<p>You can retain access to the original map argument by using the <span
class="literal1">:as</span> keyword. In the following example, the
original map is accessed with <span
class="literal1">treasure-location</span>:</p>
<pre class="programs"><code>(defn receive-treasure-location
  [{:keys [lat lng] :as treasure-location}]

  (println (str &quot;Treasure lat: &quot; lat))
  (println (str &quot;Treasure lng: &quot; lng))


  ;; One would assume that this would put in new coordinates for your ship
  (steer-ship! treasure-location))</code></pre>
<p>In general, you can think of destructuring as instructing Clojure on
how to associate names with values in a list, map, set, or vector. Now,
on to the part of the function that actually does something: the
function body!</p>
<h5 class="h3" id="text_part0014.html_ch03lev3sec8"><strong>Function
Body</strong></h5>
<p>The function body can contain forms of any kind. Clojure
automatically returns the last form evaluated. This function body
contains just three forms, and when you call the function, it spits out
the last form, <span class="literal1">"joe"</span>:</p>
<pre class="programs"><code>(defn illustrative-function
  []
  (+ 1 304)
  30
  &quot;joe&quot;)


(illustrative-function)
; =&gt; &quot;joe&quot;</code></pre>
<p>Here’s another function body, which uses an <span
class="literal1">if</span> expression:</p>
<pre class="programs"><code>(defn number-comment
  [x]
  (if (&gt; x 6)
    &quot;Oh my gosh! What a big number!&quot;
    &quot;That number&#39;s OK, I guess&quot;))


(number-comment 5)
; =&gt; &quot;That number&#39;s OK, I guess&quot;


(number-comment 7)
; =&gt; &quot;Oh my gosh! What a big number!&quot;</code></pre>
<h5 class="h3" id="text_part0014.html_ch03lev3sec9"><strong>All
Functions Are Created Equal</strong></h5>
<p>One final note: Clojure has no privileged functions. <span
class="literal1">+</span> is just a function, <span
class="literal1">-</span> is just a function, and <span
class="literal1">inc</span> and <span class="literal1">map</span> are
just functions. They’re no better than the functions you define
yourself. So don’t let them give you any lip!</p>
<p>More important, this fact helps demonstrate Clojure’s underlying
simplicity. In a way, Clojure is very dumb. When you make a function
call, Clojure just says, “<span class="literal1">map</span>? Sure,
whatever! I’ll just apply this and move on.” It doesn’t care what the
function is or where it came from; it treats all functions the same. At
its core, Clojure doesn’t give two burger flips about addition,
multiplication, or mapping. It just cares about applying functions.</p>
<p>As you continue to program with Clojure, you’ll see that this
simplicity is ideal. You don’t have to worry about special rules or
syntax for working with different functions. They all work the same!</p>
<h4 class="h2" id="text_part0014.html_ch03lev2sec15"><span
id="text_part0014.html_page_57"
class="calibre1"></span><em><strong>Anonymous
Functions</strong></em></h4>
<p>In Clojure, functions don’t need to have names. In fact, you’ll use
<em>anonymous</em> functions all the time. How mysterious! You create
anonymous functions in two ways. The first is to use the <span
class="literal1">fn</span> form:</p>
<pre class="programs"><code>(fn [param-list]
  function body)</code></pre>
<p>Looks a lot like <span class="literal1">defn</span>, doesn’t it?
Let’s try a couple of examples:</p>
<pre class="programs"><code>(map (fn [name] (str &quot;Hi, &quot; name))
     [&quot;Darth Vader&quot; &quot;Mr. Magoo&quot;])
; =&gt; (&quot;Hi, Darth Vader&quot; &quot;Hi, Mr. Magoo&quot;)


((fn [x] (* x 3)) 8)
; =&gt; 24</code></pre>
<p>You can treat <span class="literal1">fn</span> nearly identically to
the way you treat <span class="literal1">defn</span>. The parameter
lists and function bodies work exactly the same. You can use argument
destructuring, rest parameters, and so on. You could even associate your
anonymous function with a name, which shouldn’t come as a surprise (if
that does come as a surprise, then . . . Surprise!):</p>
<pre class="programs"><code>(def my-special-multiplier (fn [x] (* x 3)))
(my-special-multiplier 12)
; =&gt; 36</code></pre>
<p>Clojure also offers another, more compact way to create anonymous
functions. Here’s what an anonymous function looks like:</p>
<pre class="programs"><code>#(* % 3)</code></pre>
<p>Whoa, that looks weird. Go ahead and apply that weird-looking
function:</p>
<pre class="programs"><code>(#(* % 3) 8)
; =&gt; 24</code></pre>
<p>Here’s an example of passing an anonymous function as an argument to
map:</p>
<pre class="programs"><code>(map #(str &quot;Hi, &quot; %)
     [&quot;Darth Vader&quot; &quot;Mr. Magoo&quot;])
; =&gt; (&quot;Hi, Darth Vader&quot; &quot;Hi, Mr. Magoo&quot;)</code></pre>
<p>This strange-looking style of writing anonymous functions is made
possible by a feature called <em>reader macros</em>. You’ll learn all
about those in <a href="#text_part0018.html_ch07"
class="calibre4">Chapter 7</a>. Right now, it’s okay to learn how to use
just these anonymous functions.</p>
<p><span id="text_part0014.html_page_58" class="calibre4"></span>You can
see that this syntax is definitely more compact, but it’s also a little
odd. Let’s break it down. This kind of anonymous function looks a lot
like a function call, except that it’s preceded by a hash mark, <span
class="literal1">#</span>:</p>
<pre class="programs"><code>;; Function call
(* 8 3)


;; Anonymous function
#(* % 3)</code></pre>
<p>This similarity allows you to more quickly see what will happen when
this anonymous function is applied. “Oh,” you can say to yourself, “this
is going to multiply its argument by three.”</p>
<p>As you may have guessed by now, the percent sign, <span
class="literal1">%</span>, indicates the argument passed to the
function. If your anonymous function takes multiple arguments, you can
distinguish them like this: <span class="literal1">%1</span>, <span
class="literal1">%2</span>, <span class="literal1">%3</span>, and so on.
<span class="literal1">%</span> is equivalent to <span
class="literal1">%1</span>:</p>
<pre class="programs"><code>(#(str %1 &quot; and &quot; %2) &quot;cornbread&quot; &quot;butter beans&quot;)
; =&gt; &quot;cornbread and butter beans&quot;</code></pre>
<p>You can also pass a rest parameter with <span
class="literal1">%&amp;</span>:</p>
<pre class="programs"><code>(#(identity %&amp;) 1 &quot;blarg&quot; :yip)
; =&gt; (1 &quot;blarg&quot; :yip)</code></pre>
<p>In this case, you applied the identity function to the rest argument.
Identity returns the argument it’s given without altering it. Rest
arguments are stored as lists, so the function application returns a
list of all the arguments.</p>
<p>If you need to write a simple anonymous function, using this style is
best because it’s visually compact. On the other hand, it can easily
become unreadable if you’re writing a longer, more complex function. If
that’s the case, use <span class="literal1">fn</span>.</p>
<h4 class="h2"
id="text_part0014.html_ch03lev2sec16"><em><strong>Returning
Functions</strong></em></h4>
<p>By now you’ve seen that functions can return other functions. The
returned functions are <em>closures</em>, which means that they can
access all the variables that were in scope when the function was
created. Here’s a standard example:</p>
<pre class="programs"><code>(defn inc-maker
  &quot;Create a custom incrementor&quot;
  [inc-by]
  #(+ % inc-by))


(def inc3 (inc-maker 3))


(inc3 7)
; =&gt; 10</code></pre>
<p><span id="text_part0014.html_page_59" class="calibre4"></span>Here,
<span class="literal1">inc-by</span> is in scope, so the returned
function has access to it even when the returned function is used
outside <span class="literal1">inc-maker</span>.</p>
<h3 class="h2" id="text_part0014.html_ch03lev1sec4"><strong>Pulling It
All Together</strong></h3>
<div class="image">
<img src="images_00027.jpeg" class="calibre3" alt="image" />
</div>
<p>Okay! It's time to use your newfound knowledge for a noble purpose:
smacking around hobbits! To hit a hobbit, you’ll first model its body
parts. Each body part will include its relative size to indicate how
likely it is that that part will be hit. To avoid repetition, the hobbit
model will include only entries for <em>left foot</em>, <em>left
ear</em>, and so on. Therefore, you’ll need a function to fully
symmetrize the model, creating <em>right foot</em>, <em>right ear</em>,
and so forth. Finally, you’ll create a function that iterates over the
body parts and randomly chooses the one hit. Along the way, you’ll learn
about a few new Clojure tools: <span class="literal1">let</span>
expressions, loops, and regular expressions. Fun!</p>
<h4 class="h2" id="text_part0014.html_ch03lev2sec17"><em><strong>The
Shire’s Next Top Model</strong></em></h4>
<p>For our hobbit model, we’ll eschew such hobbit characteristics as
joviality and mischievousness and focus only on the hobbit’s tiny body.
Here’s the hobbit model:</p>
<pre class="programs"><code>(def asym-hobbit-body-parts [{:name &quot;head&quot; :size 3}
                             {:name &quot;left-eye&quot; :size 1}
                             {:name &quot;left-ear&quot; :size 1}
                             {:name &quot;mouth&quot; :size 1}
                             {:name &quot;nose&quot; :size 1}
                             {:name &quot;neck&quot; :size 2}
                             {:name &quot;left-shoulder&quot; :size 3}
                             {:name &quot;left-upper-arm&quot; :size 3}
                             {:name &quot;chest&quot; :size 10}
                             {:name &quot;back&quot; :size 10}
                             {:name &quot;left-forearm&quot; :size 3}
                             {:name &quot;abdomen&quot; :size 6}
                             {:name &quot;left-kidney&quot; :size 1}
                             {:name &quot;left-hand&quot; :size 2}
                             {:name &quot;left-knee&quot; :size 2}
                             {:name &quot;left-thigh&quot; :size 4}
                             {:name &quot;left-lower-leg&quot; :size 3}
                             {:name &quot;left-achilles&quot; :size 1}
                             {:name &quot;left-foot&quot; :size 2}])</code></pre>
<p>This is a vector of maps. Each map has the name of the body part and
relative size of the body part. (I know that only anime characters have
eyes one-third the size of their head, but just go with it, okay?)</p>
<p><span id="text_part0014.html_page_60"
class="calibre4"></span>Conspicuously missing is the hobbit’s right
side. Let’s fix that. <a href="#text_part0014.html_ch3list1"
class="calibre4">Listing 3-1</a> is the most complex code you’ve seen so
far, and it introduces some new ideas. But don’t worry, because we’ll
examine it in great detail.</p>
<pre class="programs"><code>(defn matching-part
  [part]
  {:name (clojure.string/replace (:name part) #&quot;^left-&quot; &quot;right-&quot;)
   :size (:size part)})


(defn symmetrize-body-parts
  &quot;Expects a seq of maps that have a :name and :size&quot;
  [asym-body-parts]
  (loop [remaining-asym-parts asym-body-parts
         final-body-parts []]
    (if (empty? remaining-asym-parts)
      final-body-parts
      (let [[part &amp; remaining] remaining-asym-parts]
        (recur remaining
               (into final-body-parts
                     (set [part (matching-part part)])))))))</code></pre>
<p><span id="text_part0014.html_ch3list1"
class="calibre4"></span><em>Listing 3-1: <span class="literal1">The
matching-part</span> and <span
class="literal1">symmetrize-body-parts</span> functions</em></p>
<p>When we call the function <span
class="literal1">symmetrize-body-parts</span> on <span
class="literal1">asym-hobbit-body-parts</span>, we get a fully
symmetrical hobbit:</p>
<pre class="programs"><code>(symmetrize-body-parts asym-hobbit-body-parts)
; =&gt; [{:name &quot;head&quot;, :size 3}
      {:name &quot;left-eye&quot;, :size 1}
      {:name &quot;right-eye&quot;, :size 1}
      {:name &quot;left-ear&quot;, :size 1}
      {:name &quot;right-ear&quot;, :size 1}
      {:name &quot;mouth&quot;, :size 1}
      {:name &quot;nose&quot;, :size 1}
      {:name &quot;neck&quot;, :size 2}
      {:name &quot;left-shoulder&quot;, :size 3}
      {:name &quot;right-shoulder&quot;, :size 3}
      {:name &quot;left-upper-arm&quot;, :size 3}
      {:name &quot;right-upper-arm&quot;, :size 3}
      {:name &quot;chest&quot;, :size 10}
      {:name &quot;back&quot;, :size 10}
      {:name &quot;left-forearm&quot;, :size 3}
      {:name &quot;right-forearm&quot;, :size 3}
      {:name &quot;abdomen&quot;, :size 6}
      {:name &quot;left-kidney&quot;, :size 1}
      {:name &quot;right-kidney&quot;, :size 1}
      {:name &quot;left-hand&quot;, :size 2}
      {:name &quot;right-hand&quot;, :size 2}
      {:name &quot;left-knee&quot;, :size 2}
      {:name &quot;right-knee&quot;, :size 2}
      {:name &quot;left-thigh&quot;, :size 4}
      {:name &quot;right-thigh&quot;, :size 4}
      {:name &quot;left-lower-leg&quot;, :size 3}
      {:name &quot;right-lower-leg&quot;, :size 3}

      {:name &quot;left-achilles&quot;, :size 1}
      {:name &quot;right-achilles&quot;, :size 1}
      {:name &quot;left-foot&quot;, :size 2}
      {:name &quot;right-foot&quot;, :size 2}]</code></pre>
<p>Let’s break down this code!</p>
<h4 class="h2"
id="text_part0014.html_ch03lev2sec18"><em><strong>let</strong></em></h4>
<p>In the mass of craziness in <a href="#text_part0014.html_ch3list1"
class="calibre4">Listing 3-1</a>, you can see a form of the structure
<span class="literal1">(let ...)</span>. Let’s build up an understanding
of <span class="literal1">let</span> one example at a time, and then
examine the full example from the program once we’re familiar with all
the pieces.</p>
<p><span class="literal1">let</span> binds names to values. You can
think of <span class="literal1">let</span> as short for <em>let it
be</em>, which is also a beautiful Beatles song about programming.
Here’s an example:</p>
<pre class="programs"><code>(let [x 3]
  x)
; =&gt; 3


(def dalmatian-list
  [&quot;Pongo&quot; &quot;Perdita&quot; &quot;Puppy 1&quot; &quot;Puppy 2&quot;])
(let [dalmatians (take 2 dalmatian-list)]
  dalmatians)
; =&gt; (&quot;Pongo&quot; &quot;Perdita&quot;)</code></pre>
<p>In the first example, you bind the name <span
class="literal1">x</span> to the value <span class="literal1">3</span>.
In the second, you bind the name <span
class="literal1">dalmatians</span> to the result of the expression <span
class="literal1">(take 2 dalmatian-list)</span>, which was the list
<span class="literal1">("Pongo" "Perdita")</span>. <span
class="literal1">let</span> also introduces a new <em>scope</em>:</p>
<pre class="programs"><code>(def x 0)
(let [x 1] x)
; =&gt; 1</code></pre>
<p>Here, you first bind the name <span class="literal1">x</span> to the
value <span class="literal1">0</span> using <span
class="literal1">def</span>. Then, <span class="literal1">let</span>
creates a new scope in which the name <span class="literal1">x</span> is
bound to the value <span class="literal1">1</span>. I think of scope as
the context for what something refers to. For example, in the phrase
“please clean up these butts,” <em>butts</em> means something different
depending on whether you’re working in a maternity ward or on the
custodial staff of a cigarette manufacturers convention. In this code
snippet, you’re saying, “I want <span class="literal1">x</span> to be
<span class="literal1">0</span> in the global context, but within the
context of this <span class="literal1">let</span> expression, it should
be <span class="literal1">1</span>.”</p>
<p>You can reference existing bindings in your <span
class="literal1">let</span> binding:</p>
<pre class="programs"><code>(def x 0)
(let [x (inc x)] x)
; =&gt; 1</code></pre>
<p><span id="text_part0014.html_page_62" class="calibre4"></span>In this
example, the <span class="literal1">x</span> in <span
class="literal1">(inc x)</span> refers to the binding created by <span
class="literal1">(def x 0)</span>. The resulting value is <span
class="literal1">1</span>, which is then bound to the name <span
class="literal1">x</span> within a new scope created by <span
class="literal1">let</span>. Within the confines of the <span
class="literal1">let</span> form, <span class="literal1">x</span> refers
to <span class="literal1">1</span>, not <span
class="literal1">0</span>.</p>
<p>You can also use rest parameters in <span
class="literal1">let</span>, just like you can in functions:</p>
<pre class="programs"><code>(let [[pongo &amp; dalmatians] dalmatian-list]
  [pongo dalmatians])
; =&gt; [&quot;Pongo&quot; (&quot;Perdita&quot; &quot;Puppy 1&quot; &quot;Puppy 2&quot;)]</code></pre>
<p>Notice that the value of a <span class="literal1">let</span> form is
the last form in its body that is evaluated. <span
class="literal1">let</span> forms follow all the destructuring rules
introduced in “<a href="#text_part0014.html_ch03lev2sec12"
class="calibre4">Calling Functions</a>” on <a
href="#text_part0014.html_page_48" class="calibre4">page 48</a>. In this
case, <span class="literal1">[pongo &amp; dalmatians]</span>
destructured <span class="literal1">dalmatian-list</span>, binding the
string <span class="literal1">"Pongo"</span> to the name <span
class="literal1">pongo</span> and the list of the rest of the dalmatians
to <span class="literal1">dalmatians</span>. The vector <span
class="literal1">[pongo dalmatians]</span> is the last expression in
<span class="literal1">let</span>, so it’s the value of the <span
class="literal1">let</span> form.</p>
<p><span class="literal1">let</span> forms have two main uses. First,
they provide clarity by allowing you to name things. Second, they allow
you to evaluate an expression only once and reuse the result. This is
especially important when you need to reuse the result of an expensive
function call, like a network API call. It’s also important when the
expression has side effects.</p>
<p>Let’s have another look at the <span class="literal1">let</span> form
in our symmetrizing function so we can understand exactly what’s going
on:</p>
<pre class="programs"><code>(let [[part &amp; remaining] remaining-asym-parts]
  (recur remaining
         (into final-body-parts
               (set [part (matching-part part)])))) </code></pre>
<p>This code tells Clojure, “Create a new scope. Within it, associate
<span class="literal1">part</span> with the first element of <span
class="literal1">remaining-asym-parts</span>. Associate <span
class="literal1">remaining</span> with the rest of the elements in <span
class="literal1">remaining-asym-parts</span>.”</p>
<p>As for the body of the <span class="literal1">let</span> expression,
you’ll learn about the meaning of <span class="literal1">recur</span> in
the next section. The function call</p>
<pre class="programs"><code>(into final-body-parts
  (set [part (matching-part part)]))</code></pre>
<p>first tells Clojure, “Use the <span class="literal1">set</span>
function to create a set consisting of <span
class="literal1">part</span> and its matching part. Then use the
function <span class="literal1">into</span> to add the elements of that
set to the vector <span class="literal1">final-body-parts</span>.” You
create a set here to ensure you’re adding unique elements to <span
class="literal1">final-body-parts</span> because <span
class="literal1">part</span> and <span class="literal1">(matching-part
part)</span> are sometimes the same thing, as you’ll see in the upcoming
section on regular expressions. Here’s a simplified example:</p>
<pre class="programs"><code>(into [] (set [:a :a]))
; =&gt; [:a]</code></pre>
<p><span id="text_part0014.html_page_63" class="calibre4"></span>First,
<span class="literal1">(set [:a :a])</span> returns the set <span
class="literal1">#{:a}</span>, because sets don’t contain duplicate
elements. Then <span class="literal1">(into [] #{:a})</span> returns the
vector <span class="literal1">[:a]</span>.</p>
<p>Back to <span class="literal1">let</span>: notice that <span
class="literal1">part</span> is used multiple times in the body of the
<span class="literal1">let</span>. If we used the original expressions
instead of using the names <span class="literal1">part</span> and <span
class="literal1">remaining</span>, it would be a mess! Here’s an
example:</p>
<pre class="programs"><code>(recur (rest remaining-asym-parts)
       (into final-body-parts
             (set [(first remaining-asym-parts) (matching-part (first
remaining-asym-parts))])))</code></pre>
<p>So, <span class="literal1">let</span> is a handy way to introduce
local names for values, which helps simplify the code.</p>
<h4 class="h2"
id="text_part0014.html_ch03lev2sec19"><em><strong>loop</strong></em></h4>
<p>In our <span class="literal1">symmetrize-body-parts</span> function
we use <span class="literal1">loop</span>, which provides another way to
do recursion in Clojure. Let’s look at a simple example:</p>
<pre class="programs"><code>(loop [iteration 0]
  (println (str &quot;Iteration &quot; iteration))
  (if (&gt; iteration 3)
    (println &quot;Goodbye!&quot;)
    (recur (inc iteration))))
; =&gt; Iteration 0
; =&gt; Iteration 1
; =&gt; Iteration 2
; =&gt; Iteration 3
; =&gt; Iteration 4
; =&gt; Goodbye!</code></pre>
<p>The first line, <span class="literal1">loop [iteration 0]</span>,
begins the loop and introduces a binding with an initial value. On the
first pass through the loop, <span class="literal1">iteration</span> has
a value of 0. Next, it prints a short message. Then, it checks the value
of <span class="literal1">iteration</span>. If the value is greater than
3, it’s time to say Goodbye. Otherwise, we <span
class="literal1">recur</span>. It’s as if <span
class="literal1">loop</span> creates an anonymous function with a
parameter named <span class="literal1">iteration</span>, and <span
class="literal1">recur</span> allows you to call the function from
within itself, passing the argument <span class="literal1">(inc
iteration)</span>.</p>
<p>You could in fact accomplish the same thing by just using a normal
function definition:</p>
<pre class="programs"><code>(defn recursive-printer
  ([]
     (recursive-printer 0))
  ([iteration]
     (println iteration)
     (if (&gt; iteration 3)
       (println &quot;Goodbye!&quot;)
       (recursive-printer (inc iteration)))))
(recursive-printer)

; =&gt; Iteration 0
; =&gt; Iteration 1
; =&gt; Iteration 2
; =&gt; Iteration 3
; =&gt; Iteration 4
; =&gt; Goodbye!</code></pre>
<p>But as you can see, this is a bit more verbose. Also, <span
class="literal1">loop</span> has much better performance. In our
symmetrizing function, we’ll use <span class="literal1">loop</span> to
go through each element in the asymmetrical list of body parts.</p>
<h4 class="h2" id="text_part0014.html_ch03lev2sec20"><em><strong>Regular
Expressions</strong></em></h4>
<p><em>Regular expressions</em> are tools for performing pattern
matching on text. The literal notation for a regular expression is to
place the expression in quotes after a hash mark:</p>
<pre class="programs"><code>#&quot;regular-expression&quot;</code></pre>
<p>In the function <span class="literal1">matching-part</span> in <a
href="#text_part0014.html_ch3list1" class="calibre4">Listing 3-1</a>,
<span class="literal1">clojure.string/replace</span> uses the regular
expression <span class="literal1">#"^left-"</span> to match strings
starting with <span class="literal1">"left-"</span> in order to replace
<span class="literal1">"left-"</span> with <span
class="literal1">"right-"</span>. The carat, <span
class="literal1">^</span>, is how the regular expression signals that it
will match the text <span class="literal1">"left-"</span> only if it’s
at the beginning of the string, which ensures that something like <span
class="literal1">"cleft-chin"</span> won’t match. You can test this with
<span class="literal1">re-find</span>, which checks whether a string
matches the pattern described by a regular expression, returning the
matched text or <span class="literal1">nil</span> if there is no
match:</p>
<pre class="programs"><code>(re-find #&quot;^left-&quot; &quot;left-eye&quot;)
; =&gt; &quot;left-&quot;


(re-find #&quot;^left-&quot; &quot;cleft-chin&quot;)
; =&gt; nil


(re-find #&quot;^left-&quot; &quot;wongleblart&quot;)
; =&gt; nil</code></pre>
<p>Here are a couple of examples of <span
class="literal1">matching-part</span> using a regex to replace <span
class="literal1">"left-"</span> with <span
class="literal1">"right-"</span>:</p>
<pre class="programs"><code>(defn matching-part
  [part]
  {:name (clojure.string/replace (:name part) #&quot;^left-&quot; &quot;right-&quot;)
   :size (:size part)})
(matching-part {:name &quot;left-eye&quot; :size 1})
; =&gt; {:name &quot;right-eye&quot; :size 1}]


(matching-part {:name &quot;head&quot; :size 3})
; =&gt; {:name &quot;head&quot; :size 3}]</code></pre>
<p>Notice that the name <span class="literal1">"head"</span> is returned
as is.</p>
<h4 class="h2" id="text_part0014.html_ch03lev2sec21"><span
id="text_part0014.html_page_65"
class="calibre1"></span><em><strong>Symmetrizer</strong></em></h4>
<p>Now let’s go back to the full symmetrizer and analyze it in more
detail:</p>
<pre class="programs"><code>   (def asym-hobbit-body-parts [{:name &quot;head&quot; :size 3}
                                {:name &quot;left-eye&quot; :size 1}
                                {:name &quot;left-ear&quot; :size 1}
                                {:name &quot;mouth&quot; :size 1}
                                {:name &quot;nose&quot; :size 1}
                                {:name &quot;neck&quot; :size 2}
                                {:name &quot;left-shoulder&quot; :size 3}
                                {:name &quot;left-upper-arm&quot; :size 3}
                                {:name &quot;chest&quot; :size 10}
                                {:name &quot;back&quot; :size 10}
                                {:name &quot;left-forearm&quot; :size 3}
                                {:name &quot;abdomen&quot; :size 6}
                                {:name &quot;left-kidney&quot; :size 1}
                                {:name &quot;left-hand&quot; :size 2}
                                {:name &quot;left-knee&quot; :size 2}
                                {:name &quot;left-thigh&quot; :size 4}
                                {:name &quot;left-lower-leg&quot; :size 3}
                                {:name &quot;left-achilles&quot; :size 1}
                                {:name &quot;left-foot&quot; :size 2}])






   (defn matching-part
     [part]
     {:name (clojure.string/replace (:name part) #&quot;^left-&quot; &quot;right-&quot;)
      :size (:size part)})


➊ (defn symmetrize-body-parts
     &quot;Expects a seq of maps that have a :name and :size&quot;
     [asym-body-parts]
➋   (loop [remaining-asym-parts asym-body-parts
           final-body-parts []]
➌     (if (empty? remaining-asym-parts)
        final-body-parts
➍       (let [[part &amp; remaining] remaining-asym-parts]
➎         (recur remaining
                 (into final-body-parts
                       (set [part (matching-part part)])))))))</code></pre>
<p>The <span class="literal1">symmetrize-body-parts</span> function
(starting at <span class="ent">➊</span>) employs a general strategy that
is common in functional programming. Given a sequence (in this case, a
vector of body parts and their sizes), the function continuously splits
the sequence into a <em>head</em> and a <em>tail</em>. Then it processes
the head, adds it to some result, and uses recursion to continue the
process with the tail.</p>
<p>We begin looping over the body parts at <span class="ent">➋</span>.
The tail of the sequence will be bound to <span
class="literal1">remaining-asym-parts</span>. Initially, it’s bound to
the full sequence passed to the function: <span
class="literal1">asym-body-parts</span>. We also create a result
sequence, <span class="literal1">final-body-parts</span>; its initial
value is an empty vector.</p>
<p><span id="text_part0014.html_page_66" class="calibre4"></span>If
<span class="literal1">remaining-asym-parts</span> is empty at <span
class="ent">➌</span>, that means we’ve processed the entire sequence and
can return the result, <span class="literal1">final-body-parts</span>.
Otherwise, at <span class="ent">➍</span> we split the list into a head,
<span class="literal1">part</span>, and tail, <span
class="literal1">remaining</span>.</p>
<p>At <span class="ent">➎</span>, we recur with <span
class="literal1">remaining</span>, a list that gets shorter by one
element on each iteration of the loop, and the <span
class="literal1">(into)</span> expression, which builds our vector of
symmetrized body parts.</p>
<p>If you’re new to this kind of programming, this code might take some
time to puzzle out. Stick with it! Once you understand what’s happening,
you’ll feel like a million bucks!</p>
<h4 class="h2" id="text_part0014.html_ch03lev2sec22"><em><strong>Better
Symmetrizer with reduce</strong></em></h4>
<p>The pattern of <em>process each element in a sequence and build a
result</em> is so common that there’s a built-in function for it called
<span class="literal1">reduce</span>. Here’s a simple example:</p>
<pre class="programs"><code>;; sum with reduce
(reduce + [1 2 3 4])
; =&gt; 10</code></pre>
<p>This is like telling Clojure to do this:</p>
<pre class="programs"><code>(+ (+ (+ 1 2) 3) 4)</code></pre>
<p>The <span class="literal1">reduce</span> function works according to
the following steps:</p>
<p>1. Apply the given function to the first two elements of a sequence.
That’s where <span class="literal1">(+ 1 2)</span> comes from.</p>
<p>2. Apply the given function to the result and the next element of the
sequence. In this case, the result of step 1 is <span
class="literal1">3</span>, and the next element of the sequence is <span
class="literal1">3</span> as well. So the final result is <span
class="literal1">(+ 3 3)</span>.</p>
<p>3. Repeat step 2 for every remaining element in the sequence.</p>
<p><span class="literal1">reduce</span> also takes an optional initial
value. The initial value here is <span class="literal1">15</span>:</p>
<pre class="programs"><code>(reduce + 15 [1 2 3 4])</code></pre>
<p>If you provide an initial value, <span class="literal1">reduce</span>
starts by applying the given function to the initial value and the first
element of the sequence rather than the first two elements of the
sequence.</p>
<p>One detail to note is that, in these examples, <span
class="literal1">reduce</span> takes a collection of elements, <span
class="literal1">[1 2 3 4]</span>, and returns a single number. Although
programmers often use <span class="literal1">reduce</span> this way, you
can also use <span class="literal1">reduce</span> to return an even
larger collection than the one you started with, as we’re trying to do
with <span class="literal1">symmetrize-body-parts</span>. <span
class="literal1">reduce</span> abstracts the task “process a collection
<span id="text_part0014.html_page_67" class="calibre4"></span>and build
a result,” which is agnostic about the type of result returned. To
further understand how <span class="literal1">reduce</span> works,
here’s one way that you could implement it:</p>
<pre class="programs"><code>(defn my-reduce
  ([f initial coll]
   (loop [result initial
          remaining coll]
      (if (empty? remaining)
        result
        (recur (f result (first remaining)) (rest remaining)))))
   ([f [head &amp; tail]]
    (my-reduce f head tail)))</code></pre>
<p>We could reimplement our symmetrizer as follows:</p>
<pre class="programs"><code>(defn better-symmetrize-body-parts
  &quot;Expects a seq of maps that have a :name and :size&quot;
  [asym-body-parts]
  (reduce (fn [final-body-parts part]
            (into final-body-parts (set [part (matching-part part)])))
          []
          asym-body-parts))</code></pre>
<p>Groovy! One immediately obvious advantage of using <span
class="literal1">reduce</span> is that you write less code overall. The
anonymous function you pass to <span class="literal1">reduce</span>
focuses only on processing an element and building a result. The reason
is that <span class="literal1">reduce</span> handles the lower-level
machinery of keeping track of which elements have been processed and
deciding whether to return a final result or to recur.</p>
<p>Using <span class="literal1">reduce</span> is also more expressive.
If readers of your code encounter <span class="literal1">loop</span>,
they won’t be sure exactly what the loop is doing without reading all of
the code. But if they see <span class="literal1">reduce</span>, they’ll
immediately know that the purpose of the code is to process the elements
of a collection to build a result.</p>
<p>Finally, by abstracting the <span class="literal1">reduce</span>
process into a function that takes another function as an argument, your
program becomes more composable. You can pass the <span
class="literal1">reduce</span> function as an argument to other
functions, for example. You could also create a more generic version of
<span class="literal1">symmetrize-body-parts</span>, say, <span
class="literal1">expand-body-parts</span>. This could take an
<em>expander</em> function in addition to a list of body parts and would
let you model more than just hobbits. For example, you could have a
spider expander that could multiply the numbers of eyes and legs. I’ll
leave it up to you to write that because I am evil.</p>
<h4 class="h2" id="text_part0014.html_ch03lev2sec23"><em><strong>Hobbit
Violence</strong></em></h4>
<p>My word, this is truly Clojure for the Brave and True! To put the
capstone on your work, here’s a function that determines which part of a
hobbit is hit:</p>
<pre class="programs"><code>(defn hit
  [asym-body-parts]

  (let [sym-parts (➊better-symmetrize-body-parts asym-body-parts)
        ➋body-part-size-sum (reduce + (map :size sym-parts))
        target (rand body-part-size-sum)]
    ➌(loop [[part &amp; remaining] sym-parts
          accumulated-size (:size part)]
      (if (&gt; accumulated-size target)
        part
        (recur remaining (+ accumulated-size (:size (first remaining))))))))</code></pre>
<p><span class="literal1">hit</span> works by taking a vector of
asymmetrical body parts, symmetrizing it at <span class="ent">➊</span>,
and then summing the sizes of the parts at <span class="ent">➋</span>.
Once we sum the sizes, it’s like each number from 1 through <span
class="literal1">body-part-size-sum</span> corresponds to a body part; 1
might correspond to the left eye, and 2, 3, 4 might correspond to the
head. This makes it so when you hit a body part (by choosing a random
number in this range), the likelihood that a particular body part is hit
will depend on the size of the body part.</p>
<p>Finally, one of these numbers is randomly chosen, and then we use
<span class="literal1">loop</span> at <span class="ent">➌</span> to find
and return the body part that corresponds to the number. The loop does
this by keeping track of the accumulated sizes of parts that we’ve
checked and checking whether the accumulated size is greater than the
target. I visualize this process as lining up the body parts with a row
of numbered slots. After I line up a body part, I ask myself, “Have I
reached the target yet?” If I have, that means the body part I just
lined up was the one hit. Otherwise, I just keep lining up those
parts.</p>
<div class="image">
<img src="images_00028.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0014.html_ch3fig1"
class="calibre4"></span><em>Figure 3-1: Body parts correspond to ranges
of numbers and get hit if the target falls within that range.</em></p>
<p>For example, say that your list of parts is <em>head</em>, <em>left
eye</em>, and <em>left hand</em>, like in <a
href="#text_part0014.html_ch3fig1" class="calibre4">Figure 3-1</a>.
After taking the first part, the head, the accumulated size is 3. The
body part is hit if the accumulated size is greater than the target, so
if the target is 0, 1, or 2, then the head was hit. Otherwise, you take
the next part, the left eye, and increase the accumulated size to 4,
yielding a hit if the target is 3. Similarly, the left hand gets hit if
the target is 4 or 5.</p>
<p>Here are some sample runs of the <span class="literal1">hit</span>
function:</p>
<pre class="programs"><code>(hit asym-hobbit-body-parts)
; =&gt; {:name &quot;right-upper-arm&quot;, :size 3}


(hit asym-hobbit-body-parts)
; =&gt; {:name &quot;chest&quot;, :size 10}


(hit asym-hobbit-body-parts)
; =&gt; {:name &quot;left-eye&quot;, :size 1}</code></pre>
<p>Oh my god, that poor hobbit! You monster!</p>
<h3 class="h2" id="text_part0014.html_ch03lev1sec5"><span
id="text_part0014.html_page_69"
class="calibre1"></span><strong>Summary</strong></h3>
<p>This chapter gave you a whirlwind tour of how to <em>do stuff</em> in
Clojure. You now know how to represent information using strings,
numbers, maps, keywords, vectors, lists, and sets, and how to name these
representations with <span class="literal1">def</span> and <span
class="literal1">let</span>. You’ve learned about how flexible functions
are and how to create your own functions. Also, you’ve been introduced
to Clojure’s philosophy of simplicity, including its uniform syntax and
its emphasis on using large libraries of functions on primitive data
types.</p>
<p><a href="#text_part0015.html_ch04" class="calibre4">Chapter 4</a>
will take you through a detailed examination of Clojure’s core
functions, and <a href="#text_part0016.html_ch05"
class="calibre4">Chapter 5</a> explains the functional programming
mindset. This chapter has shown you how to write Clojure code—the next
two will show you how to write Clojure <em>well</em>.</p>
<p>At this point I recommend, with every fiber of my being, that you
start writing code. There is no better way to solidify your Clojure
knowledge. The Clojure Cheat Sheet (<em><a
href="http://clojure.org/cheatsheet/"
class="calibre4">http://clojure.org/cheatsheet/</a></em>) is a great
reference that lists all the built-in functions that operate on the data
structures covered in this chapter.</p>
<p>The following exercises will really tickle your brain. If you’d like
to test your new skills even more, try some Project Euler challenges at
<em><a href="http://www.projecteuler.net/"
class="calibre4">http://www.projecteuler.net/</a></em>. You could also
check out 4Clojure (<em><a href="http://www.4clojure.com/problems/"
class="calibre4">http://www.4clojure.com/problems/</a></em>), an online
set of Clojure problems designed to test your knowledge. Just write
something!</p>
<h3 class="h2" id="text_part0014.html_ch03lev1sec6"><strong><span
class="bordera">Exercises</span></strong></h3>
<p>These exercises are meant to be a fun way to test your Clojure
knowledge and to learn more Clojure functions. The first three can be
completed using only the information presented in this chapter, but the
last three will require you to use functions that haven’t been covered
so far. Tackle the last three if you’re really itching to write more
code and explore Clojure’s standard library. If you find the exercises
too difficult, revisit them after reading <a
href="#text_part0015.html_ch04" class="calibre4">Chapters 4</a> and <a
href="#text_part0016.html_ch05" class="calibre4">5</a>—you’ll find them
much easier.</p>
<p>1. Use the <span class="literal1">str</span>, <span
class="literal1">vector</span>, <span class="literal1">list</span>,
<span class="literal1">hash-map</span>, and <span
class="literal1">hash-set</span> functions.</p>
<p>2. Write a function that takes a number and adds 100 to it.</p>
<p>3. Write a function, <span class="literal1">dec-maker</span>, that
works exactly like the function <span class="literal1">inc-maker</span>
except with subtraction:</p>
<pre class="programs1"><code>(def dec9 (dec-maker 9))
(dec9 10)
; =&gt; 1</code></pre>
<p>4. Write a function, <span class="literal1">mapset</span>, that works
like <span class="literal1">map</span> except the return value is a
set:</p>
<pre class="programs1"><code>(mapset inc [1 1 2 2])
; =&gt; #{2 3}</code></pre>
<p><span id="text_part0014.html_page_70" class="calibre4"></span>5.
Create a function that’s similar to <span
class="literal1">symmetrize-body-parts</span> except that it has to work
with weird space aliens with radial symmetry. Instead of two eyes, arms,
legs, and so on, they have five.</p>
<p>6. Create a function that generalizes <span
class="literal1">symmetrize-body-parts</span> and the function you
created in Exercise 5. The new function should take a collection of body
parts and the number of matching body parts to add. If you’re completely
new to Lisp languages and functional programming, it probably won’t be
obvious how to do this. If you get stuck, just move on to the next
chapter and revisit the problem later.</p>
<p><span id="text_part0015.html"></span></p>
<h2 class="h1" id="text_part0015.html_ch04"><span
id="text_part0015.html_page_71" class="calibre1"></span><strong><span
class="big1">4</span></strong><br />
<strong>Core Functions in Depth</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>If you’re a huge fan of the angsty, teenagercentric, quasi–soap opera
<em>The Vampire Diaries</em> like I am, you’ll remember the episode
where the lead protagonist, Elena, starts to question her pale,
mysterious crush’s behavior: “Why did he instantly vanish without a
trace when I scraped my knee?” and “How come his face turned into a
grotesque mask of death when I nicked my finger?” and so on.</p>
<p>You might be asking yourself similar questions if you’ve started
playing with Clojure’s core functions. “Why did <span
class="literal1">map</span> return a list when I gave it a vector?” and
“How come <span class="literal1">reduce</span> treats my map like a list
of vectors?” and so on. (With Clojure, though, you’re at least spared
from contemplating the profound existential horror of being a
17-year-old for eternity.)</p>
<p>In this chapter, you’ll learn about Clojure’s deep, dark,
bloodthirsty, supernatur—*<em>cough</em>* I mean, in this chapter,
you’ll learn about Clojure’s <span id="text_part0015.html_page_72"
class="calibre4"></span>underlying concept of <em>programming to
abstractions</em> and about the sequence and collection abstractions.
You’ll also learn about <em>lazy sequences</em>. This will give you the
grounding you need to read the documentation for functions you haven’t
used before and to understand what’s happening when you give them a
try.</p>
<p>Next, you’ll get more experience with the functions you’ll be
reaching for the most. You’ll learn how to work with lists, vectors,
maps, and sets with the functions <span class="literal1">map</span>,
<span class="literal1">reduce</span>, <span
class="literal1">into</span>, <span class="literal1">conj</span>, <span
class="literal1">concat</span>, <span class="literal1">some</span>,
<span class="literal1">filter</span>, <span
class="literal1">take</span>, <span class="literal1">drop</span>, <span
class="literal1">sort</span>, <span class="literal1">sort-by</span>, and
<span class="literal1">identity</span>. You’ll also learn how to create
new functions with <span class="literal1">apply</span>, <span
class="literal1">partial</span>, and <span
class="literal1">complement</span>. All this information will help you
understand how to do things the Clojure way, and it will give you a
solid foundation for writing your own code as well as for reading and
learning from others’ projects.</p>
<p>Finally, you’ll learn how to parse and query a CSV of vampire data to
determine what nosferatu lurk in your hometown.</p>
<div class="image">
<img src="images_00029.jpeg" class="calibre3" alt="image" />
</div>
<h3 class="h2" id="text_part0015.html_ch04lev1sec1"><strong>Programming
to Abstractions</strong></h3>
<p>To understand programming to abstractions, let’s compare Clojure to a
language that wasn’t built with that principle in mind: Emacs Lisp
(elisp). In elisp, you can use the <span class="literal1">mapcar</span>
function to derive a new list, which is similar to how you use <span
class="literal1">map</span> in Clojure. However, if you want to map over
a hash map (similar to Clojure’s map data structure) in elisp, you’ll
need to use the <span class="literal1">maphash</span> function, whereas
in Clojure you can still just use <span class="literal1">map</span>. In
other words, elisp uses two different, data structure–specific functions
to implement the <em>map</em> operation, but Clojure uses only one. You
can also call <span class="literal1">reduce</span> on a map in Clojure,
whereas elisp doesn’t provide a function for reducing a hash map.</p>
<p>The reason is that Clojure defines <span class="literal1">map</span>
and <span class="literal1">reduce</span> functions in terms of the
<em>sequence abstraction</em>, not in terms of specific data structures.
As long as a data structure responds to the core sequence operations
(the functions <span class="literal1">first</span>, <span
class="literal1">rest</span>, and <span class="literal1">cons</span>,
which we’ll look at more closely in a moment), it will work with <span
class="literal1">map</span>, <span class="literal1">reduce</span>, and
oodles of other sequence functions for free. This is what Clojurists
mean by programming to abstractions, and it’s a central tenet of Clojure
philosophy.</p>
<p>I think of abstractions as named collections of operations. If you
can perform all of an abstraction’s operations on an object, then that
object is an instance of the abstraction. I think this way even outside
of programming. For example, the <em>battery</em> abstraction includes
the operation “connect a conducting medium to its anode and cathode,”
and the operation’s output is <em>electrical current</em>. It doesn’t
matter if the battery is made out of lithium or out of potatoes. It’s a
battery as long as it responds to the set of operations that define
<em>battery</em>.</p>
<p><span id="text_part0015.html_page_73"
class="calibre4"></span>Similarly, <span class="literal1">map</span>
doesn’t care about how lists, vectors, sets, and maps are implemented.
It only cares about whether it can perform sequence operations on them.
Let’s look at how <span class="literal1">map</span> is defined in terms
of the sequence abstraction so you can understand programming to
abstractions in general.</p>
<h4 class="h2" id="text_part0015.html_ch04lev2sec1"><em><strong>Treating
Lists, Vectors, Sets, and Maps as Sequences</strong></em></h4>
<p>If you think about the <span class="literal1">map</span> operation
independently of any programming language, or even of programming
altogether, its essential behavior is to derive a new sequence
<em>y</em> from an existing sequence <em>x</em> using a function
<em>f</em> such that <em>y</em><sub>1</sub> =
<em>f</em>(<em>x</em><sub>1</sub>), <em>y</em><sub>2</sub> =
<em>f</em>(<em>x</em><sub>2</sub>), . . . <em>y<sub>n</sub></em> =
<em>f</em>(<em>x<sub>n</sub></em>). <a
href="#text_part0015.html_ch4fig1" class="calibre4">Figure 4-1</a>
illustrates how you might visualize a mapping applied to a sequence.</p>
<div class="image">
<img src="images_00030.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0015.html_ch4fig1"
class="calibre4"></span><em>Figure 4-1: Visualizing a mapping</em></p>
<p>The term <em>sequence</em> here refers to a collection of elements
organized in linear order, as opposed to, say, an unordered collection
or a graph without a <em>before-and-after</em> relationship between its
nodes. <a href="#text_part0015.html_ch4fig2" class="calibre4">Figure
4-2</a> shows how you might visualize a sequence, in contrast to the
other two collections mentioned.</p>
<div class="image">
<img src="images_00031.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0015.html_ch4fig2"
class="calibre4"></span><em>Figure 4-2: Sequential and nonsequential
collections</em></p>
<p>Absent from this description of mapping and sequences is any mention
of lists, vectors, or other concrete data structures. Clojure is
designed to allow us to think and program in such abstract terms as much
as possible, and it does this by implementing functions in terms of data
structure abstractions. In this case, <span class="literal1">map</span>
is defined in terms of the sequence abstraction. In conversation, you
would say <span class="literal1">map</span>, <span
class="literal1">reduce</span>, and other sequence functions <em>take a
sequence</em> <span id="text_part0015.html_page_74"
class="calibre4"></span>or even <em>take a seq</em>. In fact, Clojurists
usually use <em>seq</em> instead of <em>sequence</em>, using terms like
<em>seq functions</em> and <em>the seq library</em> to refer to
functions that perform sequential operations. Whether you use
<em>sequence</em> or <em>seq</em>, you’re indicating that the data
structure in question will be treated as a sequence and that what it
actually is in its truest heart of hearts doesn’t matter in this
context.</p>
<p>If the core sequence functions <span class="literal1">first</span>,
<span class="literal1">rest</span>, and <span
class="literal1">cons</span> work on a data structure, you can say the
data structure <em>implements</em> the sequence abstraction. Lists,
vectors, sets, and maps all implement the sequence abstraction, so they
all work with <span class="literal1">map</span>, as shown here:</p>
<pre class="programs"><code>(defn titleize
  [topic]
  (str topic &quot; for the Brave and True&quot;))


(map titleize [&quot;Hamsters&quot; &quot;Ragnarok&quot;])
; =&gt; (&quot;Hamsters for the Brave and True&quot; &quot;Ragnarok for the Brave and True&quot;)


(map titleize &#39;(&quot;Empathy&quot; &quot;Decorating&quot;))
; =&gt; (&quot;Empathy for the Brave and True&quot; &quot;Decorating for the Brave and True&quot;)


(map titleize #{&quot;Elbows&quot; &quot;Soap Carving&quot;})
; =&gt; (&quot;Elbows for the Brave and True&quot; &quot;Soap Carving for the Brave and True&quot;)


(map #(titleize (second %)) {:uncomfortable-thing &quot;Winking&quot;})
; =&gt; (&quot;Winking for the Brave and True&quot;)</code></pre>
<p>The first two examples show that <span class="literal1">map</span>
works identically with vectors and lists. The third example shows that
<span class="literal1">map</span> can work with unsorted sets. In the
fourth example, you must call <span class="literal1">second</span> on
the anonymous function’s argument before title-izing it because the
argument is a map. I’ll explain why soon, but first let’s look at the
three functions that define the sequence abstraction.</p>
<h4 class="h2" id="text_part0015.html_ch04lev2sec2"><em><strong>first,
rest, and cons</strong></em></h4>
<p>In this section, we’ll take a quick detour into JavaScript to
implement a linked list and three core functions: <span
class="literal1">first</span>, <span class="literal1">rest</span>, and
<span class="literal1">cons</span>. After those three core functions are
implemented, I’ll show how you to build <span
class="literal1">map</span> with them.</p>
<div class="image">
<img src="images_00032.jpeg" class="calibre3" alt="image" />
</div>
<p>The point is to appreciate the distinction between the seq
abstraction in Clojure and the concrete implementation of a linked list.
It doesn’t matter how a particular data structure is implemented: when
it comes to using seq functions on a data structure, all Clojure asks is
“can I <span class="literal1">first</span>, <span
class="literal1">rest</span>, and <span class="literal1">cons</span>
it?” If the answer is yes, you can use the seq library with that data
structure.</p>
<p><span id="text_part0015.html_page_75" class="calibre4"></span>In a
linked list, nodes are linked in a linear sequence. Here’s how you might
create one in JavaScript. In this snippet, <span
class="literal1">next</span> is null because this is the last node in
the list:</p>
<pre class="programs"><code>var node3 = {
  value: &quot;last&quot;,
  next: null
};</code></pre>
<p>In this snippet, <span class="literal1">node2</span>’s <span
class="literal1">next</span> points to <span
class="literal1">node3</span>, and <span class="literal1">node1</span>’s
<span class="literal1">next</span> points to <span
class="literal1">node2</span>; that’s the “link” in “linked list”:</p>
<pre class="programs"><code>var node2 = {
  value: &quot;middle&quot;,
  next: node3
};


var node1 = {
  value: &quot;first&quot;,
  next: node2
};</code></pre>
<p>Graphically, you could represent this list as shown in <a
href="#text_part0015.html_ch4fig3" class="calibre4">Figure 4-3</a>.</p>
<div class="image">
<img src="images_00033.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0015.html_ch4fig3"
class="calibre4"></span><em>Figure 4-3: A linked list</em></p>
<p>You can perform three core functions on a linked list: <span
class="literal1">first</span>, <span class="literal1">rest</span>, and
<span class="literal1">cons</span>. <span class="literal1">first</span>
returns the value for the requested node, <span
class="literal1">rest</span> returns the remaining values after the
requested node, and <span class="literal1">cons</span> adds a new node
with the given value to the beginning of the list. After those are
implemented, you can implement <span class="literal1">map</span>, <span
class="literal1">reduce</span>, <span class="literal1">filter</span>,
and other seq functions on top of them.</p>
<p>The following code shows how we would implement and use <span
class="literal1">first</span>, <span class="literal1">rest</span>, and
<span class="literal1">cons</span> with our JavaScript node example, as
well as how to use them to return specific nodes and derive a new list.
Note that the parameter of <span class="literal1">first</span> and <span
class="literal1">rest</span> is named <em>node</em>. This might be
confusing because you might say, “Ain’t I getting the first element of a
<em>list</em>?” Well, you operate on the elements of a list one node at
a time!</p>
<pre class="programs"><code>var first = function(node) {
  return node.value;
};


var rest = function(node) {
  return node.next;
};
var cons = function(newValue, node) {
  return {
    value: newValue,
    next: node
  };
};


first(node1);
// =&gt; &quot;first&quot;


first(rest(node1));
// =&gt; &quot;middle&quot;


first(rest(rest(node1)));
// =&gt; &quot;last&quot;


var node0 = cons(&quot;new first&quot;, node1);
first(node0);
// =&gt; &quot;new first&quot;


first(rest(node0));
// =&gt; &quot;first&quot;</code></pre>
<p>As noted previously, you can implement <span
class="literal1">map</span> in terms of <span
class="literal1">first</span>, <span class="literal1">rest</span>, and
<span class="literal1">cons</span>:</p>
<pre class="programs"><code>var map = function (list, transform) {
  if (list === null) {
    return null;
  } else {
    return cons(transform(first(list)), map(rest(list), transform));
  }
}</code></pre>
<p>This function transforms the first element of the list and then calls
itself again on the rest of the list until it reaches the end (a null).
Let’s see it in action! In this example, you’re mapping the list that
begins with <span class="literal1">node1</span>, returning a new list
where the string <span class="literal1">" mapped!"</span> is appended to
each node’s value. Then you’re using <span class="literal1">first</span>
to return the first node’s value:</p>
<pre class="programs"><code>first(
  map(node1, function (val) { return val + &quot; mapped!&quot;})
);


// =&gt; &quot;first mapped!&quot;</code></pre>
<p>So here’s the cool thing: because <span class="literal1">map</span>
is implemented completely in terms of <span
class="literal1">cons</span>, <span class="literal1">first</span>, and
<span class="literal1">rest</span>, you could actually pass it any data
structure and it would work as long as <span
class="literal1">cons</span>, <span class="literal1">first</span>, and
<span class="literal1">rest</span> work on that data structure.</p>
<p><span id="text_part0015.html_page_77" class="calibre4"></span>Here’s
how they might work for an array:</p>
<pre class="programs"><code>var first = function (array) {
  return array[0];
}


var rest = function (array) {
  var sliced = array.slice(1, array.length);
  if (sliced.length == 0) {
    return null;
  } else {
    return sliced;
  }
}


var cons = function (newValue, array) {
  return [newValue].concat(array);
}


var list = [&quot;Transylvania&quot;, &quot;Forks, WA&quot;];
map(list, function (val) { return val + &quot; mapped!&quot;})
// =&gt; [&quot;Transylvania mapped!&quot;, &quot;Forks, WA mapped!&quot;]</code></pre>
<p>This code snippet defines <span class="literal1">first</span>, <span
class="literal1">rest</span>, and <span class="literal1">cons</span> in
terms of JavaScript’s array functions. Meanwhile, <span
class="literal1">map</span> continues referencing functions named <span
class="literal1">first</span>, <span class="literal1">rest</span>, and
<span class="literal1">cons</span>, so now it works on <span
class="literal1">array</span>. So, if you can just implement <span
class="literal1">first</span>, <span class="literal1">rest</span>, and
<span class="literal1">cons</span>, you get <span
class="literal1">map</span> for free along with the aforementioned
oodles of other functions.</p>
<h4 class="h2"
id="text_part0015.html_ch04lev2sec3"><em><strong>Abstraction Through
Indirection</strong></em></h4>
<p>At this point, you might object that I’m just kicking the can down
the road because we’re still left with the problem of how a function
like <span class="literal1">first</span> is able to work with different
data structures. Clojure does this using two forms of indirection. In
programming, <em>indirection</em> is a generic term for the mechanisms a
language employs so that one name can have multiple, related meanings.
In this case, the name <span class="literal1">first</span> has multiple,
data structure–specific meanings. Indirection is what makes abstraction
possible.</p>
<p><em>Polymorphism</em> is one way that Clojure provides indirection. I
don’t want to get lost in the details, but basically, polymorphic
functions dispatch to different function bodies based on the type of the
argument supplied. (It’s not so different from how multiple-arity
functions dispatch to different function bodies based on the number of
arguments you provide.)</p>
<div class="note">
<p><strong><span class="bordera">NOTE</span></strong></p>
<p><em>Clojure has two constructs for defining polymorphic dispatch: the
host platform’s</em> interface <em>construct and
platform-independent</em> protocols<em>. But it’s not necessary to
understand how these work when you’re just getting started. I’ll cover
protocols in <a href="#text_part0025.html_ch13" class="calibre4">Chapter
13</a>.</em></p>
</div>
<p><span id="text_part0015.html_page_78" class="calibre4"></span>When it
comes to sequences, Clojure also creates indirection by doing a kind of
lightweight type conversion, producing a data structure that works with
an abstraction’s functions. Whenever Clojure expects a sequence—for
example, when you call <span class="literal1">map</span>, <span
class="literal1">first</span>, <span class="literal1">rest</span>, or
<span class="literal1">cons</span>—it calls the <span
class="literal1">seq</span> function on the data structure in question
to obtain a data structure that allows for <span
class="literal1">first</span>, <span class="literal1">rest</span>, and
<span class="literal1">cons</span>:</p>
<pre class="programs"><code>(seq &#39;(1 2 3))
; =&gt; (1 2 3)


(seq [1 2 3])
; =&gt; (1 2 3)


(seq #{1 2 3})
; =&gt; (1 2 3)


(seq {:name &quot;Bill Compton&quot; :occupation &quot;Dead mopey guy&quot;})
; =&gt; ([:name &quot;Bill Compton&quot;] [:occupation &quot;Dead mopey guy&quot;])</code></pre>
<p>There are two notable details here. First, <span
class="literal1">seq</span> always returns a value that looks and
behaves like a list; you’d call this value a <em>sequence</em> or
<em>seq</em>. Second, the seq of a map consists of two-element key-value
vectors. That’s why <span class="literal1">map</span> treats your maps
like lists of vectors! You can see this in the <span
class="literal1">"Bill Compton"</span> example. I wanted to point out
this example in particular because it might be surprising and confusing.
It was for me when I first started using Clojure. Knowing these
underlying mechanisms will spare you from the kind of frustration and
general mopiness often exhibited by male vampires trying to retain their
humanity.</p>
<p>You can convert the seq back into a map by using <span
class="literal1">into</span> to stick the result into an empty map
(you’ll look at <span class="literal1">into</span> closely later):</p>
<pre class="programs"><code>(into {} (seq {:a 1 :b 2 :c 3}))
; =&gt; {:a 1, :c 3, :b 2}</code></pre>
<p>So, Clojure’s sequence functions use <span
class="literal1">seq</span> on their arguments. The sequence functions
are defined in terms of the sequence abstraction, using <span
class="literal1">first</span>, <span class="literal1">rest</span>, and
<span class="literal1">cons</span>. As long as a data structure
implements the sequence abstraction, it can use the extensive seq
library, which includes such superstar functions as <span
class="literal1">reduce</span>, <span class="literal1">filter</span>,
<span class="literal1">distinct</span>, <span
class="literal1">group-by</span>, and dozens more.</p>
<p>The takeaway here is that it’s powerful to focus on what we can
<em>do</em> with a data structure and to ignore, as much as possible,
its implementation. Implementations rarely matter in and of themselves.
They’re just a means to an end. In general, programming to abstractions
gives you power by letting you use libraries of functions on different
data structure regardless of how those data structures are
implemented.</p>
<h3 class="h2" id="text_part0015.html_ch04lev1sec2"><span
id="text_part0015.html_page_79" class="calibre1"></span><strong>Seq
Function Examples</strong></h3>
<p>Clojure’s seq library is full of useful functions that you’ll use all
the time. Now that you have a deeper understanding of Clojure’s sequence
abstraction, let’s look at these functions in detail. If you’re new to
Lisp and functional programming, these examples will be surprising and
delightful.</p>
<h4 class="h2"
id="text_part0015.html_ch04lev2sec4"><em><strong>map</strong></em></h4>
<p>You’ve seen many examples of <span class="literal1">map</span> by
now, but this section shows <span class="literal1">map</span> doing two
new tasks: taking multiple collections as arguments and taking a
collection of functions as an argument. It also highlights a common
<span class="literal1">map</span> pattern: using keywords as the mapping
function.</p>
<p>So far, you’ve only seen examples of <span
class="literal1">map</span> operating on one collection. In the
following code, the collection is the vector <span class="literal1">[1 2
3]</span>:</p>
<pre class="programs"><code>(map inc [1 2 3])
; =&gt; (2 3 4)</code></pre>
<p>However, you can also give <span class="literal1">map</span> multiple
collections. Here’s a simple example to show how this works:</p>
<pre class="programs"><code>(map str [&quot;a&quot; &quot;b&quot; &quot;c&quot;] [&quot;A&quot; &quot;B&quot; &quot;C&quot;])
; =&gt; (&quot;aA&quot; &quot;bB&quot; &quot;cC&quot;)</code></pre>
<p>It’s as if <span class="literal1">map</span> does the following:</p>
<pre class="programs"><code>(list (str &quot;a&quot; &quot;A&quot;) (str &quot;b&quot; &quot;B&quot;) (str &quot;c&quot; &quot;C&quot;))</code></pre>
<p>When you pass <span class="literal1">map</span> multiple collections,
the elements of the first collection (<span class="literal1">["a" "b"
"c"]</span>) will be passed as the first argument of the mapping
function (<span class="literal1">str</span>), the elements of the second
collection (<span class="literal1">["A" "B" "C"]</span>) will be passed
as the second argument, and so on. Just be sure that your mapping
function can take a number of arguments equal to the number of
collections you’re passing to <span class="literal1">map</span>.</p>
<p>The following example shows how you could use this capability if you
were a vampire trying to curb your human consumption. You have two
vectors, one representing human intake in liters and another
representing critter intake for the past four days. The <span
class="literal1">unify-diet-data</span> function takes a single day’s
data for both human and critter feeding and unifies the two into a
single map:</p>
<pre class="programs"><code>(def human-consumption  [8.1 7.3 6.6 5.0])
(def critter-consumption [0.0 0.2 0.3 1.1])
(defn unify-diet-data
  [human critter]
  {:human human
   :critter critter})
(map unify-diet-data human-consumption critter-consumption)
; =&gt; ({:human 8.1, :critter 0.0}
      {:human 7.3, :critter 0.2}
      {:human 6.6, :critter 0.3}
      {:human 5.0, :critter 1.8})</code></pre>
<div class="image">
<img src="images_00034.jpeg" class="calibre3" alt="image" />
</div>
<p>Good job laying off the human!</p>
<p>Another fun thing you can do with <span class="literal1">map</span>
is pass it a collection of functions. You could use this if you wanted
to perform a set of calculations on different collections of numbers,
like so:</p>
<pre class="programs"><code>(def sum #(reduce + %))
(def avg #(/ (sum %) (count %)))
(defn stats
  [numbers]
  (map #(% numbers) [sum count avg]))


(stats [3 4 10])
; =&gt; (17 3 17/3)


(stats [80 1 44 13 6])
; =&gt; (144 5 144/5)</code></pre>
<p>In this example, the <span class="literal1">stats</span> function
iterates over a vector of functions, applying each function to <span
class="literal1">numbers</span>.</p>
<p>Additionally, Clojurists often use <span class="literal1">map</span>
to retrieve the value associated with a keyword from a collection of map
data structures. Because keywords can be used as functions, you can do
this succinctly. Here’s an example:</p>
<pre class="programs"><code>(def identities
  [{:alias &quot;Batman&quot; :real &quot;Bruce Wayne&quot;}
   {:alias &quot;Spider-Man&quot; :real &quot;Peter Parker&quot;}
   {:alias &quot;Santa&quot; :real &quot;Your mom&quot;}
   {:alias &quot;Easter Bunny&quot; :real &quot;Your dad&quot;}])


(map :real identities)
; =&gt; (&quot;Bruce Wayne&quot; &quot;Peter Parker&quot; &quot;Your mom&quot; &quot;Your dad&quot;)</code></pre>
<p>(If you are five, then I apologize profusely.)</p>
<h4 class="h2"
id="text_part0015.html_ch04lev2sec5"><em><strong>reduce</strong></em></h4>
<p><a href="#text_part0014.html_ch03" class="calibre4">Chapter 3</a>
showed how <span class="literal1">reduce</span> processes each element
in a sequence to build a result. This section shows a couple of other
ways to use it that might not be obvious.</p>
<p>The first use is to transform a map’s values, producing a new map
with the same keys but with updated values:</p>
<pre class="programs"><code>(reduce (fn [new-map [key val]]
          (assoc new-map key (inc val)))

          {}
          {:max 30 :min 10})
; =&gt; {:max 31, :min 11}</code></pre>
<p>In this example, <span class="literal1">reduce</span> treats the
argument <span class="literal1">{:max 30 :min 10}</span> as a sequence
of vectors, like <span class="literal1">([:max 30] [:min 10])</span>.
Then, it starts with an empty map (the second argument) and builds it up
using the first argument, an anonymous function. It’s as if <span
class="literal1">reduce</span> does this:</p>
<pre class="programs"><code>(assoc (assoc {} :max (inc 30))
       :min (inc 10))</code></pre>
<p>Another use for <span class="literal1">reduce</span> is to filter out
keys from a map based on their value. In the following example, the
anonymous function checks whether the value of a key-value pair is
greather than 4. If it isn’t, then the key-value pair is filtered out.
In the map <span class="literal1">{:human 4.1 :critter 3.9}</span>, 3.9
is less than 4, so the <span class="literal1">:critter</span> key and
its 3.9 value are filtered out.</p>
<pre class="programs"><code>(reduce (fn [new-map [key val]]
          (if (&gt; val 4)
            (assoc new-map key val)
            new-map))
        {}
        {:human 4.1
         :critter 3.9})
; =&gt; {:human 4.1}</code></pre>
<p>The takeaway here is that <span class="literal1">reduce</span> is a
more flexible function than it first appears. Whenever you want to
derive a new value from a seqable data structure, <span
class="literal1">reduce</span> will usually be able to do what you need.
If you want an exercise that will really blow your hair back, try
implementing <span class="literal1">map</span> using <span
class="literal1">reduce</span>, and then do the same for <span
class="literal1">filter</span> and <span class="literal1">some</span>
after you read about them later in this chapter.</p>
<h4 class="h2" id="text_part0015.html_ch04lev2sec6"><em><strong>take,
drop, take-while, and drop-while</strong></em></h4>
<p><span class="literal1">take</span> and <span
class="literal1">drop</span> both take two arguments: a number and a
sequence. <span class="literal1">take</span> returns the first
<em>n</em> elements of the sequence, whereas <span
class="literal1">drop</span> returns the sequence with the first
<em>n</em> elements removed:</p>
<pre class="programs"><code>(take 3 [1 2 3 4 5 6 7 8 9 10])
; =&gt; (1 2 3)


(drop 3 [1 2 3 4 5 6 7 8 9 10])
; =&gt; (4 5 6 7 8 9 10)</code></pre>
<p>Their cousins <span class="literal1">take-while</span> and <span
class="literal1">drop-while</span> are a bit more interesting. Each
takes a <em>predicate function</em> (a function whose return value is
evaluated for truth or falsity) to determine when it should stop taking
or dropping. <span id="text_part0015.html_page_82"
class="calibre4"></span>Suppose, for example, that you had a vector
representing entries in your “food” journal. Each entry has the year,
month, day, and what you ate. To preserve space, we’ll only include a
few entries:</p>
<pre class="programs"><code>(def food-journal
  [{:month 1 :day 1 :human 5.3 :critter 2.3}
   {:month 1 :day 2 :human 5.1 :critter 2.0}
   {:month 2 :day 1 :human 4.9 :critter 2.1}
   {:month 2 :day 2 :human 5.0 :critter 2.5}
   {:month 3 :day 1 :human 4.2 :critter 3.3}
   {:month 3 :day 2 :human 4.0 :critter 3.8}
   {:month 4 :day 1 :human 3.7 :critter 3.9}
   {:month 4 :day 2 :human 3.7 :critter 3.6}])</code></pre>
<p>With <span class="literal1">take-while</span>, you can retrieve just
January’s and February’s data. <span class="literal1">take-while</span>
traverses the given sequence (in this case, <span
class="literal1">food-journal</span>), applying the predicate function
to each element.</p>
<p>This example uses the anonymous function <span
class="literal1">#(&lt; (:month %) 3)</span> to test whether the journal
entry’s month is out of range:</p>
<pre class="programs"><code>(take-while #(&lt; (:month %) 3) food-journal)
; =&gt; ({:month 1 :day 1 :human 5.3 :critter 2.3}
      {:month 1 :day 2 :human 5.1 :critter 2.0}
      {:month 2 :day 1 :human 4.9 :critter 2.1}
      {:month 2 :day 2 :human 5.0 :critter 2.5})</code></pre>
<p>When <span class="literal1">take-while</span> reaches the first March
entry, the anonymous function returns <span
class="literal1">false</span>, and <span
class="literal1">take-while</span> returns a sequence of every element
it tested until that point.</p>
<p>The same idea applies with <span class="literal1">drop-while</span>
except that it keeps dropping elements until one tests true:</p>
<pre class="programs"><code>(drop-while #(&lt; (:month %) 3) food-journal)
; =&gt; ({:month 3 :day 1 :human 4.2 :critter 3.3}
      {:month 3 :day 2 :human 4.0 :critter 3.8}
      {:month 4 :day 1 :human 3.7 :critter 3.9}
      {:month 4 :day 2 :human 3.7 :critter 3.6})</code></pre>
<p>By using <span class="literal1">take-while</span> and <span
class="literal1">drop-while</span> together, you can get data for just
February and March:</p>
<pre class="programs"><code>(take-while #(&lt; (:month %) 4)
            (drop-while #(&lt; (:month %) 2) food-journal))
; =&gt; ({:month 2 :day 1 :human 4.9 :critter 2.1}
      {:month 2 :day 2 :human 5.0 :critter 2.5}
      {:month 3 :day 1 :human 4.2 :critter 3.3}
      {:month 3 :day 2 :human 4.0 :critter 3.8})</code></pre>
<p>This example uses <span class="literal1">drop-while</span> to get rid
of the January entries, and then it uses <span
class="literal1">take-while</span> on the result to keep taking entries
until it reaches the first April entry.</p>
<h4 class="h2" id="text_part0015.html_ch04lev2sec7"><span
id="text_part0015.html_page_83"
class="calibre1"></span><em><strong>filter and some</strong></em></h4>
<p>Use <span class="literal1">filter</span> to return all elements of a
sequence that test true for a predicate function. Here are the journal
entries where human consumption is less than five liters:</p>
<pre class="programs"><code>(filter #(&lt; (:human %) 5) food-journal)
; =&gt; ({:month 2 :day 1 :human 4.9 :critter 2.1}
      {:month 3 :day 1 :human 4.2 :critter 3.3}
      {:month 3 :day 2 :human 4.0 :critter 3.8}
      {:month 4 :day 1 :human 3.7 :critter 3.9}
      {:month 4 :day 2 :human 3.7 :critter 3.6})</code></pre>
<p>You might be wondering why we didn’t just use <span
class="literal1">filter</span> in the <span
class="literal1">take-while</span> and <span
class="literal1">drop-while</span> examples earlier. Indeed, <span
class="literal1">filter</span> would work for that too. Here we’re
grabbing the January and February data, just like in the <span
class="literal1">take-while</span> example:</p>
<pre class="programs"><code>(filter #(&lt; (:month %) 3) food-journal)
; =&gt; ({:month 1 :day 1 :human 5.3 :critter 2.3}
      {:month 1 :day 2 :human 5.1 :critter 2.0}
      {:month 2 :day 1 :human 4.9 :critter 2.1}
      {:month 2 :day 2 :human 5.0 :critter 2.5})</code></pre>
<p>This use is perfectly fine, but <span class="literal1">filter</span>
can end up processing all of your data, which isn’t always necessary.
Because the food journal is already sorted by date, we know that <span
class="literal1">take-while</span> will return the data we want without
having to examine any of the data we won’t need. Therefore, <span
class="literal1">take-while</span> can be more efficient.</p>
<p>Often, you want to know whether a collection contains any values that
test true for a predicate function. The <span
class="literal1">some</span> function does that, returning the first
truthy value (any value that’s not <span class="literal1">false</span>
or <span class="literal1">nil</span>) returned by a predicate
function:</p>
<pre class="programs"><code>(some #(&gt; (:critter %) 5) food-journal)
; =&gt; nil


(some #(&gt; (:critter %) 3) food-journal)
; =&gt; true</code></pre>
<p>You don’t have any food journal entries where you consumed more than
five liters from critter sources, but you do have at least one where you
consumed more than three liters. Notice that the return value in the
second example is <span class="literal1">true</span> and not the actual
entry that produced the true value. The reason is that the anonymous
function <span class="literal1">#(&gt; (:critter %) 3)</span> returns
<span class="literal1">true</span> or <span
class="literal1">false</span>. Here’s how you could return the
entry:</p>
<pre class="programs"><code>(some #(and (&gt; (:critter %) 3) %) food-journal)
; =&gt; {:month 3 :day 1 :human 4.2 :critter 3.3}</code></pre>
<p><span id="text_part0015.html_page_84" class="calibre4"></span>Here, a
slightly different anonymous function uses <span
class="literal1">and</span> to first check whether the condition <span
class="literal1">(&gt; (:critter %) 3)</span> is true, and then returns
the entry when the condition is indeed true.</p>
<h4 class="h2" id="text_part0015.html_ch04lev2sec8"><em><strong>sort and
sort-by</strong></em></h4>
<p>You can sort elements in ascending order with <span
class="literal1">sort</span>:</p>
<pre class="programs"><code>(sort [3 1 2])
; =&gt; (1 2 3)</code></pre>
<p>If your sorting needs are more complicated, you can use <span
class="literal1">sort-by</span>, which allows you to apply a function
(sometimes called a <em>key function</em>) to the elements of a sequence
and use the values it returns to determine the sort order. In the
following example, which is taken from <em><a
href="http://clojuredocs.org/"
class="calibre4">http://clojuredocs.org/</a></em>, <span
class="literal1">count</span> is the key function:</p>
<pre class="programs"><code>(sort-by count [&quot;aaa&quot; &quot;c&quot; &quot;bb&quot;])
; =&gt; (&quot;c&quot; &quot;bb&quot; &quot;aaa&quot;)</code></pre>
<p>If you were sorting using <span class="literal1">sort</span>, the
elements would be sorted in alphabetical order, returning <span
class="literal1">("aaa" "bb" "c")</span>. Instead, the result is <span
class="literal1">("c" "bb" "aaa")</span> because you’re sorting by <span
class="literal1">count</span> and the count of <span
class="literal1">"c"</span> is 1, <span class="literal1">"bb"</span> is
2, and <span class="literal1">"aaa"</span> is 3.</p>
<h4 class="h2"
id="text_part0015.html_ch04lev2sec9"><em><strong>concat</strong></em></h4>
<p>Finally, <span class="literal1">concat</span> simply appends the
members of one sequence to the end of another:</p>
<pre class="programs"><code>(concat [1 2] [3 4])
; =&gt; (1 2 3 4)</code></pre>
<h3 class="h2" id="text_part0015.html_ch04lev1sec3"><strong>Lazy
Seqs</strong></h3>
<p>As you saw earlier, <span class="literal1">map</span> first calls
<span class="literal1">seq</span> on the collection you pass to it. But
that’s not the whole story. Many functions, including <span
class="literal1">map</span> and <span class="literal1">filter</span>,
return a <em>lazy seq</em>. A lazy seq is a seq whose members aren’t
computed until you try to access them. Computing a seq’s members is
called <em>realizing</em> the seq. Deferring the computation until the
moment it’s needed makes your programs more efficient, and it has the
surprising benefit of allowing you to construct infinite sequences.</p>
<h4 class="h2"
id="text_part0015.html_ch04lev2sec10"><em><strong>Demonstrating Lazy Seq
Efficiency</strong></em></h4>
<p>To see lazy seqs in action, pretend that you’re part of a modern-day
task force whose purpose is to identify vampires. Your intelligence
agents tell you that there is only one active vampire in your city, and
they’ve helpfully <span id="text_part0015.html_page_85"
class="calibre4"></span>narrowed down the list of suspects to a million
people. Your boss gives you a list of one million Social Security
numbers and shouts, “Get it done, McFishwich!”</p>
<p>Thankfully, you are in possession of a Vampmatic 3000 computifier,
the state-of-the-art device for vampire identification. Because the
source code for this vampire-hunting technology is proprietary, I’ve
stubbed it out to simulate the time it would take to perform this task.
Here is a subset of a vampire database:</p>
<pre class="programs"><code>(def vampire-database
  {0 {:makes-blood-puns? false, :has-pulse? true  :name &quot;McFishwich&quot;}
   1 {:makes-blood-puns? false, :has-pulse? true  :name &quot;McMackson&quot;}
   2 {:makes-blood-puns? true,  :has-pulse? false :name &quot;Damon Salvatore&quot;}
   3 {:makes-blood-puns? true,  :has-pulse? true  :name &quot;Mickey Mouse&quot;}})


(defn vampire-related-details
  [social-security-number]
  (Thread/sleep 1000)
  (get vampire-database social-security-number))


(defn vampire?
  [record]
  (and (:makes-blood-puns? record)
       (not (:has-pulse? Record))
       record))


(defn identify-vampire
  [social-security-numbers]
  (first (filter vampire?
                 (map vampire-related-details social-security-numbers))))</code></pre>
<p>You have a function, <span
class="literal1">vampire-related-details</span>, which takes one second
to look up an entry from the database. Next, you have a function, <span
class="literal1">vampire?</span>, which returns a record if it passes
the vampire test; otherwise, it returns <span
class="literal1">false</span>. Finally, <span
class="literal1">identify-vampire</span> maps Social Security numbers to
database records and then returns the first record that indicates
vampirism.</p>
<p>To show how much time it takes to run these functions, you can use
the <span class="literal1">time</span> operation. When you use <span
class="literal1">time</span>, your code behaves exactly as it would if
you didn’t use <span class="literal1">time</span>, but with one
exception: a report of the elapsed time is printed. Here’s an
example:</p>
<pre class="programs"><code>(time (vampire-related-details 0))
; =&gt; &quot;Elapsed time: 1001.042 msecs&quot;
; =&gt; {:name &quot;McFishwich&quot;, :makes-blood-puns? false, :has-pulse? true}</code></pre>
<p>The first printed line reports the time taken by the given
operation—in this case, 1,001.042 milliseconds. The second is the return
value, which is your database record in this case. The return value is
exactly the same as it would have been if you hadn’t used <span
class="literal1">time</span>.</p>
<p>A nonlazy implementation of <span class="literal1">map</span> would
first have to apply <span
class="literal1">vampire-related-details</span> to every member of <span
class="literal1">social-security-numbers</span> before passing <span
id="text_part0015.html_page_86" class="calibre4"></span>the result to
<span class="literal1">filter</span>. Because you have one million
suspects, this would take one million seconds, or 12 days, and half your
city would be dead by then! Of course, if it turns out that the only
vampire is the last suspect in the record, it will still take that much
time with the lazy version, but at least there’s a good chance that it
won’t.</p>
<p>Because <span class="literal1">map</span> is lazy, it doesn’t
actually apply <span class="literal1">vampire-related-details</span> to
Social Security numbers until you try to access the mapped element. In
fact, <span class="literal1">map</span> returns a value almost
instantly:</p>
<pre class="programs"><code>(time (def mapped-details (map vampire-related-details (range 0 1000000))))
; =&gt; &quot;Elapsed time: 0.049 msecs&quot;
; =&gt; #&#39;user/mapped-details</code></pre>
<p>In this example, <span class="literal1">range</span> returns a lazy
sequence consisting of the integers from 0 to 999,999. Then, <span
class="literal1">map</span> returns a lazy sequence that is associated
with the name <span class="literal1">mapped-details</span>. Because
<span class="literal1">map</span> didn’t actually apply <span
class="literal1">vampire-related-details</span> to any of the elements
returned by <span class="literal1">range</span>, the entire operation
took barely any time—certainly less than 12 days.</p>
<p>You can think of a lazy seq as consisting of two parts: a recipe for
how to realize the elements of a sequence and the elements that have
been realized so far. When you use <span class="literal1">map</span>,
the lazy seq it returns doesn’t include any realized elements yet, but
it does have the recipe for generating its elements. Every time you try
to access an unrealized element, the lazy seq will use its recipe to
generate the requested element.</p>
<p>In the previous example, <span class="literal1">mapped-details</span>
is unrealized. Once you try to access a member of <span
class="literal1">mapped-details</span>, it will use its recipe to
generate the element you’ve requested, and you’ll incur the
one-second-per-database-lookup cost:</p>
<pre class="programs"><code>(time (first mapped-details))
; =&gt; &quot;Elapsed time: 32030.767 msecs&quot;
; =&gt; {:name &quot;McFishwich&quot;, :makes-blood-puns? false, :has-pulse? true}</code></pre>
<p>This operation took about 32 seconds. That’s much better than one
million seconds, but it’s still 31 seconds more than we would have
expected. After all, you’re only trying to access the very first
element, so it should have taken only one second.</p>
<p>The reason it took 32 seconds is that Clojure <em>chunks</em> its
lazy sequences, which just means that whenever Clojure has to realize an
element, it preemptively realizes some of the next elements as well. In
this example, you wanted only the very first element of <span
class="literal1">mapped-details</span>, but Clojure went ahead and
prepared the next 31 as well. Clojure does this because it almost always
results in better performance.</p>
<p>Thankfully, lazy seq elements need to be realized only once.
Accessing the first element of <span
class="literal1">mapped-details</span> again takes almost no time:</p>
<pre class="programs"><code>(time (first mapped-details))
; =&gt; &quot;Elapsed time: 0.022 msecs&quot;
; =&gt; {:name &quot;McFishwich&quot;, :makes-blood-puns? false, :has-pulse? true}</code></pre>
<p><span id="text_part0015.html_page_87" class="calibre4"></span>With
all this newfound knowledge, you can efficiently mine the vampire
database to find the fanged culprit:</p>
<pre class="programs"><code>(time (identify-vampire (range 0 1000000)))
&quot;Elapsed time: 32019.912 msecs&quot;
; =&gt; {:name &quot;Damon Salvatore&quot;, :makes-blood-puns? true, :has-pulse? false}</code></pre>
<p>Ooh! That’s why Damon makes those creepy puns!</p>
<h4 class="h2"
id="text_part0015.html_ch04lev2sec11"><em><strong>Infinite
Sequences</strong></em></h4>
<p>One cool, useful capability that lazy seqs give you is the ability to
construct infinite sequences. So far, you’ve only worked with lazy
sequences generated from vectors or lists that terminated. However,
Clojure comes with a few functions to create infinite sequences. One
easy way to create an infinite sequence is with <span
class="literal1">repeat</span>, which creates a sequence whose every
member is the argument you pass:</p>
<pre class="programs"><code>(concat (take 8 (repeat &quot;na&quot;)) [&quot;Batman!&quot;])
; =&gt; (&quot;na&quot; &quot;na&quot; &quot;na&quot; &quot;na&quot; &quot;na&quot; &quot;na&quot; &quot;na&quot; &quot;na&quot; &quot;Batman!&quot;)</code></pre>
<p>In this case, you create an infinite sequence whose every element is
the string <span class="literal1">"na"</span>, then use that to
construct a sequence that may or not provoke nostalgia.</p>
<p>You can also use <span class="literal1">repeatedly</span>, which will
call the provided function to generate each element in the sequence:</p>
<pre class="programs"><code>(take 3 (repeatedly (fn [] (rand-int 10))))
; =&gt; (1 4 0)</code></pre>
<p>Here, the lazy sequence returned by <span
class="literal1">repeatedly</span> generates every new element by
calling the anonymous function <span class="literal1">(fn [] (rand-int
10))</span>, which returns a random integer between 0 and 9. If you run
this in your REPL, your result will most likely be different from this
one.</p>
<p>A lazy seq’s recipe doesn’t have to specify an endpoint. Functions
like <span class="literal1">first</span> and <span
class="literal1">take</span>, which realize the lazy seq, have no way of
knowing what will come next in a seq, and if the seq keeps providing
elements, well, they’ll just keep taking them. You can see this if you
construct your own infinite sequence:</p>
<pre class="programs"><code>(defn even-numbers
  ([] (even-numbers 0))
  ([n] (cons n (lazy-seq (even-numbers (+ n 2))))))


(take 10 (even-numbers))
; =&gt; (0 2 4 6 8 10 12 14 16 18)</code></pre>
<p><span id="text_part0015.html_page_88" class="calibre4"></span>This
example is a bit mind-bending because of its use of recursion. It helps
to remember that <span class="literal1">cons</span> returns a new list
with an element appended to the given list:</p>
<pre class="programs"><code>(cons 0 &#39;(2 4 6))
; =&gt; (0 2 4 6)</code></pre>
<p>(Incidentally, Lisp programmers call it <em>consing</em> when they
use the <span class="literal1">cons</span> function.)</p>
<p>In <span class="literal1">even-numbers</span>, you’re consing to a
lazy list, which includes a recipe (a function) for the next element (as
opposed to consing to a fully realized list).</p>
<p>And that covers lazy seqs! Now you know everything there is to know
about the sequence abstraction, and we can turn to the collection
abstraction!</p>
<h3 class="h2" id="text_part0015.html_ch04lev1sec4"><strong>The
Collection Abstraction</strong></h3>
<p>The collection abstraction is closely related to the sequence
abstraction. All of Clojure’s core data structures—vectors, maps, lists,
and sets—take part in both abstractions.</p>
<p>The sequence abstraction is about operating on members individually,
whereas the collection abstraction is about the data structure as a
whole. For example, the collection functions <span
class="literal1">count</span>, <span class="literal1">empty?</span>, and
<span class="literal1">every?</span> aren’t about any individual
element; they’re about the whole:</p>
<pre class="programs"><code>(empty? [])
; =&gt; true


(empty? [&quot;no!&quot;])
; =&gt; false</code></pre>
<p>Practically speaking, you’ll rarely consciously say, “Okay, self!
You’re working with the collection as a whole now. Think in terms of the
collection abstraction!” Nevertheless, it’s useful to know these
concepts that underlie the functions and data structures you’re
using.</p>
<p>Now we’ll examine two common collection functions—<span
class="literal1">into</span> and <span
class="literal1">conj</span>—whose similarities can be a bit
confusing.</p>
<h4 class="h2"
id="text_part0015.html_ch04lev2sec12"><em><strong>into</strong></em></h4>
<p>One of the most important collection functions is <span
class="literal1">into</span>. As you now know, many seq functions return
a seq rather than the original data structure. You’ll probably want to
convert the return value back into the original value, and <span
class="literal1">into</span> lets you do that:</p>
<pre class="programs"><code>(map identity {:sunlight-reaction &quot;Glitter!&quot;})
; =&gt; ([:sunlight-reaction &quot;Glitter!&quot;])


(into {} (map identity {:sunlight-reaction &quot;Glitter!&quot;}))
; =&gt; {:sunlight-reaction &quot;Glitter!&quot;}</code></pre>
<p><span id="text_part0015.html_page_89" class="calibre4"></span>Here,
the <span class="literal1">map</span> function returns a sequential data
structure after being given a map data structure, and into converts the
seq back into a map.</p>
<p>This will work with other data structures as well:</p>
<pre class="programs"><code>(map identity [:garlic :sesame-oil :fried-eggs])
; =&gt; (:garlic :sesame-oil :fried-eggs)


(into [] (map identity [:garlic :sesame-oil :fried-eggs]))
; =&gt; [:garlic :sesame-oil :fried-eggs]</code></pre>
<p>Here, in the first line, <span class="literal1">map</span> returns a
seq, and we use <span class="literal1">into</span> in the second line to
convert the result back to a vector.</p>
<p>In the following example, we start with a vector with two identical
entries, <span class="literal1">map</span> converts it to a list, and
then we use <span class="literal1">into</span> to stick the values into
a set.</p>
<pre class="programs"><code>(map identity [:garlic-clove :garlic-clove])
; =&gt; (:garlic-clove :garlic-clove)


(into #{} (map identity [:garlic-clove :garlic-clove]))
; =&gt; #{:garlic-clove}</code></pre>
<p>Because sets only contain unique values, the set ends up with just
one value in it.</p>
<p>The first argument of <span class="literal1">into</span> doesn’t have
to be empty. Here, the first example shows how you can use <span
class="literal1">into</span> to add elements to a map, and the second
shows how you can add elements to a vector.</p>
<pre class="programs"><code>(into {:favorite-emotion &quot;gloomy&quot;} [[:sunlight-reaction &quot;Glitter!&quot;]])
; =&gt; {:favorite-emotion &quot;gloomy&quot; :sunlight-reaction &quot;Glitter!&quot;}


(into [&quot;cherry&quot;] &#39;(&quot;pine&quot; &quot;spruce&quot;))
; =&gt; [&quot;cherry&quot; &quot;pine&quot; &quot;spruce&quot;]</code></pre>
<p>And, of course, both arguments can be the same type. In this next
example, both arguments are maps, whereas all the previous examples had
arguments of different types. It works as you’d expect, returning a new
map with the elements of the second map added to the first:</p>
<pre class="programs"><code>(into {:favorite-animal &quot;kitty&quot;} {:least-favorite-smell &quot;dog&quot;
                                  :relationship-with-teenager &quot;creepy&quot;})
; =&gt; {:favorite-animal &quot;kitty&quot;
      :relationship-with-teenager &quot;creepy&quot;
      :least-favorite-smell &quot;dog&quot;}</code></pre>
<p>If <span class="literal1">into</span> were asked to describe its
strengths at a job interview, it would say, “I’m great at taking two
collections and adding all the elements from the second to the
first.”</p>
<h4 class="h2" id="text_part0015.html_ch04lev2sec13"><span
id="text_part0015.html_page_90"
class="calibre1"></span><em><strong>conj</strong></em></h4>
<p><span class="literal1">conj</span> also adds elements to a
collection, but it does it in a slightly different way:</p>
<pre class="programs"><code>(conj [0] [1])
; =&gt; [0 [1]]</code></pre>
<p>Whoopsie! Looks like it added the entire vector <span
class="literal1">[1]</span> to <span class="literal1">[0]</span>.
Compare this with <span class="literal1">into</span>:</p>
<pre class="programs"><code>(into [0] [1])
; =&gt; [0 1]</code></pre>
<p>Here’s how we’d do the same with <span
class="literal1">conj</span>:</p>
<pre class="programs"><code>(conj [0] 1)
; =&gt; [0 1]</code></pre>
<p>Notice that the number 1 is passed as a scalar (singular,
non-collection) value, whereas <span class="literal1">into</span>’s
second argument must be a collection.</p>
<p>You can supply as many elements to add with <span
class="literal1">conj</span> as you want, and you can also add to other
collections like maps:</p>
<pre class="programs"><code>(conj [0] 1 2 3 4)
; =&gt; [0 1 2 3 4]


(conj {:time &quot;midnight&quot;} [:place &quot;ye olde cemetarium&quot;])
; =&gt; {:place &quot;ye olde cemetarium&quot; :time &quot;midnight&quot;}</code></pre>
<p><span class="literal1">conj</span> and <span
class="literal1">into</span> are so similar that you could even define
<span class="literal1">conj</span> in terms of <span
class="literal1">into</span>:</p>
<pre class="programs"><code>(defn my-conj
  [target &amp; additions]
  (into target additions))


(my-conj [0] 1 2 3)
; =&gt; [0 1 2 3]</code></pre>
<p>This kind of pattern isn’t that uncommon. You’ll often see two
functions that do the same thing, except one takes a rest parameter
(<span class="literal1">conj</span>) and one takes a seqable data
structure (<span class="literal1">into</span>).</p>
<h3 class="h2" id="text_part0015.html_ch04lev1sec5"><strong>Function
Functions</strong></h3>
<p>Learning to take advantage of Clojure’s ability to accept functions
as arguments and return functions as values is really fun, even if it
takes some getting used to.</p>
<p>Two of Clojure’s functions, <span class="literal1">apply</span> and
<span class="literal1">partial</span>, might seem especially weird
because they both accept <em>and</em> return functions. Let’s unweird
them.</p>
<h4 class="h2" id="text_part0015.html_ch04lev2sec14"><span
id="text_part0015.html_page_91"
class="calibre1"></span><em><strong>apply</strong></em></h4>
<p><span class="literal1">apply</span> <em>explodes</em> a seqable data
structure so it can be passed to a function that expects a rest
parameter. For example, <span class="literal1">max</span> takes any
number of arguments and returns the greatest of all the arguments.
Here’s how you’d find the greatest number:</p>
<pre class="programs"><code>(max 0 1 2)
; =&gt; 2</code></pre>
<p>But what if you want to find the greatest element of a vector? You
can’t just pass the vector to <span class="literal1">max</span>:</p>
<pre class="programs"><code>(max [0 1 2])
; =&gt; [0 1 2]</code></pre>
<p>This doesn’t return the greatest element in the vector because <span
class="literal1">max</span> returns the greatest of all the arguments
passed to it, and in this case you’re only passing it a vector
containing all the numbers you want to compare, rather than passing in
the numbers as separate arguments. <span class="literal1">apply</span>
is perfect for this situation:</p>
<pre class="programs"><code>(apply max [0 1 2])
; =&gt; 2</code></pre>
<p>By using <span class="literal1">apply</span>, it’s as if you called
<span class="literal1">(max 0 1 2)</span>. You’ll often use <span
class="literal1">apply</span> like this, exploding the elements of a
collection so that they get passed to a function as separate
arguments.</p>
<p>Remember how we defined <span class="literal1">conj</span> in terms
of <span class="literal1">into</span> earlier? Well, we can also define
<span class="literal1">into</span> in terms of <span
class="literal1">conj</span> by using <span
class="literal1">apply</span>:</p>
<pre class="programs"><code>(defn my-into
  [target additions]
  (apply conj target additions))


(my-into [0] [1 2 3])
; =&gt; [0 1 2 3]</code></pre>
<p>This call to <span class="literal1">my-into</span> is equivalent to
calling <span class="literal1">(conj [0] 1 2 3)</span>.</p>
<h4 class="h2"
id="text_part0015.html_ch04lev2sec15"><em><strong>partial</strong></em></h4>
<p><span class="literal1">partial</span> takes a function and any number
of arguments. It then returns a new function. When you call the returned
function, it calls the original function with the original arguments you
supplied it along with the new arguments.</p>
<p>Here’s an example:</p>
<pre class="programs"><code>(def add10 (partial + 10))
(add10 3)
; =&gt; 13
(add10 5)
; =&gt; 15


(def add-missing-elements
  (partial conj [&quot;water&quot; &quot;earth&quot; &quot;air&quot;]))


(add-missing-elements &quot;unobtainium&quot; &quot;adamantium&quot;)
; =&gt; [&quot;water&quot; &quot;earth&quot; &quot;air&quot; &quot;unobtainium&quot; &quot;adamantium&quot;]</code></pre>
<p>So when you call <span class="literal1">add10</span>, it calls the
original function and arguments (<span class="literal1">+ 10</span>) and
tacks on whichever arguments you call <span
class="literal1">add10</span> with. To help clarify how <span
class="literal1">partial</span> works, here’s how you might define
it:</p>
<pre class="programs"><code>(defn my-partial
  [partialized-fn &amp; args]
  (fn [&amp; more-args]
    (apply partialized-fn (into args more-args))))


(def add20 (my-partial + 20))
(add20 3)
; =&gt; 23</code></pre>
<p>In this example, the value of <span class="literal1">add20</span> is
the anonymous function returned by <span
class="literal1">my-partial</span>. The anonymous function is defined
like this:</p>
<pre class="programs"><code>(fn [&amp; more-args]
  (apply + (into [20] more-args)))</code></pre>
<p>In general, you want to use partials when you find you’re repeating
the same combination of function and arguments in many different
contexts. This toy example shows how you could use <span
class="literal1">partial</span> to specialize a logger, creating a <span
class="literal1">warn</span> function:</p>
<pre class="programs"><code>(defn lousy-logger
  [log-level message]
  (condp = log-level
    :warn (clojure.string/lower-case message)
    :emergency (clojure.string/upper-case message)))


(def warn (partial lousy-logger :warn))


(warn &quot;Red light ahead&quot;)
; =&gt; &quot;red light ahead&quot;</code></pre>
<p>Calling <span class="literal1">(warn "Red light ahead")</span> here
is identical to calling <span class="literal1">(lousy-logger :warn "Red
light ahead")</span>.</p>
<h4 class="h2"
id="text_part0015.html_ch04lev2sec16"><em><strong>complement</strong></em></h4>
<p>Earlier you created the <span
class="literal1">identify-vampire</span> function to find one vampire
amid a million people. What if you wanted to create a function to find
all humans? <span id="text_part0015.html_page_93"
class="calibre4"></span>Perhaps you want to send them thank-you cards
for not being an undead predator. Here’s how you could do it:</p>
<pre class="programs"><code>(defn identify-humans
  [social-security-numbers]
  (filter #(not (vampire? %))
          (map vampire-related-details social-security-numbers)))</code></pre>
<p>Look at the first argument to <span class="literal1">filter</span>,
<span class="literal1">#(not (vampire? %))</span>. It’s so common to
want the <em>complement</em> (the negation) of a Boolean function that
there’s a function, <span class="literal1">complement</span>, for
that:</p>
<pre class="programs"><code>(def not-vampire? (complement vampire?))
(defn identify-humans
  [social-security-numbers]
  (filter not-vampire?
          (map vampire-related-details social-security-numbers)))</code></pre>
<p>Here’s how you might implement <span
class="literal1">complement</span>:</p>
<pre class="programs"><code>(defn my-complement
  [fun]
  (fn [&amp; args]
    (not (apply fun args))))


(def my-pos? (complement neg?))
(my-pos? 1)
; =&gt; true


(my-pos? -1)
; =&gt; false</code></pre>
<p>As you can see, <span class="literal1">complement</span> is a humble
function. It does one little thing and does it well. <span
class="literal1">complement</span> made it trivial to create a <span
class="literal1">not-vampire?</span> function, and anyone reading the
code could understand the code’s intention.</p>
<p>This won’t MapReduce terabytes of data for you or anything like that,
but it does demonstrate the power of higher-order functions. They allow
you to build up libraries of utility functions in a way that is
impossible in some languages. In aggregate, these utility functions make
your life a lot easier.</p>
<h3 class="h2" id="text_part0015.html_ch04lev1sec6"><strong>A Vampire
Data Analysis Program for the FWPD</strong></h3>
<p>To pull everything together, let’s write the beginnings of a
sophisticated vampire data analysis program for the Forks, Washington
Police Department (FWPD).</p>
<p>The FWPD has a fancy new database technology called <em>CSV
(comma-separated values)</em>. Your job is to parse this
state-of-the-art CSV and analyze <span id="text_part0015.html_page_94"
class="calibre4"></span>it for potential vampires. We’ll do that by
filtering on each suspect’s <em>glitter index</em>, a 0–10 prediction of
the suspect’s vampireness developed by some teenage girl. Go ahead and
create a new Leiningen project for your tool:</p>
<pre class="programs"><code>lein new app fwpd</code></pre>
<p>Under the new <em>fwpd</em> directory, create a file named
<em>suspects.csv</em> and enter contents like the following:</p>
<pre class="programs"><code>Edward Cullen,10
Bella Swan,0
Charlie Swan,0
Jacob Black,3
Carlisle Cullen,6</code></pre>
<p>Now it’s time to get your hands dirty by building up the
<em>fwpd/src/fwpd/core.clj</em> file. I recommend that you start a new
REPL session so you can try things out as you go along. In Emacs you can
do this by opening <em>fwpd/src/fwpd/core.clj</em> and running
<strong>M-x</strong> <span
class="literal1"><strong>cider-restart</strong></span>. Once the REPL is
started, delete the contents of <em>core.clj</em>, and then add
this:</p>
<pre class="programs"><code>(ns fwpd.core)
(def filename &quot;suspects.csv&quot;)</code></pre>
<p>The first line establishes the namespace, and the second just makes
it a tiny bit easier to refer to the CSV you created. You can do a quick
sanity check in your REPL by compiling your file (<strong>C-c
C-k</strong> in Emacs) and running this:</p>
<pre class="programs"><code>(slurp filename)
; =&gt; &quot;Edward Cullen,10\nBella Swan,0\nCharlie Swan,0\nJacob Black,3\nCarlisle Cullen,6&quot;</code></pre>
<p>If the <span class="literal1">slurp</span> function doesn’t return
the preceding string, try restarting your REPL session with
<em>core.clj</em> open.</p>
<p>Next, add this to <em>core.clj</em>:</p>
<pre class="programs"><code>➊ (def vamp-keys [:name :glitter-index])


➋ (defn str-&gt;int
    [str]
    (Integer. str))


➌ (def conversions {:name identity
                    :glitter-index str-&gt;int})


➍ (defn convert
    [vamp-key value]
    ((get conversions vamp-key) value))</code></pre>
<p>Ultimately, you’ll end up with a sequence of maps that look like
<span class="literal1">{:name "Edward Cullen" :glitter-index 10}</span>,
and the preceding definitions help <span id="text_part0015.html_page_95"
class="calibre4"></span>you get there. First, <span
class="literal1">vamp-keys</span> <span class="ent">➊</span> is a vector
of the keys that you’ll soon use to create vampire maps. Next, the
function <span class="literal1">str-&gt;int</span> <span
class="ent">➋</span> converts a string to an integer. The map <span
class="literal1">conversions</span> <span class="ent">➌</span>
associates a conversion function with each of the vamp keys. You don’t
need to transform the name at all, so its conversion function is <span
class="literal1">identity</span>, which just returns the argument passed
to it. The glitter index is converted to an integer, so its conversion
function is <span class="literal1">str-&gt;int</span>. Finally, the
<span class="literal1">convert</span> function <span
class="ent">➍</span> takes a vamp key and a value, and returns the
converted value. Here’s an example:</p>
<pre class="programs"><code>(convert :glitter-index &quot;3&quot;)
; =&gt; 3</code></pre>
<p>Now add this to your file:</p>
<pre class="programs"><code>(defn parse
  &quot;Convert a CSV into rows of columns&quot;
  [string]
  (map #(clojure.string/split % #&quot;,&quot;)
       (clojure.string/split string #&quot;\n&quot;)))</code></pre>
<p>The <span class="literal1">parse</span> function takes a string and
first splits it on the newline character to create a seq of strings.
Next, it maps over the seq of strings, splitting each one on the comma
character. Try running <span class="literal1">parse</span> on your
CSV:</p>
<pre class="programs"><code>(parse (slurp filename))
; =&gt; ([&quot;Edward Cullen&quot; &quot;10&quot;] [&quot;Bella Swan&quot; &quot;0&quot;] [&quot;Charlie Swan&quot; &quot;0&quot;]
      [&quot;Jacob Black&quot; &quot;3&quot;] [&quot;Carlisle Cullen&quot; &quot;6&quot;])</code></pre>
<p>The next bit of code takes the seq of vectors and combines it with
your vamp keys to create maps:</p>
<pre class="programs"><code>(defn mapify
  &quot;Return a seq of maps like {:name \&quot;Edward Cullen\&quot; :glitter-index 10}&quot;
  [rows]
  (map (fn [unmapped-row]
         (reduce (fn [row-map [vamp-key value]]
                   (assoc row-map vamp-key (convert vamp-key value)))
                 {}
                 (map vector vamp-keys unmapped-row)))
       rows))</code></pre>
<p>In this function, <span class="literal1">map</span> transforms each
row—vectors like <span class="literal1">["Bella Swan" 0]</span>—into a
map by using <span class="literal1">reduce</span> in a manner similar to
the first example in “<span class="literal1">reduce</span>” on <a
href="#text_part0015.html_page_80" class="calibre4">page 80</a>. First,
<span class="literal1">map</span> creates a seq of key-value pairs like
<span class="literal1">([:name "Bella Swan"] [:glitter-index] 0)</span>.
Then, <span class="literal1">reduce</span> builds up a map by
associating a vamp key with a converted vamp value into <span
class="literal1">row-map</span>. Here’s the first row mapified:</p>
<pre class="programs"><code>(first (mapify (parse (slurp filename))))
; =&gt; {:glitter-index 10, :name &quot;Edward Cullen&quot;}</code></pre>
<p><span id="text_part0015.html_page_96"
class="calibre4"></span>Finally, add this <span
class="literal1">glitter-filter</span> function:</p>
<pre class="programs"><code>(defn glitter-filter
  [minimum-glitter records]
  (filter #(&gt;= (:glitter-index %) minimum-glitter) records))</code></pre>
<p>This takes fully mapified vampire records and filters out those with
a <span class="literal1">:glitter-index</span> less than the provided
<span class="literal1">minimum-glitter</span>:</p>
<pre class="programs"><code>(glitter-filter 3 (mapify (parse (slurp filename))))
({:name &quot;Edward Cullen&quot;, :glitter-index 10}
 {:name &quot;Jacob Black&quot;, :glitter-index 3}
 {:name &quot;Carlisle Cullen&quot;, :glitter-index 6})</code></pre>
<p>Et voilà! You are now one step closer to fulfilling your dream of
being a supernatural-creature-hunting vigilante. You better go round up
those sketchy characters!</p>
<h3 class="h2"
id="text_part0015.html_ch04lev1sec7"><strong>Summary</strong></h3>
<p>In this chapter, you learned that Clojure emphasizes programming to
abstractions. The sequence abstraction deals with operating on the
individual elements of a sequence, and seq functions often convert their
arguments to a seq and return a lazy seq. Lazy evaluation improves
performance by delaying computations until they’re needed. The other
abstraction you learned about, the collection abstraction, deals with
data structures as a whole. Finally, the most important thing you
learned is that you should never trust someone who sparkles in
sunlight.</p>
<h3 class="h2" id="text_part0015.html_ch04lev1sec8"><strong><span
class="bordera">Exercises</span></strong></h3>
<p>The vampire analysis program you now have is already decades ahead of
anything else on the market. But how could you make it better? I suggest
trying the following:</p>
<p>1. Turn the result of your glitter filter into a list of names.</p>
<p>2. Write a function, <span class="literal1">append</span>, which will
append a new suspect to your list of suspects.</p>
<p>3. Write a function, <span class="literal1">validate</span>, which
will check that <span class="literal1">:name</span> and <span
class="literal1">:glitter-index</span> are present when you <span
class="literal1">append</span>. The <span
class="literal1">validate</span> function should accept two arguments: a
map of keywords to validating functions, similar to <span
class="literal1">conversions</span>, and the record to be validated.</p>
<p>4. Write a function that will take your list of maps and convert it
back to a CSV string. You’ll need to use the <span
class="literal1">clojure.string/join</span> function.</p>
<p>Good luck, McFishwich!</p>
<p><span id="text_part0016.html"></span></p>
<h2 class="h1" id="text_part0016.html_ch05"><span
id="text_part0016.html_page_97" class="calibre1"></span><strong><span
class="big1">5</span></strong><br />
<strong>Functional Programming</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>So far, you’ve focused on becoming familiar with the tools that
Clojure provides: immutable data structures, functions, abstractions,
and so on. In this chapter, you’ll learn how to think about your
programming tasks in a way that makes the best use of those tools.
You’ll begin integrating your experience into a new functional
programming mindset.</p>
<p>The core concepts you’ll learn include: what pure functions are and
why they’re useful; how to work with immutable data structures and why
they’re superior to their mutable cousins; how disentangling data and
functions gives you more power and flexibility; and why it’s powerful to
program to a small set of data abstractions. Once you shove all this
knowledge into your brain matter, you’ll have an entirely new approach
to problem solving!</p>
<p><span id="text_part0016.html_page_98" class="calibre4"></span>After
going over these topics, you’ll put everything you’ve learned to use by
writing a terminal-based game inspired by an ancient, mystic
mind-training device found in Cracker Barrel restaurants across America:
Peg Thing!</p>
<h3 class="h2" id="text_part0016.html_ch05lev1sec1"><strong>Pure
Functions: What and Why</strong></h3>
<p>Except for <span class="literal1">println</span> and <span
class="literal1">rand</span>, all the functions you’ve used up till now
have been pure functions. What makes them pure functions, and why does
it matter? A function is pure if it meets two qualifications:</p>
<p>• It always returns the same result if given the same arguments. This
is called <em>referential transparency</em>, and you can add it to your
list of $5 programming terms.</p>
<p>• It can’t cause any side effects. That is, the function can’t make
any changes that are observable outside the function itself—for example,
by changing an externally accessible mutable object or writing to a
file.</p>
<p>These qualities make it easier for you to reason about your programs
because the functions are completely isolated, unable to impact other
parts of your system. When you use them, you don’t have to ask yourself,
“What could I break by calling this function?” They’re also consistent:
you’ll never need to figure out why passing a function the same
arguments results in different return values, because that will never
happen.</p>
<p>Pure functions are as stable and problem free as arithmetic (when was
the last time you fretted over adding two numbers?). They’re stupendous
little bricks of functionality that you can confidently use as the
foundation of your program. Let’s look at referential transparency and
lack of side effects in more detail to see exactly what they are and how
they’re helpful.</p>
<h4 class="h2" id="text_part0016.html_ch05lev2sec1"><em><strong>Pure
Functions Are Referentially Transparent</strong></em></h4>
<p>To return the same result when called with the same argument, pure
functions rely only on 1) their own arguments and 2) immutable values to
determine their return value. Mathematical functions, for example, are
referentially transparent:</p>
<pre class="programs"><code>(+ 1 2)
; =&gt; 3</code></pre>
<p>If a function relies on an immutable value, it’s referentially
transparent. The string <span class="literal1">", Daniel-san"</span> is
immutable, so the following function is also referentially
transparent:</p>
<pre class="programs"><code>(defn wisdom
  [words]
  (str words &quot;, Daniel-san&quot;))


(wisdom &quot;Always bathe on Fridays&quot;)
; =&gt; &quot;Always bathe on Fridays, Daniel-san&quot;</code></pre>
<p><span id="text_part0016.html_page_99" class="calibre4"></span>By
contrast, the following functions do not yield the same result with the
same arguments; therefore, they are not referentially transparent. Any
function that relies on a random number generator cannot be
referentially transparent:</p>
<pre class="programs"><code>(defn year-end-evaluation
  []
  (if (&gt; (rand) 0.5)
    &quot;You get a raise!&quot;
    &quot;Better luck next year!&quot;))</code></pre>
<p>If your function reads from a file, it’s not referentially
transparent because the file’s contents can change. The following
function, <span class="literal1">analyze-file</span>, is not
referentially transparent, but the function <span
class="literal1">analysis</span> is:</p>
<pre class="programs"><code>(defn analyze-file
  [filename]
  (analysis (slurp filename)))


(defn analysis
  [text]
  (str &quot;Character count: &quot; (count text)))</code></pre>
<p>When using a referentially transparent function, you never have to
consider what possible external conditions could affect the return value
of the function. This is especially important if your function is used
multiple places or if it’s nested deeply in a chain of function calls.
In both cases, you can rest easy knowing that changes to external
conditions won’t cause your code to break.</p>
<p>Another way to think about this is that reality is largely
referentially transparent. If you think of gravity as a function, then
gravitational force is the return value of calling that function on two
objects. Therefore, the next time you’re in a programming interview, you
can demonstrate your functional programming knowledge by knocking
everything off your interviewer’s desk. (This also demonstrates that you
know how to apply a function over a collection.)</p>
<h4 class="h2" id="text_part0016.html_ch05lev2sec2"><em><strong>Pure
Functions Have No Side Effects</strong></em></h4>
<p>To perform a side effect is to change the association between a name
and its value within a given scope. Here is an example in
JavaScript:</p>
<pre class="programs"><code>var haplessObject = {
  emotion: &quot;Carefree!&quot;
};


var evilMutator = function(object){
  object.emotion = &quot;So emo :&#39;(&quot;;
}

evilMutator(haplessObject);
haplessObject.emotion;
// =&gt; &quot;So emo :&#39;(&quot;</code></pre>
<p>Of course, your program has to have some side effects. It writes to a
disk, which changes the association between a filename and a collection
of disk sectors; it changes the RGB values of your monitor’s pixels; and
so on. Otherwise, there’d be no point in running it.</p>
<p>Side effects are potentially harmful, however, because they introduce
uncertainty about what the names in your code are referring to. This
leads to situations where it’s very difficult to trace why and how a
name came to be associated with a value, which makes it hard to debug
the program. When you call a function that doesn’t have side effects,
you only have to consider the relationship between the input and the
output. You don’t have to worry about other changes that could be
rippling through your system.</p>
<p>Functions with side effects, on the other hand, place more of a
burden on your mind grapes: now you have to worry about how the world is
affected when you call the function. Not only that, but every function
that depends on a side-effecting function gets infected by this worry;
it, too, becomes another component that requires extra care and thought
as you build your program.</p>
<p>If you have any significant experience with a language like Ruby or
JavaScript, you’ve probably run into this problem. As an object gets
passed around, its attributes somehow change, and you can’t figure out
why. Then you have to buy a new computer because you’ve chucked yours
out the window. If you’ve read anything about object-oriented design,
you know that a lot of writing has been devoted to strategies for
managing state and reducing side effects for just this reason.</p>
<p>For all these reasons, it’s a good idea to look for ways to limit the
use of side effects in your code. Lucky for you, Clojure makes your job
easier by going to great lengths to limit side effects—all of its core
data structures are immutable. You cannot change them in place, no
matter how hard you try! However, if you’re unfamiliar with immutable
data structures, you might feel like your favorite tool has been taken
from you. How can you <em>do</em> anything without side effects? Well,
that’s what the next section is all about! How about that segue, eh?
Eh?</p>
<h3 class="h2" id="text_part0016.html_ch05lev1sec2"><strong>Living with
Immutable Data Structures</strong></h3>
<p>Immutable data structures ensure that your code won’t have side
effects. As you now know with all your heart, this is a good thing. But
how do you get anything done without side effects?</p>
<h4 class="h2"
id="text_part0016.html_ch05lev2sec3"><em><strong>Recursion Instead of
for/while</strong></em></h4>
<p>Raise your hand if you’ve ever written something like this in
JavaScript:</p>
<pre class="programs"><code>var wrestlers = getAlligatorWrestlers();
var totalBites = 0;

var l = wrestlers.length;


for(var i=0; i &lt; l; i++){
  totalBites += wrestlers[i].timesBitten;
}</code></pre>
<p>Or this:</p>
<pre class="programs"><code>var allPatients = getArkhamPatients();
var analyzedPatients = [];
var l = allPatients.length;


for(var i=0; i &lt; l; i++){
  if(allPatients[i].analyzed){
    analyzedPatients.push(allPatients[i]);
  }
}</code></pre>
<p>Notice that both examples induce side effects on the looping variable
<span class="literal1">i</span>, as well as a variable outside the loop
(<span class="literal1">totalBites</span> in the first example and <span
class="literal1">analyzedPatients</span> in the second). Using side
effects this way—mutating <em>internal</em> variables—is pretty much
harmless. You’re creating new values, as opposed to changing an object
you’ve received from elsewhere in your program.</p>
<p>But Clojure’s core data structures don’t even allow these harmless
mutations. So what can you do instead? First, ignore the fact that you
could easily use <span class="literal1">map</span> and <span
class="literal1">reduce</span> to accomplish the preceding work. In
these situations—iterating over some collection to build a result—the
functional alternative to mutation is recursion.</p>
<div class="image">
<img src="images_00035.jpeg" class="calibre3" alt="image" />
</div>
<p>Let’s look at the first example, building a sum. Clojure has no
assignment operator. You can’t associate a new value with a name without
creating a new scope:</p>
<pre class="programs"><code>(def great-baby-name &quot;Rosanthony&quot;)
great-baby-name
; =&gt; &quot;Rosanthony&quot;


(let [great-baby-name &quot;Bloodthunder&quot;]
  great-baby-name)
; =&gt; &quot;Bloodthunder&quot;


great-baby-name
; =&gt; &quot;Rosanthony&quot;</code></pre>
<p>In this example, you first bind the name <span
class="literal1">great-baby-name</span> to <span
class="literal1">"Rosanthony"</span> within the global scope. Next, you
introduce a new scope with <span class="literal1">let</span>. Within
<span id="text_part0016.html_page_102" class="calibre4"></span>that
scope, you bind <span class="literal1">great-baby-name</span> to <span
class="literal1">"Bloodthunder"</span>. Once Clojure finishes evaluating
the <span class="literal1">let</span> expression, you’re back in the
global scope, and <span class="literal1">great-baby-name</span>
evaluates to <span class="literal1">"Rosanthony"</span> once again.</p>
<p>Clojure lets you work around this apparent limitation with recursion.
The following example shows the general approach to recursive problem
solving:</p>
<pre class="programs"><code>   (defn sum
➊   ([vals] (sum vals 0))
     ([vals accumulating-total]
➋       (if (empty? vals) 
           accumulating-total
           (sum (rest vals) (+ (first vals) accumulating-total)))))</code></pre>
<p>This function takes two arguments, a collection to process (<span
class="literal1">vals</span>) and an accumulator (<span
class="literal1">accumulating-total</span>), and it uses arity
overloading (covered in <a href="#text_part0014.html_ch03"
class="calibre4">Chapter 3</a>) to provide a default value of <span
class="literal1">0</span> for <span
class="literal1">accumulating-total</span> at <span
class="ent">➊</span>.</p>
<p>Like all recursive solutions, this function checks the argument it’s
processing against a base condition. In this case, we check whether
<span class="literal1">vals</span> is empty at <span
class="ent">➋</span>. If it is, we know that we’ve processed all the
elements in the collection, so we return <span
class="literal1">accumulating-total</span>.</p>
<p>If <span class="literal1">vals</span> isn’t empty, it means we’re
still working our way through the sequence, so we recursively call <span
class="literal1">sum</span> passing it two arguments: the <em>tail</em>
of vals with <span class="literal1">(rest vals)</span> and the sum of
the first element of <span class="literal1">vals</span> plus the
accumulating total with <span class="literal1">(+ (first vals)
accumulating-total)</span>. In this way, we build up <span
class="literal1">accumulating-total</span> and at the same time reduce
<span class="literal1">vals</span> until it reaches the base case of an
empty collection.</p>
<p>Here’s what the recursive function call might look like if we
separate out each time it recurs:</p>
<pre class="programs"><code>(sum [39 5 1]) ; single-arity body calls two-arity body
(sum [39 5 1] 0)
(sum [5 1] 39)
(sum [1] 44)
(sum [] 45) ; base case is reached, so return accumulating-total
; =&gt; 45</code></pre>
<p>Each recursive call to <span class="literal1">sum</span> creates a
new scope where <span class="literal1">vals</span> and <span
class="literal1">accumulating-total</span> are bound to different
values, all without needing to alter the values originally passed to the
function or perform any internal mutation. As you can see, you can get
along fine without mutation.</p>
<p>Note that you should generally use <span
class="literal1">recur</span> when doing recursion for performance
reasons. The reason is that Clojure doesn’t provide tail call
optimization, a topic I will never bring up again! (Check out this URL
for more information: <em><a
href="http://en.wikipedia.org/wiki/Tail_call"
class="calibre4">http://en.wikipedia.org/wiki/Tail_call</a></em>.) So
here’s how you’d do this with <span class="literal1">recur</span>:</p>
<pre class="programs"><code>(defn sum
  ([vals]
     (sum vals 0))
  ([vals accumulating-total]

  (if (empty? vals)
    accumulating-total
    (recur (rest vals) (+ (first vals) accumulating-total)))))</code></pre>
<p>Using <span class="literal1">recur</span> isn’t that important if
you’re recursively operating on a small collection, but if your
collection contains thousands or millions values, you will definitely
need to whip out <span class="literal1">recur</span> so you don’t blow
up your program with a stack overflow.</p>
<p>One last thing! You might be saying, “Wait a minute—what if I end up
creating thousands of intermediate values? Doesn’t this cause the
program to thrash because of garbage collection or whatever?”</p>
<p>Very good question, eagle-eyed reader! The answer is no! The reason
is that, behind the scenes, Clojure’s immutable data structures are
implemented using <em>structural sharing</em>, which is totally beyond
the scope of this book. It’s kind of like Git! Read this great article
if you want to know more: <em><a
href="http://hypirion.com/musings/understanding-persistent-vector-pt-1"
class="calibre4">http://hypirion.com/musings/understanding-persistent-vector-pt-1</a></em>.</p>
<h4 class="h2" id="text_part0016.html_ch05lev2sec4"><em><strong>Function
Composition Instead of Attribute Mutation</strong></em></h4>
<p>Another way you might be used to using mutation is to build up the
final state of an object. In the following Ruby example, the <span
class="literal1">GlamourShotCaption</span> object uses mutation to clean
input by removing trailing spaces and capitalizing <span
class="literal1">"lol"</span>:</p>
<pre class="programs"><code>class GlamourShotCaption
  attr_reader :text
  def initialize(text)
    @text = text
    clean!
  end


  private
  def clean!
    text.trim!
    text.gsub!(/lol/, &quot;LOL&quot;)
  end
end


best = GlamourShotCaption.new(&quot;My boa constrictor is so sassy lol!  &quot;)
best.text
; =&gt; &quot;My boa constrictor is so sassy LOL!&quot;</code></pre>
<p>In this code, the class <span
class="literal1">GlamourShotCaption</span> encapsulates the knowledge of
how to clean a glamour shot caption. On creating a <span
class="literal1">GlamourShotCaption</span> object, you assign text to an
instance variable and progressively mutate it.</p>
<p><a href="#text_part0016.html_ch5list1" class="calibre4">Listing
5-1</a> shows how you might do this in Clojure:</p>
<pre class="programs"><code>(require &#39;[clojure.string :as s])
(defn clean
  [text]
  (s/replace (s/trim text) #&quot;lol&quot; &quot;LOL&quot;))
(clean &quot;My boa constrictor is so sassy lol!  &quot;)
; =&gt; &quot;My boa constrictor is so sassy LOL!&quot;</code></pre>
<p><span id="text_part0016.html_ch5list1"
class="calibre4"></span><em>Listing 5-1: Using function composition to
modify a glamour shot caption</em></p>
<p>In the first line, we use <span class="literal1">require</span> to
access the string function library (I’ll discuss this function and
related concepts in <a href="#text_part0017.html_ch06"
class="calibre4">Chapter 6</a>). Otherwise, the code is easy peasy. No
mutation required. Instead of progressively mutating an object, the
<span class="literal1">clean</span> function works by passing an
immutable value, <span class="literal1">text</span>, to a pure function,
<span class="literal1">s/trim</span>, which returns an immutable value
(<span class="literal1">"My boa constrictor is so sassy lol!"</span>;
the spaces at the end of the string have been trimmed). That value is
then passed to the pure function <span
class="literal1">s/replace</span>, which returns another immutable value
(<span class="literal1">"My boa constrictor is so sassy
LOL!"</span>).</p>
<div class="image">
<img src="images_00036.jpeg" class="calibre3" alt="image" />
</div>
<p>Combining functions like this—so that the return value of one
function is passed as an argument to another—is called <em>function
composition</em>. In fact, this isn’t so different from the previous
example, which used recursion, because recursion continually passes the
result of a function to another function; it just happens to be the same
function. In general, functional programming encourages you to build
more complex functions by combining simpler functions.</p>
<p>This comparison also starts to reveal some limitations of
object-oriented programming (OOP). In OOP, one of the main purposes of
classes is to protect against unwanted modification of private
data—something that isn’t necessary with immutable data structures. You
also have to tightly couple methods with classes, thus limiting the
reusability of the methods. In the Ruby example, you have to do extra
work to reuse the <span class="literal1">clean!</span> method. In
Clojure, <span class="literal1">clean</span> will work on any string at
all. By both a) decoupling functions and data, and b) programming to a
small set of abstractions, you end up with more reusable, composable
code. You gain power and lose nothing.</p>
<p>Going beyond immediately practical concerns, the differences between
the way you write object-oriented and functional code point to a deeper
difference between the two mindsets. Programming is about manipulating
data for your own nefarious purposes (as much as you can say it’s
<em>about</em> anything). In OOP, you think about data as something you
can embody in an object, and you poke and prod it until it looks right.
During this process, your original data is lost forever unless you’re
very careful about preserving it. By contrast, in functional programming
you think of data as unchanging, and you derive new data from existing
data. During this process, the original data remains safe and sound. In
the preceding Clojure example, <span id="text_part0016.html_page_105"
class="calibre4"></span>the original caption doesn’t get modified. It’s
safe in the same way that numbers are safe when you add them together;
you don’t somehow transform 4 into 7 when you add 3 to it.</p>
<p>Once you are confident using immutable data structures to get stuff
done, you’ll feel even more confident because you won’t have to worry
about what dirty code might be getting its greasy paws on your precious,
mutable variables. It’ll be great!</p>
<h3 class="h2" id="text_part0016.html_ch05lev1sec3"><strong>Cool Things
to Do with Pure Functions</strong></h3>
<p>You can derive new functions from existing functions in the same way
that you derive new data from existing data. You’ve already seen one
function, <span class="literal1">partial</span>, that creates new
functions. This section introduces you to two more functions, <span
class="literal1">comp</span> and <span class="literal1">memoize</span>,
which rely on referential transparency, immutability, or both.</p>
<h4 class="h2"
id="text_part0016.html_ch05lev2sec5"><em><strong>comp</strong></em></h4>
<p>It’s always safe to compose pure functions like we just did in the
previous section, because you only need to worry about their
input/output relationship. Composing functions is so common that Clojure
provides a function, <span class="literal1">comp</span>, for creating a
new function from the composition of any number of functions. Here’s a
simple example:</p>
<pre class="programs"><code>((comp inc *) 2 3)
; =&gt; 7</code></pre>
<p>Here, you create an anonymous function by composing the <span
class="literal1">inc</span> and <span class="literal1">*</span>
functions. Then, you immediately apply this function to the arguments
<span class="literal1">2</span> and <span class="literal1">3</span>. The
function multiplies the numbers 2 and 3 and then increments the result.
Using math notation, you’d say that, in general, using <span
class="literal1">comp</span> on the functions <em>f</em><sub>1</sub>,
<em>f</em><sub>2</sub>, ... <em>f<sub>n</sub></em>, creates a new
function <em>g</em> such that <em>g</em>(<em>x</em><sub>1</sub>,
<em>x</em><sub>2</sub>, ... <em>x<sub>n</sub></em>) equals
<em>f</em><sub>1</sub>(<em>f</em><sub>2</sub>(<em>f<sub>n</sub></em>(<em>x</em><sub>1</sub>,
<em>x</em><sub>2</sub>, ... <em>x<sub>n</sub></em>))). One detail to
note here is that the first function applied—<span
class="literal1">*</span> in the code shown here—can take any number of
arguments, whereas the remaining functions must be able to take only one
argument.</p>
<p>Here’s an example that shows how you could use <span
class="literal1">comp</span> to retrieve character attributes in
role-playing games:</p>
<pre class="programs"><code>(def character
  {:name &quot;Smooches McCutes&quot;
   :attributes {:intelligence 10
                :strength 4
                :dexterity 5}})
(def c-int (comp :intelligence :attributes))
(def c-str (comp :strength :attributes))
(def c-dex (comp :dexterity :attributes))


(c-int character)
; =&gt; 10
(c-str character)
; =&gt; 4


(c-dex character)
; =&gt; 5</code></pre>
<p>In this example, you created three functions that help you look up a
character’s attributes. Instead of using <span
class="literal1">comp</span>, you could just have written something like
this for each attribute:</p>
<pre class="programs"><code>(fn [c] (:strength (:attributes c)))</code></pre>
<p>But <span class="literal1">comp</span> is more elegant because it
uses less code to convey more meaning. When you see <span
class="literal1">comp</span>, you immediately know that the resulting
function’s purpose is to combine existing functions in a well-known
way.</p>
<p>What do you do if one of the functions you want to compose needs to
take more than one argument? You wrap it in an anonymous function. Have
a look at this next snippet, which calculates the number of spell slots
your character has based on her intelligence attribute:</p>
<pre class="programs"><code>(defn spell-slots
  [char]
  (int (inc (/ (c-int char) 2))))


(spell-slots character)
; =&gt; 6</code></pre>
<p>First, you divide intelligence by two, then you add one, and then you
use the <span class="literal1">int</span> function to round down. Here’s
how you could do the same thing with <span
class="literal1">comp</span>:</p>
<pre class="programs"><code>(def spell-slots-comp (comp int inc #(/ % 2) c-int))</code></pre>
<p>To divide by two, all you needed to do was wrap the division in an
anonymous function.</p>
<p>Clojure’s <span class="literal1">comp</span> function can compose any
number of functions. To get a hint of how it does this, here’s an
implementation that composes just two functions:</p>
<pre class="programs"><code>(defn two-comp
  [f g]
  (fn [&amp; args]
    (f (apply g args))))</code></pre>
<p>I encourage you to evaluate this code and use <span
class="literal1">two-comp</span> to compose two functions! Also, try
reimplementing Clojure’s <span class="literal1">comp</span> function so
you can compose any number of functions.</p>
<h4 class="h2" id="text_part0016.html_ch05lev2sec6"><span
id="text_part0016.html_page_107"
class="calibre1"></span><em><strong>memoize</strong></em></h4>
<p>Another cool thing you can do with pure functions is memoize them so
that Clojure remembers the result of a particular function call. You can
do this because, as you learned earlier, pure functions are
referentially transparent. For example, <span class="literal1">+</span>
is referentially transparent. You can replace</p>
<pre class="programs"><code>(+ 3 (+ 5 8))</code></pre>
<p>with</p>
<pre class="programs"><code>(+ 3 13)</code></pre>
<p>or</p>
<pre class="programs"><code>16</code></pre>
<p>and the program will have the same behavior.</p>
<p>Memoization lets you take advantage of referential transparency by
storing the arguments passed to a function and the return value of the
function. That way, subsequent calls to the function with the same
arguments can return the result immediately. This is especially useful
for functions that take a lot of time to run. For example, in this
unmemoized function, the result is returned after one second:</p>
<pre class="programs"><code>(defn sleepy-identity
  &quot;Returns the given value after 1 second&quot;
  [x]
  (Thread/sleep 1000)
  x)
(sleepy-identity &quot;Mr. Fantastico&quot;)
; =&gt; &quot;Mr. Fantastico&quot; after 1 second


(sleepy-identity &quot;Mr. Fantastico&quot;)
; =&gt; &quot;Mr. Fantastico&quot; after 1 second</code></pre>
<p>However, if you create a new, memoized version of <span
class="literal1">sleepy-identity</span> with <span
class="literal1">memoize</span>, only the first call waits one second;
every subsequent function call returns immediately:</p>
<pre class="programs"><code>(def memo-sleepy-identity (memoize sleepy-identity))
(memo-sleepy-identity &quot;Mr. Fantastico&quot;)
; =&gt; &quot;Mr. Fantastico&quot; after 1 second


(memo-sleepy-identity &quot;Mr. Fantastico&quot;)
; =&gt; &quot;Mr. Fantastico&quot; immediately</code></pre>
<p>Pretty cool! From here on out, <span
class="literal1">memo-sleepy-identity</span> will not incur the initial
one-second cost when called with <span class="literal1">"Mr.
Fantastico"</span>. This implementation could be useful for functions
that are computationally intensive or that make network requests.</p>
<h3 class="h2" id="text_part0016.html_ch05lev1sec4"><span
id="text_part0016.html_page_108" class="calibre1"></span><strong>Peg
Thing</strong></h3>
<p>It’s that time! Time to build a terminal implementation of Peg Thing
using everything you’ve learned so far: immutable data structures, lazy
sequences, pure functions, recursion—everything! Doing this will help
you understand how to combine these concepts and techniques to solve
larger problems. Most important, you’ll learn how to model the changes
that result from each move a player makes without having to mutate
objects like you would in OOP.</p>
<p>To build the game, you’ll first learn the game’s mechanics and how to
start and play the program. Then, I’ll explain the code’s organization.
Finally, I’ll walk through each function.</p>
<p>You can find the complete code repository for Peg Thing at <em><a
href="https://www.nostarch.com/clojure/"
class="calibre4">https://www.nostarch.com/clojure/</a></em>.</p>
<h4 class="h2"
id="text_part0016.html_ch05lev2sec7"><em><strong>Playing</strong></em></h4>
<p>As mentioned earlier, Peg Thing is based on the secret
mind-sharpening tool passed down from ye olden days and is now
distributed by Cracker Barrel.</p>
<p>If you’re not familiar with the game, here are the mechanics. You
start out with a triangular board consisting of holes filled with pegs,
and one hole has a missing a peg, as shown in <a
href="#text_part0016.html_ch5fig1" class="calibre4">Figure 5-1</a>.</p>
<div class="image">
<img src="images_00037.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0016.html_ch5fig1"
class="calibre4"></span><em>Figure 5-1: The initial setup for Peg
Thing</em></p>
<p>The object of the game is to remove as many pegs as possible. You do
this by <em>jumping</em> over pegs. In <a
href="#text_part0016.html_ch5fig2" class="calibre4">Figure 5-2</a>, peg
A jumps over peg B into the empty hole, and you remove peg B from the
board.</p>
<div class="image">
<span id="text_part0016.html_page_109" class="calibre4"></span><img
src="images_00038.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0016.html_ch5fig2"
class="calibre4"></span><em>Figure 5-2: Jump a peg to remove it from the
board.</em></p>
<p>To start Peg Thing, download the code, and then run <span
class="literal1">lein run</span> in your terminal while in the
<em>pegthing</em> directory. A prompt appears that looks like this:</p>
<pre class="programs"><code>Get ready to play Peg Thing!
How many rows? [5]</code></pre>
<p>Now you can enter the number of rows the board will have, using <span
class="literal1">5</span> as the default. If you want five rows, just
press <span class="small">ENTER</span> (otherwise, type a number and
press <span class="small">ENTER</span>). You’ll then see this:</p>
<pre class="programs"><code>Here&#39;s your board:
       a0
      b0 c0
    d0 e0 f0
   g0 h0 i0 j0
 k0 l0 m0 n0 o0
Remove which peg? [e]</code></pre>
<p>Each letter identifies a position on the board. The number <span
class="literal1">0</span> (which should be blue, but if it’s not, it’s
no big deal) indicates that a position is filled. Before gameplay
begins, one peg must be empty, so the prompt asks you to enter the
position of the first to peg to remove. The default is the center peg,
<span class="literal1">e</span>, but you can choose a different one.
After you remove the peg, you’ll see this:</p>
<pre class="programs"><code>Here&#39;s your board:
       a0
      b0 c0
    d0 e- f0
   g0 h0 i0 j0
 k0 l0 m0 n0 o0
Move from where to where? Enter two letters:</code></pre>
<p>Notice that the <span class="literal1">e</span> position now has a
dash, <span class="literal1">-</span> (which should be red, but if it’s
not, it’s no big deal). The dash indicates that the position is empty.
To <span id="text_part0016.html_page_110" class="calibre4"></span>move,
you enter the position of the peg you want to <em>pick up</em> followed
by the position of the empty position that you want to place it in. If
you enter <span class="literal1">le</span>, for example, you’ll get
this:</p>
<pre class="programs"><code>Here&#39;s your board:
       a0
      b0 c0
    d0 e0 f0
   g0 h- i0 j0
 k0 l- m0 n0 o0
Move from where to where? Enter two letters:</code></pre>
<p>You’ve moved the peg from <span class="literal1">l</span> to <span
class="literal1">e</span>, jumping over <span class="literal1">h</span>
and removing its peg according to the rule shown in <a
href="#text_part0016.html_ch5fig2" class="calibre4">Figure 5-2</a>. The
game continues to prompt you for moves until no moves are available,
whereupon it prompts you to play again.</p>
<h4 class="h2" id="text_part0016.html_ch05lev2sec8"><em><strong>Code
Organization</strong></em></h4>
<p>The program has to handle four major tasks, and the source code is
organized accordingly, with the functions for each of these tasks
grouped together:</p>
<p>1. Creating a new board</p>
<p>2. Returning a board with the result of the player’s move</p>
<p>3. Representing a board textually</p>
<p>4. Handling user interaction</p>
<p>Two more points about the organization: First, the code has a basic
<em>architecture</em>, or conceptual organization, of two layers. The
top layer consists of the functions for handling user interaction. These
functions produce all of the program’s side effects, printing out the
board and presenting prompts for player interaction. The functions in
this layer use the functions in the bottom layer to create a new board,
make moves, and create a textual representation, but the functions in
the bottom layer don’t use those in the top layer at all. Even for a
program this small, a little architecture helps make the code more
manageable.</p>
<p>Second, I’ve tried as much as possible to decompose tasks into small
functions so that each does one tiny, understandable task. Some of these
functions are used by only one other function. I find this helpful
because it lets me name each tiny subtask, allowing me to better express
the intention of the code.</p>
<p>But before all the architecture, there’s this:</p>
<pre class="programs"><code>(ns pegthing.core
  (require [clojure.set :as set])
  (:gen-class))


(declare successful-move prompt-move game-over query-rows)</code></pre>
<p><span id="text_part0016.html_page_111" class="calibre4"></span>I’ll
explain the functions here in more detail in <a
href="#text_part0017.html_ch06" class="calibre4">Chapter 6</a>. If
you’re curious about what’s going on, the short explanation is that
<span class="literal1">(require [clojure.set :as set])</span> allows you
to easily use functions in the <span class="literal1">clojure.set</span>
namespace, <span class="literal1">(:gen-class)</span> allows you to run
the program from the command line, and <span class="literal1">(declare
successful-move prompt-move game-over query-rows)</span> allows
functions to refer to those names before they’re defined. If that
doesn’t quite make sense yet, trust that I will explain it soon.</p>
<h4 class="h2" id="text_part0016.html_ch05lev2sec9"><em><strong>Creating
the Board</strong></em></h4>
<p>The data structure you use to represent the board should make it easy
for you to print the board, check whether a player has made a valid
move, actually perform a move, and check whether the game is over. You
could structure the board in many ways to allow these tasks. In this
case, you’ll represent the board using a map with numerical keys
corresponding to each board position and values containing information
about that position’s connections. The map will also contain a <span
class="literal1">:rows</span> key, storing the total number of rows. <a
href="#text_part0016.html_ch5fig3" class="calibre4">Figure 5-3</a> shows
a board with each position numbered.</p>
<div class="image">
<img src="images_00039.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0016.html_ch5fig3"
class="calibre4"></span><em>Figure 5-3: The numbered pegboard</em></p>
<p>Here’s the data structure built to represent it:</p>
<pre class="programs"><code>{1  {:pegged true, :connections {6 3, 4 2}},
 2  {:pegged true, :connections {9 5, 7 4}},
 3  {:pegged true, :connections {10 6, 8 5}},
 4  {:pegged true, :connections {13 8, 11 7, 6 5, 1 2}},
 5  {:pegged true, :connections {14 9, 12 8}},
 6  {:pegged true, :connections {15 10, 13 9, 4 5, 1 3}},
 7  {:pegged true, :connections {9 8, 2 4}},
 8  {:pegged true, :connections {10 9, 3 5}},
 9  {:pegged true, :connections {7 8, 2 5}},
 10 {:pegged true, :connections {8 9, 3 6}},
 11 {:pegged true, :connections {13 12, 4 7}},
 12 {:pegged true, :connections {14 13, 5 8}},
 13 {:pegged true, :connections {15 14, 11 12, 6 9, 4 8}},
 14 {:pegged true, :connections {12 13, 5 9}},
 15 {:pegged true, :connections {13 14, 6 10}},
 :rows 5}</code></pre>
<p><span id="text_part0016.html_page_112" class="calibre4"></span>You
might be wondering why, when you play the game, each position is
represented by a letter but here the positions are represented by
numbers. Using numbers for the internal representation allows you to
take advantage of some mathematical properties of the board layout when
validating and making moves. Letters, on the other hand, are better for
display because they take up only one character space. Some conversion
functions are covered in “<a href="#text_part0016.html_ch05lev2sec11"
class="calibre4">Rendering and Printing the Board</a>” on <a
href="#text_part0016.html_page_120" class="calibre4">page 120</a>.</p>
<p>In the data structure, each position is associated with a map that
reads something like this:</p>
<pre class="programs"><code>{:pegged true, :connections {6 3, 4 2}}</code></pre>
<p>The meaning of <span class="literal1">:pegged</span> is clear; it
represents whether that position has a peg in it. <span
class="literal1">:connections</span> is a bit more cryptic. It’s a map
where each key identifies a <em>legal destination</em>, and each value
represents <em>the position that would be jumped over</em>. So pegs in
position 1, for example, can jump <em>to</em> position 6 <em>over</em>
position 3. This might seem backward, but you’ll learn the rationale for
it later when you see how move validation is implemented.</p>
<p>Now that you’ve seen what the final map representing the board should
look like, we can start exploring the functions that actually build up
this map in the program. You won’t simply start assigning mutable states
willy-nilly to represent each position and whether it’s pegged or not.
Instead, you’ll use nested recursive function calls to build up the
final board position by position. It’s analogous to the way you created
the glamour shot caption earlier, deriving new data from input by
passing an argument through a chain of functions to get your final
result.</p>
<p>The first few expressions in this section of the code deal with
triangular numbers. Triangular numbers are generated by adding the first
<em>n</em> natural numbers. The first triangular number is 1, the second
is 3 (1 + 2), the third is 6 (1 + 2 + 3), and so on. These numbers line
up nicely with the position numbers at the end of every row on the
board, which will turn out to be a very useful property. First, you
define the function <span class="literal1">tri*</span>, which can create
a lazy sequence of triangular numbers:</p>
<pre class="programs"><code>(defn tri*
  &quot;Generates lazy sequence of triangular numbers&quot;
  ([] (tri* 0 1))
  ([sum n]
     (let [new-sum (+ sum n)]
       (cons new-sum (lazy-seq (tri* new-sum (inc n)))))))</code></pre>
<p>To quickly recap how this works, calling <span
class="literal1">tri*</span> with no arguments will recursively call
<span class="literal1">(tri* 0 1)</span>. This returns a lazy list whose
element is <span class="literal1">new-sum</span>, which in this case
evaluates to <span class="literal1">1</span>. The lazy list includes a
recipe for generating the next element of the list when it’s requested,
as described in <a href="#text_part0015.html_ch04"
class="calibre4">Chapter 4</a>.</p>
<p><span id="text_part0016.html_page_113" class="calibre4"></span>The
next expression calls <span class="literal1">tri*</span>, actually
creating the lazy sequence and binding it to <span
class="literal1">tri</span>:</p>
<pre class="programs"><code>(def tri (tri*))</code></pre>
<p>You can verify that it actually works:</p>
<pre class="programs"><code>(take 5 tri)
; =&gt; (1 3 6 10 15)</code></pre>
<p>And the next few functions operate on the sequence of triangular
numbers. <span class="literal1">triangular?</span> figures out if its
argument is in the <span class="literal1">tri</span> lazy sequence. It
works by using <span class="literal1">take-while</span> to create a
sequence of triangular numbers whose last element is a triangular number
that’s less than or equal to the argument. Then it compares the last
element to the argument:</p>
<pre class="programs"><code>(defn triangular?
  &quot;Is the number triangular? e.g. 1, 3, 6, 10, 15, etc&quot;
  [n]
  (= n (last (take-while #(&gt;= n %) tri))))
(triangular? 5)
; =&gt; false


(triangular? 6)
; =&gt; true</code></pre>
<p>Next, there’s <span class="literal1">row-tri</span>, which takes a
row number and gives you the triangular number at the end of that
row:</p>
<pre class="programs"><code>(defn row-tri
  &quot;The triangular number at the end of row n&quot;
  [n]
  (last (take n tri)))
(row-tri 1)
; =&gt; 1


(row-tri 2)
; =&gt; 3


(row-tri 3)
; =&gt; 6</code></pre>
<p>Lastly, there’s <span class="literal1">row-num</span>, which takes a
board position and returns the row that it belongs to:</p>
<pre class="programs"><code>(defn row-num
  &quot;Returns row number the position belongs to: pos 1 in row 1,
  positions 2 and 3 in row 2, etc&quot;
  [pos]
  (inc (count (take-while #(&gt; pos %) tri))))
(row-num 1)
; =&gt; 1
(row-num 5)
; =&gt; 3</code></pre>
<p>After that comes <span class="literal1">connect</span>, which is used
to actually form a mutual connection between two positions:</p>
<pre class="programs"><code>(defn connect
  &quot;Form a mutual connection between two positions&quot;
  [board max-pos pos neighbor destination]
  (if (&lt;= destination max-pos)
    (reduce (fn [new-board [p1 p2]]
              (assoc-in new-board [p1 :connections p2] neighbor))
            board
            [[pos destination] [destination pos]])
    board))


(connect {} 15 1 2 4)
; =&gt; {1 {:connections {4 2}}
      4 {:connections {1 2}}}</code></pre>
<p>The first thing <span class="literal1">connect</span> does is check
whether the destination is actually a position on the board by
confirming that it’s less than the board’s max position. For example, if
you have five rows, the max position is 15. However, when the game board
is created, the <span class="literal1">connect</span> function will be
called with arguments like <span class="literal1">(connect {} 15 7 16
22)</span>. The <span class="literal1">if</span> statement at the
beginning of <span class="literal1">connect</span> makes sure your
program doesn’t allow such outrageous connections, and simply returns
the unmodified board when you ask it to do something silly.</p>
<p>Next, <span class="literal1">connect</span> uses recursion through
<span class="literal1">reduce</span> to progressively build up the final
state of the board. In this example, you’re reducing over the nested
vectors <span class="literal1">[[1 4] [4 1]]</span>. This is what allows
you to return an updated board with both <span
class="literal1">pos</span> and <span
class="literal1">destination</span> (1 and 4) pointing to each other in
their connections.</p>
<p>The anonymous function passed to <span class="literal1">reduce</span>
uses a function, <span class="literal1">assoc-in</span>, which you
haven’t seen before. Whereas the function <span
class="literal1">get-in</span> lets you look up values in nested maps,
<span class="literal1">assoc-in</span> lets you return a new map with
the given value at the specified nesting. Here are a couple of
examples:</p>
<pre class="programs"><code>(assoc-in {} [:cookie :monster :vocals] &quot;Finntroll&quot;)
; =&gt; {:cookie {:monster {:vocals &quot;Finntroll&quot;}}}


(get-in {:cookie {:monster {:vocals &quot;Finntroll&quot;}}} [:cookie :monster])
; =&gt; {:vocals &quot;Finntroll&quot;}


(assoc-in {} [1 :connections 4] 2)
; =&gt; {1 {:connections {4 2}}}</code></pre>
<p>In these examples, you can see that new, nested maps are created to
accommodate all the keys provided.</p>
<p><span id="text_part0016.html_page_115" class="calibre4"></span>Now we
have a way to connect two positions, but how should the program choose
two positions to connect in the first place? That’s handled by <span
class="literal1">connect-right</span>, <span
class="literal1">connect-down-left</span>, and <span
class="literal1">connect-down-right</span>:</p>
<pre class="programs"><code>(defn connect-right
  [board max-pos pos]
  (let [neighbor (inc pos)
        destination (inc neighbor)]
    (if-not (or (triangular? neighbor) (triangular? pos))
      (connect board max-pos pos neighbor destination)
      board)))


(defn connect-down-left
  [board max-pos pos]
  (let [row (row-num pos)
        neighbor (+ row pos)
        destination (+ 1 row neighbor)]
    (connect board max-pos pos neighbor destination)))


(defn connect-down-right
  [board max-pos pos]
  (let [row (row-num pos)
        neighbor (+ 1 row pos)
        destination (+ 2 row neighbor)]
    (connect board max-pos pos neighbor destination)))</code></pre>
<p>These functions each take the board’s max position and a board
position and use a little triangle math to figure out which numbers to
feed to <span class="literal1">connect</span>. For example, <span
class="literal1">connect-down-left</span> will attempt to connect
position 1 to position 4. In case you’re wondering why the functions
<span class="literal1">connect-left</span>, <span
class="literal1">connect-up-left</span>, and <span
class="literal1">connect-up-right</span> aren’t defined, the reason is
that the existing functions actually cover these cases. <span
class="literal1">connect</span> returns a board with the mutual
connection established; when 4 <em>connects right</em> to 6, 6
<em>connects left</em> to 4. Here are a couple of examples:</p>
<pre class="programs"><code>(connect-down-left {} 15 1)
; =&gt; {1 {:connections {4 2}
      4 {:connections {1 2}}}}


(connect-down-right {} 15 3)
; =&gt; {3  {:connections {10 6}}
      10 {:connections {3 6}}}</code></pre>
<p>In the first example, <span class="literal1">connect-down-left</span>
takes an empty board with a max position of 15 and returns a new board
populated with the mutual connection between the 1 position and the
position below and to the left of it. <span
class="literal1">connect-down-right</span> does something similar,
returning a board populated with the mutual connection between 3 and the
position below it and to its right.</p>
<p><span id="text_part0016.html_page_116" class="calibre4"></span>The
next function, <span class="literal1">add-pos</span>, is interesting
because it actually reduces on a vector of <em>functions</em>, applying
each in turn to build up the resulting board. But first it updates the
board to indicate that a peg is in the given position:</p>
<pre class="programs"><code>(defn add-pos
  &quot;Pegs the position and performs connections&quot;
  [board max-pos pos]
  (let [pegged-board (assoc-in board [pos :pegged] true)]
    (reduce (fn [new-board connection-creation-fn]
              (connection-creation-fn new-board max-pos pos))
            pegged-board
            [connect-right connect-down-left connect-down-right])))


(add-pos {} 15 1)
{1 {:connections {6 3, 4 2}, :pegged true}
 4 {:connections {1 2}}
 6 {:connections {1 3}}}</code></pre>
<p>It’s like this function is first saying, in the <span
class="literal1">pegged-board</span> binding, “Add a peg to the board at
position X.” Then, in <span class="literal1">reduce</span>, it says,
“Take the board with its new peg at position X, and try to connect
position X to a legal, rightward position. Take the board that results
from that operation, and try to connect position X to a legal, down-left
position. Finally, take the board that results from <em>that</em>
operation, and try to connect position X to a legal, down-right
position. Return the resulting board.”</p>
<p>Reducing over functions like this is another way of composing
functions. To illustrate, here’s another way of defining the <span
class="literal1">clean</span> function in <a
href="#text_part0016.html_ch5list1" class="calibre4">Listing 5-1</a> (<a
href="#text_part0016.html_page_103" class="calibre4">page 103</a>):</p>
<pre class="programs"><code>(defn clean
  [text]
  (reduce (fn [string string-fn] (string-fn string))
          text
          [s/trim #(s/replace % #&quot;lol&quot; &quot;LOL&quot;)]))</code></pre>
<p>This redefinition of <span class="literal1">clean</span> reduces a
vector of functions by applying the first function, <span
class="literal1">s/trim</span>, to an initial string, then applying the
next function, the anonymous function <span class="literal1">#(s/replace
% #"lol" "LOL")</span>, to the result.</p>
<p>Reducing over a collection of functions is not a technique you’ll use
often, but it’s occasionally useful, and it demonstrates the versatility
of functional programming.</p>
<p>Last among our board creation functions is <span
class="literal1">new-board</span>:</p>
<pre class="programs"><code>(defn new-board
  &quot;Creates a new board with the given number of rows&quot;
  [rows]
  (let [initial-board {:rows rows}
        max-pos (row-tri rows)]
    (reduce (fn [board pos] (add-pos board max-pos pos))
            initial-board
            (range 1 (inc max-pos)))))</code></pre>
<p><span id="text_part0016.html_page_117" class="calibre4"></span>The
code first creates the initial, empty board and gets the max position.
Assuming that you’re using five rows, the max position will be 15. Next,
the function uses <span class="literal1">(range 1 (inc max-pos))</span>
to get a list of numbers from 1 to 15, otherwise known as the board’s
positions. Finally, it reduces over the list of positions. Each
iteration of the reduction calls <span class="literal1">(add-pos board
max-pos pos)</span>, which, as you saw earlier, takes an existing board
and returns a new one with the position added.</p>
<h4 class="h2" id="text_part0016.html_ch05lev2sec10"><em><strong>Moving
Pegs</strong></em></h4>
<p>The next section of code validates and performs peg moves. Many of
the functions (<span class="literal1">pegged?</span>, <span
class="literal1">remove-peg</span>, <span
class="literal1">place-peg</span>, <span
class="literal1">move-peg</span>) are simple, self-explanatory
one-liners:</p>
<pre class="programs"><code>(defn pegged?
  &quot;Does the position have a peg in it?&quot;
  [board pos]
  (get-in board [pos :pegged]))


(defn remove-peg
  &quot;Take the peg at given position out of the board&quot;
  [board pos]
  (assoc-in board [pos :pegged] false))


(defn place-peg
  &quot;Put a peg in the board at given position&quot;
  [board pos]
  (assoc-in board [pos :pegged] true))


(defn move-peg
  &quot;Take peg out of p1 and place it in p2&quot;
  [board p1 p2]
  (place-peg (remove-peg board p1) p2))</code></pre>
<p>Let’s take a moment to appreciate how neat this code is. This is
where you would usually perform mutation in an object-oriented program;
after all, how else would you change the board? However, these are all
pure functions, and they do the job admirably. I also like that you
don’t need the overhead of classes to use these little guys. It feels
somehow lighter to program like this.</p>
<p>Next up is <span class="literal1">valid-moves</span>:</p>
<pre class="programs"><code>(defn valid-moves
  &quot;Return a map of all valid moves for pos, where the key is the
  destination and the value is the jumped position&quot;
  [board pos]
  (into {}
        (filter (fn [[destination jumped]]
                  (and (not (pegged? board destination))
                       (pegged? board jumped)))
                (get-in board [pos :connections]))))</code></pre>
<p><span id="text_part0016.html_page_118" class="calibre4"></span>This
code goes through each of the given position’s connections and tests
whether the destination position is empty and the jumped position has a
peg. To see this in action, you can create a board with the 4 position
empty:</p>
<pre class="programs"><code>(def my-board (assoc-in (new-board 5) [4 :pegged] false))</code></pre>
<p><a href="#text_part0016.html_ch5fig4" class="calibre4">Figure 5-4</a>
shows what that board would look like.</p>
<div class="image">
<img src="images_00040.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0016.html_ch5fig4"
class="calibre4"></span><em>Figure 5-4: A pegboard with the 4 position
empty</em></p>
<p>Given this board, positions 1, 6, and 11 have valid moves, but all
others don’t:</p>
<pre class="programs"><code>(valid-moves my-board 1)  ; =&gt; {4 2}
(valid-moves my-board 6)  ; =&gt; {4 5}
(valid-moves my-board 11) ; =&gt; {4 7}
(valid-moves my-board 5)  ; =&gt; {}
(valid-moves my-board 8)  ; =&gt; {}</code></pre>
<p>You might be wondering why <span class="literal1">valid-moves</span>
returns a map instead of, say, a set or vector. The reason is that
returning a map allows you to easily look up a destination position to
check whether a specific move is valid, which is what <span
class="literal1">valid-move?</span> (the next function) does:</p>
<pre class="programs"><code>(defn valid-move?
  &quot;Return jumped position if the move from p1 to p2 is valid, nil
  otherwise&quot;
  [board p1 p2]
  (get (valid-moves board p1) p2))


(valid-move? my-board 8 4) ; =&gt; nil
(valid-move? my-board 1 4) ; =&gt; 2</code></pre>
<p>Notice that <span class="literal1">valid-move?</span> looks up the
destination position from the map and then returns the position of the
peg that would be jumped over. This is another nice benefit of having
<span class="literal1">valid-moves</span> return a map, because the
<span id="text_part0016.html_page_119" class="calibre4"></span>jumped
position retrieved from the map is exactly what we want to pass on to
the next function, <span class="literal1">make-move</span>. When you
take the time to construct a rich data structure, it’s easier to perform
useful operations.</p>
<pre class="programs"><code>(defn make-move
  &quot;Move peg from p1 to p2, removing jumped peg&quot;
  [board p1 p2]
  (if-let [jumped (valid-move? board p1 p2)]
    (move-peg (remove-peg board jumped) p1 p2)))</code></pre>
<p><span class="literal1">if-let</span> is a nifty way to say, “If an
expression evaluates to a truthy value, then bind that value to a name
the same way that I can in a <span class="literal1">let</span>
expression. Otherwise, if I’ve provided an <span
class="literal1">else</span> clause, perform that <span
class="literal1">else</span> clause; if I haven’t provided an <span
class="literal1">else</span> clause, return <span
class="literal1">nil</span>.” In this case, the test expression is <span
class="literal1">(valid-move? board p1 p2)</span>, and you’re assigning
the result to the name <span class="literal1">jumped</span> if the
result is truthy. That’s used in the call to <span
class="literal1">move-peg</span>, which returns a new board. You don’t
supply an <span class="literal1">else</span> clause, so if the move
isn’t valid, the return value of the whole expression is <span
class="literal1">nil</span>.</p>
<p>Finally, the function <span class="literal1">can-move?</span> is used
to determine whether the game is over by finding the first pegged
positions with moves available:</p>
<pre class="programs"><code>(defn can-move?
  &quot;Do any of the pegged positions have valid moves?&quot;
  [board]
  (some (comp not-empty (partial valid-moves board))
        (map first (filter #(get (second %) :pegged) board))))</code></pre>
<p>The question mark at the end of this function name indicates it’s a
<em>predicate function</em>, a function that’s meant to be used in
Boolean expressions. <em>Predicate</em> is taken from predicate logic,
which concerns itself with determining whether a statement is true or
false. (You’ve already seen some built-in predicate functions, like
<span class="literal1">empty?</span> and <span
class="literal1">every?</span>.)</p>
<p><span class="literal1">can-move?</span> works by getting a sequence
of all pegged positions with <span class="literal1">(map first (filter
#(get (second %) :pegged) board))</span>. You can break this down
further into the <span class="literal1">filter</span> and <span
class="literal1">map</span> function calls: because <span
class="literal1">filter</span> is a seq function, it converts <span
class="literal1">board</span>, a map, into a seq of two-element vectors
(also called <em>tuples</em>), which looks something like this:</p>
<pre class="programs"><code>([1 {:connections {6 3, 4 2}, :pegged true}]
 [2 {:connections {9 5, 7 4}, :pegged true}])</code></pre>
<p>The first element of the tuple is a position number, and the second
is that position’s information. <span class="literal1">filter</span>
then applies the anonymous function <span class="literal1">#(get (second
%) :pegged)</span> to each of these tuples, filtering out the tuples
where the position’s information indicates that the position is not
currently housing a peg. Finally, the result is passed to <span
class="literal1">map</span>, which calls <span
class="literal1">first</span> on each tuple to grab just the position
number from the tuples.</p>
<p>After you get a seq of pegged positions numbers, you call a predicate
function on each one to find the first position that returns a truthy
value. The <span id="text_part0016.html_page_120"
class="calibre4"></span>predicate function is created with <span
class="literal1">(comp not-empty (partial valid-moves board))</span>.
The idea is to first return a map of all valid moves for a position and
then test whether that map is empty.</p>
<p>First, the expression <span class="literal1">(partial valid-moves
board)</span> derives an anonymous function from <span
class="literal1">valid-moves</span> with the first argument, <span
class="literal1">board</span>, filled in using <span
class="literal1">partial</span> (because you’re using the same board
each time you call <span class="literal1">valid-moves</span>). The new
function can take a position and return the map of all its valid moves
for the current board.</p>
<p>Second, you use <span class="literal1">comp</span> to compose this
function with <span class="literal1">not-empty</span>. This function is
self-descriptive; it returns <span class="literal1">true</span> if the
given collection is empty and <span class="literal1">false</span>
otherwise.</p>
<p>What’s most interesting about this bit of code is that you’re using a
chain of functions to derive a new function, similar to how you use
chains of functions to derive new data. In <a
href="#text_part0014.html_ch03" class="calibre4">Chapter 3</a>, you
learned that Clojure treats functions as data in that functions can
receive functions as arguments and return them. Hopefully, this shows
why that feature is fun and useful.</p>
<h4 class="h2"
id="text_part0016.html_ch05lev2sec11"><em><strong>Rendering and Printing
the Board</strong></em></h4>
<p>The first few expressions in the board representation and printing
section just define constants:</p>
<pre class="programs"><code>(def alpha-start 97)
(def alpha-end 123)
(def letters (map (comp str char) (range alpha-start alpha-end)))
(def pos-chars 3)</code></pre>
<p>The bindings <span class="literal1">alpha-start</span> and <span
class="literal1">alpha-end</span> set up the beginning and end of the
numerical values for the letters <em>a</em> through <em>z</em>. We use
those to build up a seq of <span class="literal1">letters</span>. <span
class="literal1">char</span>, when applied to an integer, returns the
character corresponding to that integer, and <span
class="literal1">str</span> turns the <span class="literal1">char</span>
into a string. <span class="literal1">pos-chars</span> is used by the
function <span class="literal1">row-padding</span> to determine how much
spacing to add to the beginning of each row. The next few definitions,
<span class="literal1">ansi-styles</span>, <span
class="literal1">ansi</span>, and <span class="literal1">colorize</span>
output colored text to the terminal.</p>
<p>The functions <span class="literal1">render-pos</span>, <span
class="literal1">row-positions</span>, <span
class="literal1">row-padding</span>, and <span
class="literal1">render-row</span> create strings to represent the
board:</p>
<pre class="programs"><code>(defn render-pos
  [board pos]
  (str (nth letters (dec pos))
       (if (get-in board [pos :pegged])
         (colorize &quot;0&quot; :blue)
         (colorize &quot;-&quot; :red))))


(defn row-positions
  &quot;Return all positions in the given row&quot;
  [row-num]
  (range (inc (or (row-tri (dec row-num)) 0))
         (inc (row-tri row-num))))

(defn row-padding
  &quot;String of spaces to add to the beginning of a row to center it&quot;
  [row-num rows]
  (let [pad-length (/ (* (- rows row-num) pos-chars) 2)]
    (apply str (take pad-length (repeat &quot; &quot;)))))


(defn render-row
  [board row-num]
  (str (row-padding row-num (:rows board))
       (clojure.string/join &quot; &quot; (map (partial render-pos board)
                                     (row-positions row-num)))))</code></pre>
<p>If you work from the bottom up, you can see that <span
class="literal1">render-row</span> calls each of the functions above it
to return the string representation of the given row. Notice the
expression <span class="literal1">(map (partial render-pos board)
(row-positions row-num))</span>. This demonstrates a good use case for
partials by applying the same function multiple times with one or more
arguments filled in, just like in the <span
class="literal1">can-move?</span> function shown earlier.</p>
<p>Notice too that <span class="literal1">render-pos</span> uses a
letter rather than a number to identify each position. This saves a
little space when the board is displayed, because it allows only one
character per position to represent a five-row board.</p>
<p>Finally, <span class="literal1">print-board</span> merely iterates
over each row number with <span class="literal1">doseq</span>, printing
the string representation of that row:</p>
<pre class="programs"><code>(defn print-board
  [board]
  (doseq [row-num (range 1 (inc (:rows board)))]
    (println (render-row board row-num))))</code></pre>
<p>You use <span class="literal1">doseq</span> when you want to perform
side-effecting operations (like printing to a terminal) on the elements
of a collection. The vector that immediately follows the name <span
class="literal1">doseq</span> describes how to bind all the elements in
a collection to a name one at a time so you can operate on them. In this
instance, you’re assigning the numbers 1 through 5 (assuming there are
five rows) to the name <span class="literal1">row-num</span> so you can
print each row.</p>
<p>Although printing the board technically falls under
<em>interaction</em>, I wanted to show it here with the rendering
functions. When I first started writing this game, the <span
class="literal1">print-board</span> function also generated the board’s
string representation. However, now <span
class="literal1">print-board</span> defers all rendering to pure
functions, which makes the code easier to understand and decreases the
surface area of our impure functions.</p>
<h4 class="h2" id="text_part0016.html_ch05lev2sec12"><em><strong>Player
Interaction</strong></em></h4>
<p>The next collection of functions handles player interaction. First,
there’s <span class="literal1">letter-&gt;pos</span>, which converts a
letter (which is how the positions are displayed and identified by
players) to the corresponding position number:</p>
<pre class="programs"><code>(defn letter-&gt;pos
  &quot;Converts a letter string to the corresponding position number&quot;

  [letter]
  (inc (- (int (first letter)) alpha-start)))</code></pre>
<p>Next, the helper function <span class="literal1">get-input</span>
allows you to read and clean the player’s input. You can also provide a
default value, which is used if the player presses <span
class="small">ENTER</span> without typing anything:</p>
<pre class="programs"><code>(defn get-input
  &quot;Waits for user to enter text and hit enter, then cleans the input&quot;
  ([] (get-input nil))
  ([default]
     (let [input (clojure.string/trim (read-line))]
       (if (empty? input)
         default
         (clojure.string/lower-case input)))))</code></pre>
<p>The next function, <span
class="literal1">characters-as-strings</span>, is a tiny helper function
used by <span class="literal1">prompt-move</span> to take in a string
and return a collection of letters with all nonalphabetic input
discarded:</p>
<pre class="programs"><code>(characters-as-strings &quot;a  b&quot;)
; =&gt; (&quot;a&quot; &quot;b&quot;)


(characters-as-strings &quot;a  cb&quot;)
; =&gt; (&quot;a&quot; &quot;c&quot; &quot;b&quot;)</code></pre>
<p>Next, <span class="literal1">prompt-move</span> reads the player’s
input and acts on it:</p>
<pre class="programs"><code>(defn prompt-move
  [board]
  (println &quot;\nHere&#39;s your board:&quot;)
  (print-board board)
  (println &quot;Move from where to where? Enter two letters:&quot;)
  (let [input (map letter-&gt;pos (characters-as-strings (get-input)))]
    (if-let [new-board (make-move➊ board (first input) (second input))]
      (user-entered-valid-move new-board)
      (user-entered-invalid-move board))))</code></pre>
<p>At <span class="ent">➊</span>, <span
class="literal1">make-move</span> returns <span
class="literal1">nil</span> if the player’s move was invalid, and you
use that information to inform her of her mistake with the <span
class="literal1">user-entered-invalid-move</span> function. You pass the
unmodified board to <span
class="literal1">user-entered-invalid-move</span> so that it can prompt
the player with the board again. Here’s the function definition:</p>
<pre class="programs"><code>(defn user-entered-invalid-move
  &quot;Handles the next step after a user has entered an invalid move&quot;
  [board]
  (println &quot;\n!!! That was an invalid move :(\n&quot;)
  (prompt-move board))</code></pre>
<p><span id="text_part0016.html_page_123"
class="calibre4"></span>However, if the move is valid, the <span
class="literal1">new-board</span> is passed off to <span
class="literal1">user-entered-valid-move</span>, which hands control
back to <span class="literal1">prompt-move</span> if there are still
moves to be made:</p>
<pre class="programs"><code>(defn user-entered-valid-move
  &quot;Handles the next step after a user has entered a valid move&quot;
  [board]
  (if (can-move? board)
    (prompt-move board)
    (game-over board)))</code></pre>
<p>In our board creation functions, we saw how recursion was used to
build up a value using immutable data structures. The same thing is
happening here, only it involves two mutually recursive functions and
some user input. No mutable attributes in sight!</p>
<p>What happens when the game is over? This is what happens:</p>
<pre class="programs"><code>(defn game-over
  &quot;Announce the game is over and prompt to play again&quot;
  [board]
  (let [remaining-pegs (count (filter :pegged (vals board)))]
    (println &quot;Game over! You had&quot; remaining-pegs &quot;pegs left:&quot;)
    (print-board board)
    (println &quot;Play again? y/n [y]&quot;)
    (let [input (get-input &quot;y&quot;)]
      (if (= &quot;y&quot; input)
        (prompt-rows)
        (do
          (println &quot;Bye!&quot;)
          (System/exit 0))))))</code></pre>
<p>All that’s going on here is that the game tells you how you did,
prints the final board, and prompts you to play again. If you select
<em>y</em>, the game calls <span class="literal1">prompt-rows</span>,
which brings us to the final set of functions, those used to start a new
game:</p>
<pre class="programs"><code>(defn prompt-empty-peg
  [board]
  (println &quot;Here&#39;s your board:&quot;)
  (print-board board)
  (println &quot;Remove which peg? [e]&quot;)
  (prompt-move (remove-peg board (letter-&gt;pos (get-input &quot;e&quot;)))))


(defn prompt-rows
  []
  (println &quot;How many rows? [5]&quot;)
  (let [rows (Integer. (get-input 5))
        board (new-board rows)]
    (prompt-empty-peg board)))</code></pre>
<p><span id="text_part0016.html_page_124" class="calibre4"></span>You
use <span class="literal1">prompt-rows</span> to start a game, getting
the player’s input on how many rows to include. Then you pass control on
to <span class="literal1">prompt-empty-peg</span> so the player can tell
the game which peg to remove first. From there, the program prompts you
for moves until there aren’t any moves left.</p>
<p>Even though all of this program’s side effects are relatively
harmless (all you’re doing is prompting and printing), sequestering them
in their own functions like this is a best practice for functional
programming. In general, you will reap more benefits from functional
programming if you identify the bits of functionality that are
referentially transparent and side-effect free, and place those bits in
their own functions. These functions are not capable of causing bizarre
bugs in unrelated parts of your program. They’re easier to test and
develop in the REPL because they rely only on the arguments you pass
them, not on some complicated hidden state object.</p>
<h3 class="h2"
id="text_part0016.html_ch05lev1sec5"><strong>Summary</strong></h3>
<p>Pure functions are referentially transparent and side-effect free,
which makes them easy to reason about. To get the most from Clojure, try
to keep your impure functions to a minimum. In an immutable world, you
use recursion instead of <span class="literal1">for</span>/<span
class="literal1">while</span> loops, and function composition instead of
successions of mutations. Pure functions allow powerful techniques like
function composition functions and memoization. They’re also super
fun!</p>
<h3 class="h2" id="text_part0016.html_ch05lev1sec6"><strong><span
class="bordera">Exercises</span></strong></h3>
<p>One of the best ways to develop your functional programming skills is
to try to implement existing functions. To that end, most of the
following exercises suggest a function for you to implement, but don’t
stop there; go through the Clojure cheat sheet (<em><a
href="http://clojure.org/cheatsheet/"
class="calibre4">http://clojure.org/cheatsheet/</a></em>) and pick
more!</p>
<p>1. You used <span class="literal1">(comp :intelligence
:attributes)</span> to create a function that returns a character’s
intelligence. Create a new function, <span class="literal1">attr</span>,
that you can call like <span class="literal1">(attr
:intelligence)</span> and that does the same thing.</p>
<p>2. Implement the <span class="literal1">comp</span> function.</p>
<p>3. Implement the <span class="literal1">assoc-in</span> function.
Hint: use the <span class="literal1">assoc</span> function and define
its parameters as <span class="literal1">[m [k &amp; ks] v]</span>.</p>
<p>4. Look up and use the <span class="literal1">update-in</span>
function.</p>
<p>5. Implement <span class="literal1">update-in</span>.</p>
<p><span id="text_part0017.html"></span></p>
<h2 class="h1" id="text_part0017.html_ch06"><span
id="text_part0017.html_page_125" class="calibre1"></span><strong><span
class="big1">6</span></strong><br />
<strong>Organizing Your Project: A Librarian’s Tale</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>Within each of us lives a librarian named Melvil, a fantastical
creature who delights in the organizational arts. Day and night, Melvil
yearns to bring order to your codebase. Fortunately, Clojure provides a
suite of tools designed specifically to aid this homunculus in its
constant struggle against the forces of chaos.</p>
<p>These tools help you organize your code by grouping together related
functions and data. They also prevent name collisions so you don’t
accidentally overwrite someone else’s code or vice versa. Join me in a
tale of suspense and mystery as you learn how to use these tools and
solve the heist of a lifetime! By the end of the saga, you’ll understand
the following:</p>
<p>• What <span class="literal1">def</span> does</p>
<p>• What namespaces are and how to use them</p>
<p>• The relationship between namespaces and the filesystem</p>
<p><span id="text_part0017.html_page_126" class="calibre4"></span>• How
to use <span class="literal1">refer</span>, <span
class="literal1">alias</span>, <span class="literal1">require</span>,
<span class="literal1">use</span>, and <span
class="literal1">ns</span></p>
<p>• How to organize Clojure projects using the filesystem</p>
<p>I’ll start with a high-level overview of Clojure’s organizational
system, which works much like a library. Melvil quivers with
excitement!</p>
<h3 class="h2" id="text_part0017.html_ch06lev1sec1"><strong>Your Project
as a Library</strong></h3>
<p>Real-world libraries store collections of objects, such as books,
magazines, and DVDs. They use addressing systems, so when you’re given
an object’s address, you can navigate to the physical space and retrieve
the object.</p>
<p>Of course, no human being would be expected to know offhand what a
book’s or DVD’s address is. That’s why libraries record the association
between an object’s title and its address and provide tools for
searching these records. In ye olden times before computers, libraries
provided card catalogs, which were cabinets filled with paper cards
containing each book’s title, author, “address” (its Dewey decimal or
Library of Congress number), and other info.</p>
<p>For example, to find <em>The Da Vinci Code</em>, you would riffle
through the title catalog (cards ordered by title) until you found the
correct card. On that card you would see the address <em>813.54</em> (if
it’s using the Dewey decimal system), navigate your library to find the
shelf where <em>The Da Vinci Code</em> resides, and engage in the
literary and/or hate-reading adventure of your lifetime.</p>
<p>It’s useful to imagine a similar setup in Clojure. I think of Clojure
as storing objects (like data structures and functions) in a vast set of
numbered shelves. No human being could know offhand which shelf an
object is stored in. Instead, we give Clojure an identifier that it uses
to retrieve the object.</p>
<p>For this to be successful, Clojure must maintain the associations
between our identifiers and shelf addresses. It does this by using
<em>namespaces</em>. Namespaces contain maps between human-friendly
<em>symbols</em> and references to shelf addresses, known as
<em>vars</em>, much like a card catalog.</p>
<p>Technically, namespaces are objects of type <span
class="literal1">clojure.lang.Namespace</span>, and you can interact
with them just like you can with Clojure data structures. For example,
you can refer to the current namespace with <span
class="literal1">*ns*</span>, and you can get its name with <span
class="literal1">(ns-name *ns*)</span>:</p>
<pre class="programs"><code>(ns-name *ns*)
; =&gt; user</code></pre>
<p>When you start the REPL, for example, you’re in the <span
class="literal1">user</span> namespace (as you can see here). The prompt
shows the current namespace using something like <span
class="literal1">user=&gt;</span>.</p>
<p>The idea of a current namespace implies that you can have more than
one, and indeed Clojure allows you to create as many namespaces as you
want (although technically, there might be an upper limit to the number
of names you can create). In Clojure programs, you are always
<em>in</em> a namespace.</p>
<p><span id="text_part0017.html_page_127" class="calibre4"></span>As for
symbols, you’ve been using them this entire time without even realizing
it. For example, when you write <span class="literal1">(map inc [1
2])</span>, both <span class="literal1">map</span> and <span
class="literal1">inc</span> are symbols. Symbols are data types within
Clojure, and I’ll explain them thoroughly in the next chapter. For now,
all you need to know is that when you give Clojure a symbol like <span
class="literal1">map</span>, it finds the corresponding var in the
current namespace, gets a shelf address, and retrieves an object from
that shelf for you—in this case, the function that <span
class="literal1">map</span> refers to. If you want to just use the
symbol itself, and not the thing it refers to, you have to quote it.
Quoting any Clojure form tells Clojure not to evaluate it but to treat
it as data. The next few examples show what happens when you quote a
form.</p>
<pre class="programs"><code>➊ inc
   ; =&gt; #&lt;core$inc clojure.core$inc@30132014&gt;


➋ &#39;inc
   ; =&gt; inc


➌ (map inc [1 2])
   ; =&gt; (2 3)


➍ &#39;(map inc [1 2])
   ; =&gt; (map inc [1 2])</code></pre>
<p>When you evaluate <span class="literal1">inc</span> in the REPL at
<span class="ent">➊</span>, it prints out the textual representation of
the function that <span class="literal1">inc</span> refers to. Next, you
quote <span class="literal1">inc</span> at <span class="ent">➋</span>,
so the result is the symbol <span class="literal1">inc</span>. Then, you
evaluate a familiar <span class="literal1">map</span> application at
<span class="ent">➌</span> and get a familiar result. After that, you
quote the entire list data structure at <span class="ent">➍</span>,
resulting in an unevaluated list that includes the <span
class="literal1">map</span> symbol, the <span
class="literal1">inc</span> symbol, and a vector.</p>
<p>Now that you know about Clojure’s organization system, let’s look at
how to use it.</p>
<h3 class="h2" id="text_part0017.html_ch06lev1sec2"><strong>Storing
Objects with def</strong></h3>
<p>The primary tool in Clojure for storing objects is <span
class="literal1">def</span>. Other tools like <span
class="literal1">defn</span> use <span class="literal1">def</span> under
the hood. Here’s an example of def in action:</p>
<pre class="programs"><code>(def great-books [&quot;East of Eden&quot; &quot;The Glass Bead Game&quot;])
; =&gt; #&#39;user/great-books


great-books
; =&gt; [&quot;East of Eden&quot; &quot;The Glass Bead Game&quot;]</code></pre>
<p>This code tells Clojure:</p>
<p>1. Update the current namespace’s map with the association between
<span class="literal1">great-books</span> and the var.</p>
<p>2. Find a free storage shelf.</p>
<p>3. Store <span class="literal1">["East of Eden" "The Glass Bead
Game"]</span> on the shelf.</p>
<p><span id="text_part0017.html_page_128" class="calibre4"></span>4.
Write the address of the shelf on the var.</p>
<p>5. Return the var (in this case, <span
class="literal1">#'user/great-books</span>).</p>
<p>This process is called <em>interning</em> a var. You can interact
with a namespace’s map of symbols-to-interned-vars using <span
class="literal1">ns-interns</span>. Here’s how you’d get a map of
interned vars:</p>
<pre class="programs"><code>(ns-interns *ns*)
; =&gt; {great-books #&#39;user/great-books}</code></pre>
<p>You can use the <span class="literal1">get</span> function to get a
specific var:</p>
<pre class="programs"><code>(get (ns-interns *ns*) &#39;great-books)
; =&gt; #&#39;user/great-books</code></pre>
<p>By evaluating <span class="literal1">(ns-map *ns*)</span>, you can
also get the full map that the namespace uses for looking up a var when
given a symbol. <span class="literal1">(ns-map *ns*)</span> gives you a
very large map that I won’t print here, but try it out!</p>
<p><span class="literal1">#'user/great-books</span> is the <em>reader
form</em> of a var. I’ll explain more about reader forms in <a
href="#text_part0018.html_ch07" class="calibre4">Chapter 7</a>. For now,
just know that you can use <span class="literal1">#'</span> to grab hold
of the var corresponding to the symbol that follows; <span
class="literal1">#'user/great-books</span> lets you use the var
associated with the symbol <span class="literal1">great-books</span>
within the <span class="literal1">user</span> namespace. We can <span
class="literal1">deref</span> vars to get the objects they point to:</p>
<pre class="programs"><code>(deref #&#39;user/great-books)
; =&gt; [&quot;East of Eden&quot; &quot;The Glass Bead Game&quot;]</code></pre>
<p>This is like telling Clojure, “Get the shelf number from the var, go
to that shelf number, grab what’s on it, and give it to me!”</p>
<p>But normally, you would just use the symbol:</p>
<pre class="programs"><code>great-books
; =&gt; [&quot;East of Eden&quot; &quot;The Glass Bead Game&quot;]</code></pre>
<p>This is like telling Clojure, “Retrieve the var associated with
great-books and deref that bad Jackson.”</p>
<p>So far so good, right? Well, brace yourself, because this idyllic
paradise of organization is about to be turned upside down! Call <span
class="literal1">def</span> again with the same symbol:</p>
<pre class="programs"><code>(def great-books [&quot;The Power of Bees&quot; &quot;Journey to Upstairs&quot;])
great-books
; =&gt; [&quot;The Power of Bees&quot; &quot;Journey to Upstairs&quot;]</code></pre>
<p>The var has been updated with the address of the new vector. It’s
like you used white-out on the address on a card in the card catalog and
then wrote a new address. The result is that you can no longer ask
Clojure to find the first vector. This is referred to as a <em>name
collision</em>. Chaos! Anarchy!</p>
<p><span id="text_part0017.html_page_129" class="calibre4"></span>You
may have experienced this in other programming languages. JavaScript is
notorious for it, and it happens in Ruby as well. It’s a problem because
you can unintentionally overwrite your own code, and you also have no
guarantee that a third-party library won’t overwrite your code. Melvil
recoils in horror! Fortunately, Clojure allows you to create as many
namespaces as you like so you can avoid these collisions.</p>
<div class="image">
<img src="images_00041.jpeg" class="calibre3" alt="image" />
</div>
<h3 class="h2" id="text_part0017.html_ch06lev1sec3"><strong>Creating and
Switching to Namespaces</strong></h3>
<p>Clojure has three tools for creating namespaces: the function <span
class="literal1">create-ns</span>, the function <span
class="literal1">in-ns</span>, and the macro <span
class="literal1">ns</span>. You’ll mostly use the <span
class="literal1">ns</span> macro in your Clojure files, but I’ll hold
off on explaining it for a few pages because it combines many tools, and
it’s easier to understand after I discuss each of the other tools.</p>
<p><span class="literal1">create-ns</span> takes a symbol, creates a
namespace with that name if it doesn’t exist already, and returns the
namespace:</p>
<pre class="programs"><code>user=&gt; (create-ns &#39;cheese.taxonomy)
; =&gt; #&lt;Namespace cheese.taxonomy&gt;</code></pre>
<p>You can use the returned namespace as an argument in a function
call:</p>
<pre class="programs"><code>user=&gt; (ns-name (create-ns &#39;cheese.taxonomy))
; =&gt; cheese-taxonomy</code></pre>
<p>In practice, you’ll probably never use <span
class="literal1">create-ns</span> in your code, because it’s not very
useful to create a namespace and not move into it. Using <span
class="literal1">in-ns</span> is more common because it creates the
namespace if it doesn’t exist <em>and</em> switches to it, as shown in
<a href="#text_part0017.html_ch6list1" class="calibre4">Listing
6-1</a>.</p>
<pre class="programs"><code>user=&gt; (in-ns &#39;cheese.analysis)
; =&gt; #&lt;Namespace cheese.analysis&gt;</code></pre>
<p><span id="text_part0017.html_ch6list1"
class="calibre4"></span><em>Listing 6-1: Using in-ns to create a
namespace and switch to it</em></p>
<p>Notice that your REPL prompt is now <span
class="literal1">cheese.analysis&gt;</span>, indicating that you are
indeed in the new namespace you just created. Now when you use <span
class="literal1">def</span>, it will store the named object in the <span
class="literal1">cheese.analysis</span> namespace.</p>
<p>But what if you want to use functions and data from other namespaces?
To do that, you can use a <em>fully qualified</em> symbol. The general
form is <em>namespace</em><span
class="literal1">/</span><em>name</em>:</p>
<pre class="programs"><code>cheese.analysis=&gt; (in-ns &#39;cheese.taxonomy)
cheese.taxonomy=&gt; (def cheddars [&quot;mild&quot; &quot;medium&quot; &quot;strong&quot; &quot;sharp&quot; &quot;extra sharp&quot;])
cheese.taxonomy=&gt; (in-ns &#39;cheese.analysis)

cheese.analysis=&gt; cheddars
; =&gt; Exception: Unable to resolve symbol: cheddars in this context</code></pre>
<p>This creates a new namespace, <span
class="literal1">cheese.taxonomy</span>, defines <span
class="literal1">cheddars</span> in that namespace, and then switches
back to the <span class="literal1">cheese.analysis</span> namespace.
You’ll get an exception if you try to refer to the <span
class="literal1">cheese.taxonomy</span> namespace’s <span
class="literal1">cheddars</span> from within <span
class="literal1">cheese.analysis</span>, but using the fully qualified
symbol works:</p>
<pre class="programs"><code>cheese.analysis=&gt; cheese.taxonomy/cheddars
; =&gt; [&quot;mild&quot; &quot;medium&quot; &quot;strong&quot; &quot;sharp&quot; &quot;extra sharp&quot;]</code></pre>
<p>Typing these fully qualified symbols can quickly become a nuisance.
For instance, say I’m an extremely impatient academic specializing in
semiotics-au-fromage, or the study of symbols as they relate to
cheese.</p>
<p>Suddenly, the worst conceivable thing that could possibly happen
happens! All across the world, sacred and historically important cheeses
have gone missing. Wisconsin’s Standard Cheddar: gone! The Great Cheese
Jars of Tutankhamun: stolen! The Cheese of Turin: replaced with a hoax
cheese! This threatens to throw the world into total chaos for some
reason! Naturally, as a distinguished cheese researcher, I am
honor-bound to solve this mystery. Meanwhile, I’m being chased by the
Illuminati, the Freemasons, and the Foot Clan!</p>
<p>Because I’m an academic, I attempt to solve this mystery the best way
I know how—by heading to the library and researching the shit out of it.
My trusty assistant, Clojure, accompanies me. As we bustle from
namespace to namespace, I shout at Clojure to hand me one thing after
another.</p>
<p>But Clojure is kind of dumb and has a hard time figuring out what I’m
referring to. From within the <span class="literal1">user</span>
namespace, I belt out, “<span class="literal1">join</span>! Give me
<span class="literal1">join</span>!”—specks of spittle flying from my
mouth. “<span class="literal1">RuntimeException: Unable to resolve
symbol: join</span>,” Clojure whines in response. “For the love of brie,
just hand me <span class="literal1">clojure.string/join</span>!” I
retort, and Clojure dutifully hands me the function I was looking
for.</p>
<p>My voice gets hoarse. I need some way to tell Clojure what objects to
get me without having to use the fully qualified symbol every. damn.
time.</p>
<p>Luckily, Clojure provides the <span class="literal1">refer</span> and
<span class="literal1">alias</span> tools that let me yell at it more
succinctly.</p>
<h4 class="h2"
id="text_part0017.html_ch06lev2sec1"><em><strong>refer</strong></em></h4>
<p><span class="literal1">refer</span> gives you fine-grained control
over how you refer to objects in other namespaces. Fire up a new REPL
session and try the following. Keep in mind that it’s okay to play
around with namespaces like this in the REPL, but you don’t want your
Clojure files to look like this; the proper way to structure your files
is covered in “<a href="#text_part0017.html_ch06lev1sec4"
class="calibre4">Real Project Organization</a>” on <a
href="#text_part0017.html_page_133" class="calibre4">page 133</a>.</p>
<pre class="programs"><code>user=&gt; (in-ns &#39;cheese.taxonomy)
cheese.taxonomy=&gt; (def cheddars [&quot;mild&quot; &quot;medium&quot; &quot;strong&quot; &quot;sharp&quot; &quot;extra sharp&quot;])
cheese.taxonomy=&gt; (def bries [&quot;Wisconsin&quot; &quot;Somerset&quot; &quot;Brie de Meaux&quot; &quot;Brie de Melun&quot;])
cheese.taxonomy=&gt; (in-ns &#39;cheese.analysis)

cheese.analysis=&gt; (clojure.core/refer &#39;cheese.taxonomy)
cheese.analysis=&gt; bries
; =&gt; [&quot;Wisconsin&quot; &quot;Somerset&quot; &quot;Brie de Meaux&quot; &quot;Brie de Melun&quot;]


cheese.analysis=&gt; cheddars
; =&gt; [&quot;mild&quot; &quot;medium&quot; &quot;strong&quot; &quot;sharp&quot; &quot;extra sharp&quot;]</code></pre>
<p>This code creates a <span class="literal1">cheese.taxonomy</span>
namespace and two vectors within it: <span
class="literal1">cheddars</span> and <span
class="literal1">bries</span>. Then it creates and moves to a new
namespace called <span class="literal1">cheese.analysis</span>. Calling
<span class="literal1">refer</span> with a namespace symbol lets you
refer to the corresponding namespace’s objects without having to use
fully qualified symbols. It does this by updating the current
namespace’s symbol/object map. You can see the new entries like
this:</p>
<pre class="programs"><code>cheese.analysis=&gt; (clojure.core/get (clojure.core/ns-map clojure.core/*ns*) &#39;bries)
; =&gt; #&#39;cheese.taxonomy/bries


cheese.analysis=&gt; (clojure.core/get (clojure.core/ns-map clojure.core/*ns*) &#39;cheddars)
; =&gt; #&#39;cheese.taxonomy/cheddars</code></pre>
<p>It’s as if Clojure</p>
<p>1. Calls <span class="literal1">ns-interns</span> on the <span
class="literal1">cheese.taxonomy</span> namespace</p>
<p>2. Merges that with the <span class="literal1">ns-map</span> of the
current namespace</p>
<p>3. Makes the result the new <span class="literal1">ns-map</span> of
the current namespace</p>
<p>When you call <span class="literal1">refer</span>, you can also pass
it the filters <span class="literal1">:only</span>, <span
class="literal1">:exclude</span>, and <span
class="literal1">:rename</span>. As the names imply, <span
class="literal1">:only</span> and <span class="literal1">:exclude</span>
restrict which symbol/var mappings get merged into the current
namespace’s <span class="literal1">ns-map</span>. <span
class="literal1">:rename</span> lets you use different symbols for the
vars being merged in. Here’s what would happen if we had modified the
preceding example to use <span class="literal1">:only</span>:</p>
<pre class="programs"><code>cheese.analysis=&gt; (clojure.core/refer &#39;cheese.taxonomy :only [&#39;bries])
cheese.analysis=&gt; bries
; =&gt; [&quot;Wisconsin&quot; &quot;Somerset&quot; &quot;Brie de Meaux&quot; &quot;Brie de Melun&quot;]
cheese.analysis=&gt; cheddars
; =&gt; RuntimeException: Unable to resolve symbol: cheddars</code></pre>
<p>And here’s <span class="literal1">:exclude</span> in action:</p>
<pre class="programs"><code>cheese.analysis=&gt; (clojure.core/refer &#39;cheese.taxonomy :exclude [&#39;bries])
cheese.analysis=&gt; bries
; =&gt; RuntimeException: Unable to resolve symbol: bries
cheese.analysis=&gt; cheddars
; =&gt; [&quot;mild&quot; &quot;medium&quot; &quot;strong&quot; &quot;sharp&quot; &quot;extra sharp&quot;]</code></pre>
<p>Lastly, a <span class="literal1">:rename</span> example:</p>
<pre class="programs"><code>cheese.analysis=&gt; (clojure.core/refer &#39;cheese.taxonomy :rename {&#39;bries &#39;yummy-bries})
cheese.analysis=&gt; bries
; =&gt; RuntimeException: Unable to resolve symbol: bries

cheese.analysis=&gt; yummy-bries
; =&gt; [&quot;Wisconsin&quot; &quot;Somerset&quot; &quot;Brie de Meaux&quot; &quot;Brie de Melun&quot;]</code></pre>
<p>Notice that in these last examples we have to use the fully qualified
names of all the objects in <span class="literal1">clojure.core</span>,
like <span class="literal1">clojure.core/ns-map</span> and <span
class="literal1">clojure.core/refer</span>. We didn’t have to do that in
the <span class="literal1">user</span> namespace. That’s because the
REPL automatically refers <span class="literal1">clojure.core</span>
within the <span class="literal1">user</span> namespace. You can make
your life easier by evaluating <span
class="literal1">(clojure.core/refer-clojure)</span> when you create a
new namespace; this will refer the clojure.core namespace, and I’ll be
using it from now on. Instead of seeing <span
class="literal1">clojure.core/refer</span> in the examples, you’ll only
see <span class="literal1">refer</span>.</p>
<p>Another thing to notice is that you have complete freedom over how
you organize your functions and data across namespaces. This lets you
sensibly group related functions and data together in the same
namespace.</p>
<p>Sometimes you may want a function to be available only to other
functions within the same namespace. Clojure allows you to define
<em>private</em> functions using <span
class="literal1">defn-</span>:</p>
<pre class="programs"><code>(in-ns &#39;cheese.analysis)
;; Notice the dash after &quot;defn&quot;
(defn- private-function
  &quot;Just an example function that does nothing&quot;
  [])</code></pre>
<p>If you try to call this function from another namespace or refer it,
Clojure will throw an exception. You can see this when you evaluate the
code at <span class="ent">➊</span> and <span class="ent">➋</span>:</p>
<pre class="programs"><code>   cheese.analysis=&gt; (in-ns &#39;cheese.taxonomy)
   cheese.taxonomy=&gt; (clojure.core/refer-clojure)
➊ cheese.taxonomy=&gt; (cheese.analysis/private-function)
➋ cheese.taxonomy=&gt; (refer &#39;cheese.analysis :only [&#39;private-function])</code></pre>
<p>As you can see, even if you explicitly <span
class="literal1">refer</span> the function, you can’t use the function
from another namespace, because you made it private. (If you want to be
tricky, you can still access the private var using the arcane syntax
<span class="literal1">@#'some/private-var</span>, but you’ll rarely
want to do that.)</p>
<h4 class="h2"
id="text_part0017.html_ch06lev2sec2"><em><strong>alias</strong></em></h4>
<p>Compared to <span class="literal1">refer</span>, <span
class="literal1">alias</span> is relatively simple. All it does is let
you shorten a namespace name for using fully qualified symbols:</p>
<pre class="programs"><code>cheese.analysis=&gt; (clojure.core/alias &#39;taxonomy &#39;cheese.taxonomy)
cheese.analysis=&gt; taxonomy/bries
; =&gt; [&quot;Wisconsin&quot; &quot;Somerset&quot; &quot;Brie de Meaux&quot; &quot;Brie de Melun&quot;]</code></pre>
<p>This code lets us use call symbols from the <span
class="literal1">cheese.taxonomy</span> namespace with the shorter alias
<span class="literal1">taxonomy</span>.</p>
<p><span id="text_part0017.html_page_133" class="calibre4"></span><span
class="literal1">refer</span> and <span class="literal1">alias</span>
are your two basic tools for referring to objects outside your current
namespace! They’re great aids to REPL development.</p>
<p>However, it’s unlikely that you’d create your entire program in the
REPL. In the next section, I’ll cover everything you need to know to
organize a real project with source code living on the filesystem.</p>
<h3 class="h2" id="text_part0017.html_ch06lev1sec4"><strong>Real Project
Organization</strong></h3>
<p>Now that I’ve covered the building blocks of Clojure’s organization
system, I’ll show you how to use them in real projects. I’ll discuss the
relationship between file paths and namespace names, explain how to load
a file with <span class="literal1">require</span> and <span
class="literal1">use</span>, and show how to use <span
class="literal1">ns</span> to set up a namespace.</p>
<h4 class="h2" id="text_part0017.html_ch06lev2sec3"><em><strong>The
Relationship Between File Paths and Namespace Names</strong></em></h4>
<p>To kill two birds with one stone (or feed two birds with one seed,
depending on how much of a hippie you are), I’ll cover more on
namespaces while we work on catching the pesky international cheese
thief by mapping the locations of his heists. Run the following:</p>
<pre class="programs"><code>lein new app the-divine-cheese-code</code></pre>
<p>This should create a directory structure that looks like this:</p>
<pre class="programs"><code>| .gitignore
| doc
| | intro.md
| project.clj
| README.md
| resources
| src
| | the_divine_cheese_code
| | | core.clj
| test
| | the_divine_cheese_code
| | | core_test.clj</code></pre>
<p>Now, open <em>src/the_divine_cheese_code/core.clj</em>. You should
see this on the first line:</p>
<pre class="programs"><code>(ns the-divine-cheese-code.core
  (:gen-class))</code></pre>
<p><span class="literal1">ns</span> is the primary way to create and
manage namespaces within Clojure. I’ll explain it in full shortly. For
now, though, just know that this line is very similar to the <span
class="literal1">in-ns</span> function we used in <a
href="#text_part0017.html_ch6list1" class="calibre4">Listing 6-1</a>. It
creates a namespace if it doesn’t exist and then switches to it. I also
cover <span class="literal1">(:gen-class)</span> in more detail in <a
href="#text_part0024.html_ch12" class="calibre4">Chapter 12</a>.</p>
<p><span id="text_part0017.html_page_134" class="calibre4"></span>The
name of the namespace is <span
class="literal1">the-divine-cheese-code.core</span>. In Clojure, there’s
a one-to-one mapping between a namespace name and the path of the file
where the namespace is declared, according to the following
conventions:</p>
<p>• When you create a directory with <span class="literal1">lein</span>
(as you did here), the source code’s root is <em>src</em> by
default.</p>
<p>• Dashes in namespace names correspond to underscores in the
filesystem. So <span class="literal1">the-divine-cheese-code</span> is
mapped to <em>the_divine_cheese_code</em> on the filesystem.</p>
<p>• The component preceding a period (<span class="literal1">.</span>)
in a namespace name corresponds to a directory. For example, since <span
class="literal1">the-divine-cheese-code.core</span> is the namespace
name, <em>the_divine_cheese_code</em> is a directory.</p>
<p>• The final component of a namespace corresponds to a file with the
<em>.clj</em> extension; <span class="literal1">core</span> is mapped to
<em>core.clj</em>.</p>
<p>Your project will have one more namespace, <span
class="literal1">the-divine-cheese-code.visualization.svg</span>. Go
ahead and create the file for it now:</p>
<pre class="programs"><code>mkdir src/the_divine_cheese_code/visualization
touch src/the_divine_cheese_code/visualization/svg.clj</code></pre>
<p>Notice that the filesystem path follows these conventions. With the
relationship between namespaces and the filesystem down, let’s look at
<span class="literal1">require</span> and <span
class="literal1">use</span>.</p>
<h4 class="h2"
id="text_part0017.html_ch06lev2sec4"><em><strong>Requiring and Using
Namespaces</strong></em></h4>
<p>The code in the <span
class="literal1">the-divine-cheese-code.core</span> namespace will use
the functions in the namespace <span
class="literal1">the-divine-cheese-code.visualization.svg</span> to
create SVG markup. To use <span class="literal1">svg</span>’s functions,
<span class="literal1">core</span> will have to <em>require</em> it. But
first, let’s add some code to <em>svg.clj</em>. Make it look like this
(you’ll add more later):</p>
<pre class="programs"><code>(ns the-divine-cheese-code.visualization.svg)


(defn latlng-&gt;point
  &quot;Convert lat/lng map to comma-separated string&quot;
  [latlng]
  (str (:lng latlng) &quot;,&quot; (:lat latlng)))


(defn points
  [locations]
  (clojure.string/join &quot; &quot; (map latlng-&gt;point locations)))</code></pre>
<p>This defines two functions, <span
class="literal1">latlng-&gt;point</span> and <span
class="literal1">points</span>, which you’ll use to convert a seq of
latitude/longitude coordinates into a string of points. To use this code
from the <em>core.clj</em> file, you have to <span
class="literal1">require</span> it. <span
class="literal1">require</span> takes a symbol designating a namespace
and ensures that the namespace exists and is ready to be used; in this
case, when you call <span class="literal1">(require 'the-divine-cheese
-code.visualization.svg)</span>, Clojure reads and evaluates the
corresponding file. <span id="text_part0017.html_page_135"
class="calibre4"></span>By evaluating the file, it creates the <span
class="literal1">the-divine-cheese-code.visualization.svg</span>
namespace and defines the functions <span
class="literal1">latlng-&gt;point</span> and <span
class="literal1">points</span> within that namespace. Even though the
file <em>svg.clj</em> is in your project’s directory, Clojure doesn’t
automatically evaluate it when it runs your project; you have to
explicitly tell Clojure that you want to use it.</p>
<p>After requiring the namespace, you can <em>refer</em> it so that you
don’t have to use fully qualified names to reference the functions. Go
ahead and require <span
class="literal1">the-divine-cheese-code.visualization.svg</span> and add
the <span class="literal1">heists</span> seq to make <em>core.clj</em>
match the listing:</p>
<pre class="programs"><code>(ns the-divine-cheese-code.core)
;; Ensure that the SVG code is evaluated
(require &#39;the-divine-cheese-code.visualization.svg)
;; Refer the namespace so that you don&#39;t have to use the
;; fully qualified name to reference svg functions
(refer &#39;the-divine-cheese-code.visualization.svg)


(def heists [{:location &quot;Cologne, Germany&quot;
              :cheese-name &quot;Archbishop Hildebold&#39;s Cheese Pretzel&quot;
              :lat 50.95
              :lng 6.97}
             {:location &quot;Zurich, Switzerland&quot;
              :cheese-name &quot;The Standard Emmental&quot;
              :lat 47.37
              :lng 8.55}
             {:location &quot;Marseille, France&quot;
              :cheese-name &quot;Le Fromage de Cosquer&quot;
              :lat 43.30
              :lng 5.37}
             {:location &quot;Zurich, Switzerland&quot;
              :cheese-name &quot;The Lesser Emmental&quot;
              :lat 47.37
              :lng 8.55}
             {:location &quot;Vatican City&quot;
              :cheese-name &quot;The Cheese of Turin&quot;
              :lat 41.90
              :lng 12.45}])


(defn -main
  [&amp; args]
  (println (points heists)))</code></pre>
<p>Now you have a seq of heist locations to work with and you can use
functions from the <span class="literal1">visualization.svg</span>
namespace. The <span class="literal1">main</span> function simply
applies the <span class="literal1">points</span> function to <span
class="literal1">heists</span>. If you run the project with <span
class="literal1">lein run</span>, you should see this:</p>
<pre class="programs"><code>50.95,6.97 47.37,8.55 43.3,5.37 47.37,8.55 41.9,12.45</code></pre>
<p>Hooray! You’re one step closer to catching that purloiner of the
fermented curd! Using <span class="literal1">require</span> successfully
loaded <span
class="literal1">the-divine-cheese-code.visualization.svg</span> for
use.</p>
<p><span id="text_part0017.html_page_136" class="calibre4"></span>The
details of <span class="literal1">require</span> are actually a bit
complicated, but for practical purposes you can think of <span
class="literal1">require</span> as telling Clojure the following:</p>
<p>1. Do nothing if you’ve already called <span
class="literal1">require</span> with this symbol (<span
class="literal1">the-divine -cheese-code.visualization.svg</span>).</p>
<p>2. Otherwise, find the file that corresponds to this symbol using the
rules described in “<a href="#text_part0017.html_ch06lev2sec3"
class="calibre4">The Relationship Between File Paths and Namespace
Names</a>” on <a href="#text_part0017.html_page_133"
class="calibre4">page 133</a>. In this case, Clojure finds <span
class="literal1">src/the_divine_cheese_code/visualization/svg.clj</span>.</p>
<p>Read and evaluate the contents of that file. Clojure expects the file
to declare a namespace corresponding to its path (which ours does).</p>
<p><span class="literal1">require</span> also lets you alias a namespace
when you require it, using <span class="literal1">:as</span> or <span
class="literal1">alias</span>. This:</p>
<pre class="programs"><code>(require &#39;[the-divine-cheese-code.visualization.svg :as svg])</code></pre>
<p>is equivalent to this:</p>
<pre class="programs"><code>(require &#39;the-divine-cheese-code.visualization.svg)
(alias &#39;svg &#39;the-divine-cheese-code.visualization.svg)</code></pre>
<p>You can now use the aliased namespace:</p>
<pre class="programs"><code>(svg/points heists)
; =&gt; &quot;50.95,6.97 47.37,8.55 43.3,5.37 47.37,8.55 41.9,12.45&quot;</code></pre>
<p>Clojure provides another shortcut. Instead of calling <span
class="literal1">require</span> and <span class="literal1">refer</span>
separately, the function <span class="literal1">use</span> does both.
It’s frowned upon to use <span class="literal1">use</span> in production
code, but it’s handy when you’re experimenting in the REPL and you want
to quickly get your hands on some functions. For example, this:</p>
<pre class="programs"><code>(require &#39;the-divine-cheese-code.visualization.svg)
(refer &#39;the-divine-cheese-code.visualization.svg)</code></pre>
<p>is equivalent to this:</p>
<pre class="programs"><code>(use &#39;the-divine-cheese-code.visualization.svg)</code></pre>
<p>You can alias a namespace with <span class="literal1">use</span> just
like you can with <span class="literal1">require</span>. This:</p>
<pre class="programs"><code>(require &#39;the-divine-cheese-code.visualization.svg)
(refer &#39;the-divine-cheese-code.visualization.svg)
(alias &#39;svg &#39;the-divine-cheese-code.visualization.svg)</code></pre>
<p>is equivalent to the code in <a href="#text_part0017.html_ch6list2"
class="calibre4">Listing 6-2</a>, which also shows aliased namespaces
being used in function calls.</p>
<pre class="programs"><code>(use &#39;[the-divine-cheese-code.visualization.svg :as svg])
(= svg/points points)
; =&gt; true


(= svg/latlng-&gt;point latlng-&gt;point)
; =&gt; true</code></pre>
<p><span id="text_part0017.html_ch6list2"
class="calibre4"></span><em>Listing 6-2: Sometimes it’s handy to both
use and alias a namespace.</em></p>
<p>It may seem redundant to alias a namespace with <span
class="literal1">use</span> here because <span
class="literal1">use</span> already refers the namespace (which lets you
simply call <span class="literal1">points</span> instead of <span
class="literal1">svg/points</span>). In certain situations, though, it’s
handy because <span class="literal1">use</span> takes the same options
as <span class="literal1">refer</span> (<span
class="literal1">:only</span>, <span class="literal1">:exclude</span>,
<span class="literal1">:as</span>, and <span
class="literal1">:rename</span>). You might want to alias a namespace
with <span class="literal1">use</span> when you’ve skipped referring a
symbol. You could use this:</p>
<pre class="programs"><code>(require &#39;the-divine-cheese-code.visualization.svg)
(refer &#39;the-divine-cheese-code.visualization.svg :as :only [&#39;points])</code></pre>
<p>Or you could use the <span class="literal1">use</span> form in <a
href="#text_part0017.html_ch6list3" class="calibre4">Listing 6-3</a>
(which also includes examples of how you can call functions).</p>
<pre class="programs"><code>(use &#39;[the-divine-cheese-code.visualization.svg :as svg :only [points]])
(refer &#39;the-divine-cheese-code.visualization.svg :as :only [&#39;points])
(= svg/points points)
; =&gt; true


;; We can use the alias to reach latlng-&gt;point
svg/latlng-&gt;point
; This doesn&#39;t throw an exception


;; But we can&#39;t use the bare name
latlng-&gt;point
; This does throw an exception!</code></pre>
<p><span id="text_part0017.html_ch6list3"
class="calibre4"></span><em>Listing 6-3: Aliasing a namespace after you
use it lets you refer to symbols that you excluded.</em></p>
<p>If you try <a href="#text_part0017.html_ch6list3"
class="calibre4">Listing 6-3</a> in a REPL and <span
class="literal1">latlng-&gt;point</span> doesn’t throw an exception,
it’s because you referred <span class="literal1">latlng-&gt;point</span>
in <a href="#text_part0017.html_ch6list2" class="calibre4">Listing
6-2</a>. You’ll need to restart your REPL session for the code to behave
as shown in <a href="#text_part0017.html_ch6list3"
class="calibre4">Listing 6-3</a>.</p>
<p>The takeaway here is that <span class="literal1">require</span> and
<span class="literal1">use</span> load files and optionally <span
class="literal1">alias</span> or <span class="literal1">refer</span>
their namespaces. As you write Clojure programs and read code written by
others, you might encounter even more ways of writing <span
class="literal1">require</span> and <span class="literal1">use</span>,
at which point it’ll make sense to read Clojure’s API docs (<em><a
href="http://clojure.org/libs/"
class="calibre4">http://clojure.org/libs/</a></em>) to understand what’s
going on. However, what you’ve learned so far about <span
class="literal1">require</span> and <span class="literal1">use</span>
should cover 95.3 percent of your needs.</p>
<h4 class="h2" id="text_part0017.html_ch06lev2sec5"><span
id="text_part0017.html_page_138" class="calibre1"></span><em><strong>The
ns Macro</strong></em></h4>
<p>Now it’s time to look at the <span class="literal1">ns</span> macro.
The tools covered so far—<span class="literal1">in-ns</span>, <span
class="literal1">refer</span>, <span class="literal1">alias</span>,
<span class="literal1">require</span>, and <span
class="literal1">use</span>—are most often used when you’re playing in
the REPL. In your source code files, you’ll typically use the <span
class="literal1">ns</span> macro because it allows you to use the tools
described so far succinctly and provides other useful functionality. In
this section, you’ll learn about how one <span
class="literal1">ns</span> call can incorporate <span
class="literal1">require</span>, <span class="literal1">use</span>,
<span class="literal1">in-ns</span>, <span
class="literal1">alias</span>, and <span
class="literal1">refer</span>.</p>
<p>One useful task <span class="literal1">ns</span> does is refer the
<span class="literal1">clojure.core</span> namespace by default. That’s
why you can call <span class="literal1">println</span> from within <span
class="literal1">the-divine-cheese-code.core</span> without using the
fully qualified name, <span
class="literal1">clojure.core/println</span>.</p>
<p>You can control what gets referred from <span
class="literal1">clojure-core</span> with <span
class="literal1">:refer-clojure</span>, which takes the same options as
<span class="literal1">refer</span>:</p>
<pre class="programs"><code>(ns the-divine-cheese-code.core
  (:refer-clojure :exclude [println]))</code></pre>
<p>If you called this at the beginning of
<em>divine_cheese_code.core.clj</em>, it would break your code, forcing
you to use <span class="literal1">clojure.core/println</span> within the
<span class="literal1">-main</span> function.</p>
<p>Within <span class="literal1">ns</span>, the form <span
class="literal1">(:refer-clojure)</span> is called a <em>reference</em>.
This might look weird to you. Is this reference a function call? A
macro? What is it? You’ll learn more about the underlying machinery in
<a href="#text_part0018.html_ch07" class="calibre4">Chapter 7</a>. For
now, you just need to understand how each reference maps to function
calls. For example, the preceding code is equivalent to this:</p>
<pre class="programs"><code>(in-ns &#39;the-divine-cheese-code.core)
(refer &#39;clojure.core :exclude [&#39;println])</code></pre>
<p>There are six possible kinds of references within <span
class="literal1">ns</span>:</p>
<p>• <span class="literal1">(:refer-clojure)</span></p>
<p>• <span class="literal1">(:require)</span></p>
<p>• <span class="literal1">(:use)</span></p>
<p>• <span class="literal1">(:import)</span></p>
<p>• <span class="literal1">(:load)</span></p>
<p>• <span class="literal1">(:gen-class)</span></p>
<p><span class="literal1">(:import)</span> and <span
class="literal1">(:gen-class)</span> are covered in <a
href="#text_part0024.html_ch12" class="calibre4">Chapter 12</a>. I won’t
cover <span class="literal1">(:load)</span> because it is seldom
used.</p>
<p><span class="literal1">(:require)</span> works a lot like the <span
class="literal1">require</span> function. For example, this:</p>
<pre class="programs"><code>(ns the-divine-cheese-code.core
  (:require the-divine-cheese-code.visualization.svg))</code></pre>
<p>is equivalent to this:</p>
<pre class="programs"><code>(in-ns &#39;the-divine-cheese-code.core)
(require &#39;the-divine-cheese-code.visualization.svg)</code></pre>
<p><span id="text_part0017.html_page_139" class="calibre4"></span>Notice
that in the <span class="literal1">ns</span> form (unlike the <span
class="literal1">in-ns</span> function call), you don’t have to quote
your symbol with <span class="literal1">'</span>. You never have to
quote symbols within <span class="literal1">ns</span>.</p>
<p>You can also <span class="literal1">alias</span> a library that you
<span class="literal1">require</span> within <span
class="literal1">ns</span>, just like when you call the function.
This:</p>
<pre class="programs"><code>(ns the-divine-cheese-code.core
  (:require [the-divine-cheese-code.visualization.svg :as svg]))</code></pre>
<p>is equivalent to this:</p>
<pre class="programs"><code>(in-ns &#39;the-divine-cheese-code.core)
(require [&#39;the-divine-cheese-code.visualization.svg :as &#39;svg])</code></pre>
<p>You can require multiple libraries in a <span
class="literal1">(:require)</span> reference as follows. This:</p>
<pre class="programs"><code>(ns the-divine-cheese-code.core
  (:require [the-divine-cheese-code.visualization.svg :as svg]
            [clojure.java.browse :as browse]))</code></pre>
<p>is equivalent to this:</p>
<pre class="programs"><code>(in-ns &#39;the-divine-cheese-code.core)
(require [&#39;the-divine-cheese-code.visualization.svg :as &#39;svg])
(require [&#39;clojure.java.browse :as &#39;browse])</code></pre>
<p>However, one difference between the <span
class="literal1">(:require)</span> reference and the <span
class="literal1">require</span> function is that the reference also
allows you to refer names. This:</p>
<pre class="programs"><code>(ns the-divine-cheese-code.core
  (:require [the-divine-cheese-code.visualization.svg :refer [points]]))</code></pre>
<p>is equivalent to this:</p>
<pre class="programs"><code>(in-ns &#39;the-divine-cheese-code.core)
(require &#39;the-divine-cheese-code.visualization.svg)
(refer &#39;the-divine-cheese-code.visualization.svg :only [&#39;points])</code></pre>
<p>You can also refer all symbols (notice the <span
class="literal1">:all</span> keyword):</p>
<pre class="programs"><code>(ns the-divine-cheese-code.core
  (:require [the-divine-cheese-code.visualization.svg :refer :all]))</code></pre>
<p>which is the same as doing this:</p>
<pre class="programs"><code>(in-ns &#39;the-divine-cheese-code.core)
(require &#39;the-divine-cheese-code.visualization.svg)
(refer &#39;the-divine-cheese-code.visualization.svg)</code></pre>
<p><span id="text_part0017.html_page_140" class="calibre4"></span>This
is the preferred way to require code, alias namespaces, and refer
symbols. It’s recommended that you not use <span
class="literal1">(:use)</span>, but since it’s likely that you’ll come
across it, it’s good to know how it works. You know the drill. This:</p>
<pre class="programs"><code>(ns the-divine-cheese-code.core
  (:use clojure.java.browse))</code></pre>
<p>does this:</p>
<pre class="programs"><code>(in-ns &#39;the-divine-cheese-code.core)
(use &#39;clojure.java.browse)</code></pre>
<p>whereas this:</p>
<pre class="programs"><code>(ns the-divine-cheese-code.core
  (:use [clojure.java browse io]))</code></pre>
<p>does this:</p>
<pre class="programs"><code>(in-ns &#39;the-divine-cheese-code.core)
(use &#39;clojure.java.browse)
(use &#39;clojure.java.io)</code></pre>
<p>Notice that when you follow <span class="literal1">:use</span> with a
vector, it takes the first symbol as the <em>base</em> and then calls
<span class="literal1">use</span> with each symbol that follows.</p>
<p>Oh my god, that’s it! Now you can use <span
class="literal1">ns</span> like a pro! And you’re going to need to,
dammit, because that <em>voleur des fromages</em> (as they probably say
in French) is still running amok! Remember him/her?!</p>
<h3 class="h2" id="text_part0017.html_ch06lev1sec5"><strong>To Catch a
Burglar</strong></h3>
<p>We can’t allow this plunderer of parmesan to make off with any more
cheese! It’s time to finish drawing lines based on the coordinates of
the heists! That will surely reveal something!</p>
<p>Using the latitude coordinates for each heist, you’ll connect the
dots in an SVG image. But if you draw lines using the given coordinates,
the result won’t look right for two reasons. First, latitude coordinates
ascend from south to north, whereas SVG y-coordinates ascend from top to
bottom. In other words, you need to flip the coordinates or the drawing
will be upside down.</p>
<p>Second, the drawing will be very small. To fix that, you’ll zoom in
on it by translating and scaling it. It’s like turning a drawing that
looks like <a href="#text_part0017.html_ch6fig1" class="calibre4">Figure
6-1</a>a into <a href="#text_part0017.html_ch6fig1"
class="calibre4">Figure 6-1</a>b.</p>
<div class="image">
<span id="text_part0017.html_page_141" class="calibre4"></span><img
src="images_00042.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0017.html_ch6fig1"
class="calibre4"></span><em>Figure 6-1: Flipping, translating, and
scaling latitude coordinates to make an SVG image.</em></p>
<p>Honestly, this is all completely arbitrary and it’s no longer
directly related to code organization, but it’s fun and I think you’ll
have a good time going through the code! Make your <em>svg.clj</em> file
match <a href="#text_part0017.html_ch6list4" class="calibre4">Listing
6-4</a>:</p>
<pre class="programs"><code>   (ns the-divine-cheese-code.visualization.svg
     (:require [clojure.string :as s])
     (:refer-clojure :exclude [min max]))


➊ (defn comparator-over-maps
    [comparison-fn ks]
    (fn [maps]
➋     (zipmap ks
➌             (map (fn [k] (apply comparison-fn (map k maps)))
                    ks))))


➍ (def min (comparator-over-maps clojure.core/min [:lat :lng]))
   (def max (comparator-over-maps clojure.core/max [:lat :lng]))</code></pre>
<p><span id="text_part0017.html_ch6list4"
class="calibre4"></span><em>Listing 6-4: Constructing map comparison
functions</em></p>
<p>You define the <span class="literal1">comparator-over-maps</span>
function at <span class="ent">➊</span>. This is probably the trickiest
bit, so bear with me. <span class="literal1">comparator-over-maps</span>
is a function that returns a function. The returned function compares
the values for the keys provided by the <span class="literal1">ks</span>
parameter using the supplied comparison function, <span
class="literal1">comparison-fn</span>.</p>
<p>You use <span class="literal1">comparator-over-maps</span> to
construct the <span class="literal1">min</span> and <span
class="literal1">max</span> functions <span class="ent">➍</span>, which
you’ll use to find the top-left and bottom-right corners of our drawing.
Here’s <span class="literal1">min</span> in action:</p>
<pre class="programs"><code>(min [{:a 1 :b 3} {:a 5 :b 0}])
; =&gt; {:a 1 :b 0}</code></pre>
<p>When you call <span class="literal1">min</span>, it calls <span
class="literal1">zipmap</span> <span class="ent">➋</span>, which takes
two arguments, both seqs, and returns a new map. The elements of the
first seq become the keys, and the elements of the second seq become the
values:</p>
<pre class="programs"><code>(zipmap [:a :b] [1 2])
; =&gt; {:a 1 :b 2}</code></pre>
<p><span id="text_part0017.html_page_142" class="calibre4"></span>At
<span class="ent">➋</span>, the first argument to <span
class="literal1">zipmap</span> is <span class="literal1">ks</span>, so
the elements of <span class="literal1">ks</span> will be the keys of the
returned map. The second argument is the result of the map call at <span
class="ent">➌</span>. That map call actually performs the
comparison.</p>
<p>Finally, at <span class="ent">➍</span> you use <span
class="literal1">comparator-over-maps</span> to create the comparison
functions. If you think of the drawing as being inscribed in a
rectangle, <span class="literal1">min</span> is the corner of the
rectangle closest to (0, 0) and <span class="literal1">max</span> is the
corner farthest from it.</p>
<p>Here’s the next part of the code:</p>
<pre class="programs"><code>➎ (defn translate-to-00
     [locations]
     (let [mincoords (min locations)]
       (map #(merge-with - % mincoords) locations)))


➏ (defn scale
     [width height locations]
     (let [maxcoords (max locations)
           ratio {:lat (/ height (:lat maxcoords))
                  :lng (/ width (:lng maxcoords))}]
       (map #(merge-with * % ratio) locations)))</code></pre>
<p><span class="literal1">translate-to-00</span>, defined at <span
class="ent">➎</span>, works by finding the <span
class="literal1">min</span> of our locations and subtracting that value
from each location. It uses <span class="literal1">merge-with</span>,
which works like this:</p>
<pre class="programs"><code>(merge-with - {:lat 50 :lng 10} {:lat 5 :lng 5})
; =&gt; {:lat 45 :lng 5}</code></pre>
<p>Then we define the function <span class="literal1">scale</span> at
<span class="ent">➏</span>, which multiplies each point by the ratio
between the maximum latitude and longitude and the desired height and
width.</p>
<p>Here’s the rest of the code for <em>svg.clj</em>:</p>
<pre class="programs"><code>(defn latlng-&gt;point
  &quot;Convert lat/lng map to comma-separated string&quot;
  [latlng]
  (str (:lng latlng) &quot;,&quot; (:lat latlng)))


(defn points
  &quot;Given a seq of lat/lng maps, return string of points joined by space&quot;
  [locations]
  (s/join &quot; &quot; (map latlng-&gt;point locations)))


(defn line
  [points]
  (str &quot;&lt;polyline points=\&quot;&quot; points &quot;\&quot; /&gt;&quot;))


(defn transform
  &quot;Just chains other functions&quot;
  [width height locations]
  (-&gt;&gt; locations
       translate-to-00
       (scale width height)))

(defn xml
  &quot;svg &#39;template&#39;, which also flips the coordinate system&quot;
  [width height locations]
  (str &quot;&lt;svg height=\&quot;&quot; height &quot;\&quot; width=\&quot;&quot; width &quot;\&quot;&gt;&quot;
       ;; These two &lt;g&gt; tags flip the coordinate system
       &quot;&lt;g transform=\&quot;translate(0,&quot; height &quot;)\&quot;&gt;&quot;
       &quot;&lt;g transform=\&quot;scale(1,-1)\&quot;&gt;&quot;
       (-&gt; (transform width height locations)
           points
           line)
       &quot;&lt;/g&gt;&lt;/g&gt;&quot;
       &quot;&lt;/svg&gt;&quot;))</code></pre>
<p>The functions here are pretty straightforward. They just take <span
class="literal1">{:lat x :lng y}</span> maps and transform them so that
an SVG can be created. <span class="literal1">latlng-&gt;point</span>
returns a string that can be used to define a point in SVG markup. <span
class="literal1">points</span> converts a seq of <span
class="literal1">lat</span>/<span class="literal1">lng</span> maps into
a space-separated string of points. <span class="literal1">line</span>
returns the SVG markup for a line that connects all given
space-separated strings of points. <span
class="literal1">transform</span> takes a seq of locations, translates
them so they start at the point (0, 0), and scales them to the given
width and height. Finally, <span class="literal1">xml</span> produces
the markup for displaying the given locations using SVG.</p>
<p>With <em>svg.clj</em> all coded up, now make <em>core.clj</em> look
like this:</p>
<pre class="programs"><code>(ns the-divine-cheese-code.core
  (:require [clojure.java.browse :as browse]
            [the-divine-cheese-code.visualization.svg :refer [xml]])
  (:gen-class))


(def heists [{:location &quot;Cologne, Germany&quot;
              :cheese-name &quot;Archbishop Hildebold&#39;s Cheese Pretzel&quot;
              :lat 50.95
              :lng 6.97}
             {:location &quot;Zurich, Switzerland&quot;
              :cheese-name &quot;The Standard Emmental&quot;
              :lat 47.37
              :lng 8.55}
             {:location &quot;Marseille, France&quot;
              :cheese-name &quot;Le Fromage de Cosquer&quot;
              :lat 43.30
              :lng 5.37}
             {:location &quot;Zurich, Switzerland&quot;
              :cheese-name &quot;The Lesser Emmental&quot;
              :lat 47.37
              :lng 8.55}
             {:location &quot;Vatican City&quot;
              :cheese-name &quot;The Cheese of Turin&quot;
              :lat 41.90
              :lng 12.45}])

(defn url
  [filename]
  (str &quot;file:///&quot;
       (System/getProperty &quot;user.dir&quot;)
       &quot;/&quot;
       filename))


(defn template
  [contents]
  (str &quot;&lt;style&gt;polyline { fill:none; stroke:#5881d8; stroke-width:3}&lt;/style&gt;&quot;
       contents))


(defn -main
  [&amp; args]
  (let [filename &quot;map.html&quot;]
    (-&gt;&gt; heists
         (xml 50 100)
         template
         (spit filename))
    (browse/browse-url (url filename))))</code></pre>
<p>Nothing too complicated is going on here. Within <span
class="literal1">-main</span> you build up the drawing using the <span
class="literal1">xml</span> and <span class="literal1">template</span>
functions, write the drawing to a file with <span
class="literal1">spit</span>, and then open it with <span
class="literal1">browse/browse-url</span>. You should try that now! Run
<span class="literal1">lein run</span> and you’ll see something that
looks like <a href="#text_part0017.html_ch6fig2" class="calibre4">Figure
6-2</a>.</p>
<p>Wait a minute . . . that looks a lot like . . . that looks a lot like
a lambda. Clojure’s logo is a lambda . . . oh my god! Clojure, it was
you this whole time!</p>
<div class="image">
<img src="images_00043.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0017.html_ch6fig2"
class="calibre4"></span><em>Figure 6-2: The final SVG of the heist
pattern!</em></p>
<h3 class="h2"
id="text_part0017.html_ch06lev1sec6"><strong>Summary</strong></h3>
<p>You learned a lot in this chapter. At this point, you should have all
the tools you need to start organizing your projects. You now know that
namespaces organize maps between symbols and vars, and that vars are
references to Clojure objects (data structures, functions, and so on).
<span class="literal1">def</span> stores an object and updates the
current namespace with a map between a symbol and a var that points to
the object. You can create private functions with <span
class="literal1">defn-</span>.</p>
<p>Clojure lets you create namespaces with <span
class="literal1">create-ns</span>, but often it’s more useful to use
<span class="literal1">in-ns</span>, which switches to the namespace as
well. You’ll probably only use these functions in the REPL. When you’re
in the REPL, you’re always <em>in</em> the current namespace. When
you’re defining namespaces in a file rather than the REPL, you should
use the <span class="literal1">ns</span> macro, and there’s a one-to-one
relationship between a namespace and its path on the filesystem.</p>
<p><span id="text_part0017.html_page_145" class="calibre4"></span>You
can refer to objects in other namespaces by using the fully qualified
name, like <span class="literal1">cheese.taxonomy/cheddars</span>. <span
class="literal1">refer</span> lets you use names from other namespaces
without having to fully qualify them, and <span
class="literal1">alias</span> lets you use a shorter name for a
namespace when you’re writing out a fully qualified name.</p>
<p><span class="literal1">require</span> and <span
class="literal1">use</span> ensure that a namespace exists and is ready
to be used, and optionally let you <span class="literal1">refer</span>
and <span class="literal1">alias</span> the corresponding namespaces.
You should use <span class="literal1">ns</span> to call <span
class="literal1">require</span> and <span class="literal1">use</span> in
your source files. <em><a href="https://gist.github.com/ghoseb/287710/"
class="calibre4">https://gist.github.com/ghoseb/287710/</a></em> is a
great reference for all the vagaries of using <span
class="literal1">ns</span>.</p>
<p>Lastly and most importantly, it ain’t easy being cheesy.</p>
<div class="image">
<img src="images_00044.jpeg" class="calibre3" alt="image" /><span
id="text_part0017.html_page_146" class="calibre4"></span>
</div>
<p><span id="text_part0018.html"></span></p>
<h2 class="h1" id="text_part0018.html_ch07"><span
id="text_part0018.html_page_147" class="calibre1"></span><strong><span
class="big1">7</span></strong><br />
<strong>Clojure Alchemy: Reading, Evaluation, and Macros</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>The philosopher’s stone, along with the elixir of life and Viagra, is
one of the most well-known specimens of alchemical lore, pursued for its
ability to transmute lead into gold. Clojure, however, offers a tool
that makes the philosopher’s stone look like a mere trinket: the
<em>macro</em>.</p>
<p>Macros allow you to transform arbitrary expressions into valid
Clojure, so you can extend the language itself to fit your needs. And
you don’t even have to be a wizened old dude or lady in a robe to use
them!</p>
<p>To get just a sip of this power, consider this trivial macro:</p>
<pre class="programs"><code>(defmacro backwards
  [form]
  (reverse form))


(backwards (&quot; backwards&quot; &quot; am&quot; &quot;I&quot; str))
; =&gt; &quot;I am backwards&quot;</code></pre>
<p><span id="text_part0018.html_page_148" class="calibre4"></span>The
<span class="literal1">backwards</span> macro allows Clojure to
successfully evaluate the expression <span class="literal1">("
backwards" " am" "I" str)</span>, even though it doesn’t follow
Clojure’s built-in syntax rules, which require an expression’s operand
to appear first (not to mention the rule that an expression not be
written in reverse order). Without <span
class="literal1">backwards</span>, the expression would fail harder than
millennia of alchemists ironically spending their entire lives pursuing
an impossible means of achieving immortality. With <span
class="literal1">backwards</span>, <em>you’ve created your own
syntax!</em> You’ve extended Clojure so you can write code however you
please! Better than turning lead into gold, I tell you!</p>
<p>This chapter gives you the conceptual foundation you need to go mad
with power writing your own macros. It explains the elements of
Clojure’s evaluation model: the <em>reader</em>, the <em>evaluator</em>,
and the <em>macro expander</em>. It’s like the periodic table of Clojure
elements. Think of how the periodic table reveals the properties of
atoms: elements in the same column behave similarly because they have
the same nuclear charge. Without the periodic table and its underlying
theory, we’d be in the same position as the alchemists of yore, mixing
stuff together randomly to see what blows up. But with a deeper
understanding of the elements, you can see why stuff blows up and learn
how to blow stuff up on purpose.</p>
<h3 class="h2" id="text_part0018.html_ch07lev1sec1"><strong>An Overview
of Clojure’s Evaluation Model</strong></h3>
<p>Clojure (like all Lisps) has an evaluation model that differs from
most other languages: it has a two-phase system where it <em>reads</em>
textual source code, producing Clojure data structures. These data
structures are then <em>evaluated</em>: Clojure traverses the data
structures and performs actions like function application or var lookup
based on the type of the data structure. For example, when Clojure reads
the text <span class="literal1">(+ 1 2)</span>, the result is a list
data structure whose first element is a <span class="literal1">+</span>
symbol, followed by the numbers 1 and 2. This data structure is passed
to Clojure’s evaluator, which looks up the function corresponding to
<span class="literal1">+</span> and applies that function to 1 and
2.</p>
<div class="image">
<img src="images_00045.jpeg" class="calibre3" alt="image" />
</div>
<p>Languages that have this relationship between source code, data, and
evaluation are called <em>homoiconic.</em> (Incidentally, if you say
<em>homoiconic</em> in front of your bathroom mirror three times with
the lights out, the ghost of John McCarthy appears and hands you a
parenthesis.) Homoiconic languages empower you to reason about your code
as a set of data structures that you can manipulate programmatically. To
put this into context, let’s take a jaunt through the land of
compilation.</p>
<p>Programming languages require a compiler or interpreter for
translating the code you write, which consists of Unicode characters,
into something else: machine instructions, code in another programming
language, whatever. During this process, the <span
id="text_part0018.html_page_149" class="calibre4"></span>compiler
constructs an <em>abstract syntax tree (AST)</em>, which is a data
structure that represents your program. You can think of the AST as the
input to the <em>evaluator</em>, which you can think of as a function
that traverses the tree to produce the machine code or whatever as its
output.</p>
<p>So far this sounds a lot like what I described for Clojure. However,
in most languages the AST’s data structure is inaccessible within the
programming language; the programming language space and the compiler
space are forever separated, and never the twain shall meet. <a
href="#text_part0018.html_ch7fig1" class="calibre4">Figure 7-1</a> shows
how you might visualize the compilation process for an expression in a
non-Lisp programming language.</p>
<div class="image">
<img src="images_00046.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0018.html_ch7fig1"
class="calibre4"></span><em>Figure 7-1: Evaluation in a non-Lisp
programming language</em></p>
<p>But Clojure is different, because Clojure is a Lisp and Lisps are
hotter than a stolen tamale. Instead of evaluating an AST that’s
represented as some inaccessible internal data structure, Lisps evaluate
native data structures. Clojure still evaluates tree structures, but the
trees are structured using Clojure lists and the nodes are Clojure
values.</p>
<p>Lists are ideal for constructing tree structures. The first element
of a list is treated as the root, and each subsequent element is treated
as a branch. To create a nested tree, you can just use nested lists, as
shown in <a href="#text_part0018.html_ch7fig2" class="calibre4">Figure
7-2</a>.</p>
<div class="image">
<span id="text_part0018.html_page_150" class="calibre4"></span><img
src="images_00047.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0018.html_ch7fig2"
class="calibre4"></span><em>Figure 7-2: Lists can easily be treated as
trees.</em></p>
<p>First, Clojure’s <em>reader</em> converts the text <span
class="literal1">(+ 1 (* 6 7))</span> into a nested list. (You’ll learn
more about the reader in the next section.) Then, Clojure’s evaluator
takes that data as input and produces a result. (It also compiles Java
Virtual Machine (JVM) bytecode, which you’ll learn about in <a
href="#text_part0024.html_ch12" class="calibre4">Chapter 12</a>. For
now, we’ll just focus on the evaluation model on a conceptual
level.)</p>
<p>With this in mind, <a href="#text_part0018.html_ch7fig3"
class="calibre4">Figure 7-3</a> shows what Clojure’s evaluation process
looks like.</p>
<div class="sidebar">
<p><strong>S-EXPRESSIONS</strong></p>
<p>In your Lisp adventures, you’ll come across resources that explain
that Lisps evaluate <em>s-expressions</em>. I avoid that term here
because it’s ambiguous: you’ll see it used to refer to both the actual
data object that gets evaluated and the source code that represents that
data. Using the same term for two different components of Lisp
evaluation (code and data) obscures what’s important: your text
represents native data structures, and Lisps evaluate native data
structures, which is unique and awesome. For a great treatment of
s-expressions, check out <em><a
href="http://www.gigamonkeys.com/book/syntax-and-semantics.html"
class="calibre16">http://www.gigamonkeys.com/book/syntax-and-semantics.html</a></em>.</p>
</div>
<div class="image">
<span id="text_part0018.html_page_151" class="calibre4"></span><img
src="images_00048.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0018.html_ch7fig3"
class="calibre4"></span><em>Figure 7-3: Evaluation in Clojure</em></p>
<p>However, the evaluator doesn’t actually care where its input comes
from; it doesn’t have to come from the reader. As a result, you can send
your program’s data structures directly to the Clojure evaluator with
<span class="literal1">eval</span>. Behold!</p>
<pre class="programs"><code>(def addition-list (list + 1 2))
(eval addition-list)
; =&gt; 3</code></pre>
<p>That’s right, baby! Your program just evaluated a Clojure list.
You’ll read all about Clojure’s evaluation rules soon, but briefly, this
is what happened: when Clojure evaluated the list, it looked up the list
that <span class="literal1">addition-list</span> refers to; then it
looked up the function corresponding to the <span
class="literal1">+</span> symbol; and then it called that function with
<span class="literal1">1</span> and <span class="literal1">2</span> as
arguments, returning <span class="literal1">3</span>. The data
structures of your running program and those <span
id="text_part0018.html_page_152" class="calibre4"></span>of the
evaluator live in the same space, and the upshot is that you can use the
full power of Clojure and all the code you’ve written to construct data
structures for evaluation:</p>
<pre class="programs"><code>(eval (concat addition-list [10]))
; =&gt; 13


(eval (list &#39;def &#39;lucky-number (concat addition-list [10])))
; =&gt; #&#39;user/lucky-number


lucky-number
; =&gt; 13</code></pre>
<p><a href="#text_part0018.html_ch7fig4" class="calibre4">Figure 7-4</a>
shows the lists you sent to the evaluator in these two examples.</p>
<div class="image">
<img src="images_00049.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0018.html_ch7fig4"
class="calibre4"></span><em>Figure 7-4: The lists you evaluated</em></p>
<p>Your program can talk directly to its own evaluator, using its own
functions and data to modify itself as it runs! Are you going mad with
power yet? I hope so! Hold on to some of your sanity, though, because
there’s still more to learn.</p>
<p>So Clojure is homoiconic: it represents abstract syntax trees using
lists, and you write textual representations of lists when you write
Clojure code. Because the code you write represents data structures that
you’re used to manipulating and the evaluator consumes those data
structures, it’s easy to reason about how to programmatically modify
your program.</p>
<p>Macros are what allow you to perform those manipulations easily. The
rest of this chapter covers Clojure’s reader and evaluation rules in
detail to give you a precise understanding of how macros work.</p>
<h3 class="h2" id="text_part0018.html_ch07lev1sec2"><span
id="text_part0018.html_page_153" class="calibre1"></span><strong>The
Reader</strong></h3>
<p>The reader converts the textual source code you save in a file or
enter in the REPL into Clojure data structures. It’s like a translator
between the human world of Unicode characters and Clojure’s world of
lists, vectors, maps, symbols, and other data structures. In this
section, you’ll interact directly with the reader and learn how a handy
feature, the <em>reader macro</em>, lets you write code more
succinctly.</p>
<h4 class="h2"
id="text_part0018.html_ch07lev2sec1"><em><strong>Reading</strong></em></h4>
<p>To understand reading, let’s first take a close look at how Clojure
handles the text you type in the REPL. First, the REPL prompts you for
text:</p>
<pre class="programs"><code>user=&gt;</code></pre>
<p>Then you enter a bit of text. Maybe something like this:</p>
<pre class="programs"><code>user=&gt; (str &quot;To understand what recursion is,&quot; &quot; you must first understand recursion.&quot;)</code></pre>
<p>That text is really just a sequence of Unicode characters, but it’s
meant to represent a combination of Clojure data structures. This
textual representation of data structures is called a <em>reader
form</em>. In this example, the form represents a list data structure
that contains three more forms: the <span class="literal1">str</span>
symbol and two strings.</p>
<p>Once you type those characters into the prompt and press <span
class="small">ENTER</span>, that text goes to the reader (remember REPL
stands for read-eval-print-loop). Clojure reads the stream of characters
and internally produces the corresponding data structures. It then
evaluates the data structures and prints the textual representation of
the result:</p>
<pre class="programs"><code>&quot;To understand what recursion is, you must first understand recursion.&quot;</code></pre>
<p>Reading and evaluation are discrete processes that you can perform
independently. One way to interact with the reader directly is by using
the <span class="literal1">read-string</span> function. <span
class="literal1">read-string</span> takes a string as an argument and
processes it using Clojure’s reader, returning a data structure:</p>
<pre class="programs"><code>(read-string &quot;(+ 1 2)&quot;)
; =&gt; (+ 1 2)


(list? (read-string &quot;(+ 1 2)&quot;))
; =&gt; true


(conj (read-string &quot;(+ 1 2)&quot;) :zagglewag)
; =&gt; (:zagglewag + 1 2)</code></pre>
<p>In the first example, <span class="literal1">read-string</span> reads
the string representation of a list containing a plus symbol and the
numbers 1 and 2. The return value is an actual list, as proven by the
second example. The last example uses <span class="literal1">conj</span>
to <span id="text_part0018.html_page_154"
class="calibre4"></span>prepend a keyword to the list. The takeaway is
that reading and evaluating are independent of each other. You can read
text without evaluating it, and you can pass the result to other
functions. You can also evaluate the result, if you want:</p>
<pre class="programs"><code>(eval (read-string &quot;(+ 1 2)&quot;))
; =&gt; 3</code></pre>
<p>In all the examples so far, there’s been a one-to-one relationship
between the reader form and the corresponding data structures. Here are
more examples of simple reader forms that directly map to the data
structures they represent:</p>
<p><span class="literal1"><strong>()</strong></span> A list reader
form</p>
<p><span class="literal1"><strong>str</strong></span> A symbol reader
form</p>
<p><span class="literal1"><strong>[1 2]</strong></span> A vector reader
form containing two number reader forms</p>
<p><span class="literal1"><strong>{:sound "hoot"}</strong></span> A map
reader form with a keyword reader form and string reader form</p>
<p>However, the reader can employ more complex behavior when converting
text to data structures. For example, remember anonymous functions?</p>
<pre class="programs"><code>(#(+ 1 %) 3)
; =&gt; 4</code></pre>
<p>Well, try this out:</p>
<pre class="programs"><code>(read-string &quot;#(+ 1 %)&quot;)
; =&gt; (fn* [p1__423#] (+ 1 p1__423#))</code></pre>
<p>Whoa! This is not the one-to-one mapping that we’re used to. Reading
<span class="literal1">#(+ 1 %)</span> somehow resulted in a list
consisting of the <span class="literal1">fn*</span> symbol, a vector
containing a symbol, and a list containing three elements. What just
happened?</p>
<h4 class="h2" id="text_part0018.html_ch07lev2sec2"><em><strong>Reader
Macros</strong></em></h4>
<p>I’ll answer my own question: the reader used a <em>reader macro</em>
to transform <span class="literal1">#(+ 1 %)</span>. Reader macros are
sets of rules for transforming text into data structures. They often
allow you to represent data structures in more compact ways because they
take an abbreviated reader form and expand it into a full form. They’re
designated by <em>macro characters</em>, like <span
class="literal1">'</span> (the single quote), <span
class="literal1">#</span>, and <span class="literal1">@</span>. They’re
also completely different from the macros we’ll get to later. So as not
to get the two confused, I’ll always refer to reader macros using the
full term <em>reader macros</em>.</p>
<p>For example, you can see how the quote reader macro expands the
single quote character here:</p>
<pre class="programs"><code>(read-string &quot;&#39;(a b c)&quot;)
; =&gt; (quote (a b c))</code></pre>
<p><span id="text_part0018.html_page_155" class="calibre4"></span>When
the reader encounters the single quote, it expands it to a list whose
first member is the symbol <span class="literal1">quote</span> and whose
second member is the data structure that followed the single quote. The
<span class="literal1">deref</span> reader macro works similarly for the
<span class="literal1">@</span> character:</p>
<pre class="programs"><code>(read-string &quot;@var&quot;)
; =&gt; (clojure.core/deref var)</code></pre>
<p>Reader macros can also do crazy stuff like cause text to be ignored.
The semicolon designates the single-line comment reader macro:</p>
<pre class="programs"><code>(read-string &quot;; ignore!\n(+ 1 2)&quot;)
; =&gt; (+ 1 2)</code></pre>
<p>And that’s the reader! Your humble companion, toiling away at
transforming text into data structures. Now let’s look at how Clojure
evaluates those data structures.</p>
<h3 class="h2" id="text_part0018.html_ch07lev1sec3"><strong>The
Evaluator</strong></h3>
<p>You can think of Clojure’s evaluator as a function that takes a data
structure as an argument, processes the data structure using rules
corresponding to the data structure’s type, and returns a result. To
evaluate a symbol, Clojure looks up what the symbol refers to. To
evaluate a list, Clojure looks at the first element of the list and
calls a function, macro, or special form. Any other values (including
strings, numbers, and keywords) simply evaluate to themselves.</p>
<p>For example, let’s say you’ve typed <span class="literal1">(+ 1
2)</span> in the REPL. <a href="#text_part0018.html_ch7fig5"
class="calibre4">Figure 7-5</a> shows a diagram of the data structure
that gets sent to the evaluator.</p>
<p>Because it’s a list, the evaluator starts by evaluating the first
element in the list. The first element is the plus symbol, and the
evaluator resolves that by returning the corresponding function. Because
the first element in the list is a function, the evaluator evaluates
each of the operands. The operands 1 and 2 evaluate to themselves
because they’re not lists or symbols. Then the evaluator calls the
addition function with 1 and 2 as the operands, and returns the
result.</p>
<div class="image">
<img src="images_00050.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0018.html_ch7fig5"
class="calibre4"></span><em>Figure 7-5: The data structure for (+ 1
2)</em></p>
<p>The rest of this section explains the evaluator’s rules for each kind
of data structure more fully. To show how the evaluator works, we’ll
just run each example in the REPL. Keep in mind that the REPL first
reads your text to get a data structure, then sends that data structure
to the evaluator, and then prints the result as text.</p>
<div class="sidebar">
<p><span id="text_part0018.html_page_156"
class="calibre17"></span><strong>DATA</strong></p>
<p>I write about how Clojure evaluates data structures in this chapter,
but that’s imprecise. Technically, <em>data structure</em> refers to
some kind of collection, like a linked list or b-tree, or whatever, but
I also use the term to refer to scalar (singular, noncollection) values
like symbols and numbers. I considered using the term <em>data
objects</em> but didn’t want to imply object-oriented programming, or
using just <em>data</em> but didn’t want to confuse that with data as a
concept. So, <em>data structure</em> it is, and if you find this
offensive, I will give you a thousand apologies, thoughtfully organized
in a Van Emde Boas tree.</p>
</div>
<h4 class="h2" id="text_part0018.html_ch07lev2sec3"><em><strong>These
Things Evaluate to Themselves</strong></em></h4>
<p>Whenever Clojure evaluates data structures that aren’t a list or
symbol, the result is the data structure itself:</p>
<pre class="programs"><code>true
; =&gt; true


false
; =&gt; false


{}
; =&gt; {}


:huzzah
; =&gt; :huzzah</code></pre>
<p>Empty lists evaluate to themselves, too:</p>
<pre class="programs"><code>()
; =&gt; ()</code></pre>
<h4 class="h2"
id="text_part0018.html_ch07lev2sec4"><em><strong>Symbols</strong></em></h4>
<p>One of your fundamental tasks as a programmer is creating
abstractions by associating names with values. You learned how to do
this in <a href="#text_part0014.html_ch03" class="calibre4">Chapter
3</a> by using <span class="literal1">def</span>, <span
class="literal1">let</span>, and function definitions. Clojure uses
<em>symbols</em> to name functions, macros, data, and anything else you
can use, and evaluates them by <em>resolving</em> them. To resolve a
symbol, Clojure traverses any bindings you’ve created and then looks up
the symbol’s entry in a namespace mapping, which you learned about in <a
href="#text_part0017.html_ch06" class="calibre4">Chapter 6</a>.
Ultimately, a symbol resolves to either a <em>value</em> or a
<em>special form</em>—a built-in Clojure operator that provides
fundamental behavior.</p>
<p><span id="text_part0018.html_page_157" class="calibre4"></span>In
general, Clojure resolves a symbol by:</p>
<p>1. Looking up whether the symbol names a special form. If it doesn’t
. . .</p>
<p>2. Looking up whether the symbol corresponds to a local binding. If
it doesn’t . . .</p>
<p>3. Trying to find a namespace mapping introduced by <span
class="literal1">def</span>. If it doesn’t . . .</p>
<p>4. Throwing an exception</p>
<p>Let’s first look at a symbol resolving to a special form. Special
forms, like <span class="literal1">if</span>, are always used in the
context of an operation; they’re always the first element in a list:</p>
<pre class="programs"><code>(if true :a :b)
; =&gt; :a</code></pre>
<p>In this case, <span class="literal1">if</span> is a special form and
it’s being used as an operator. If you try to refer to a special form
outside of this context, you’ll get an exception:</p>
<pre class="programs"><code>if
; =&gt; CompilerException java.lang.RuntimeException: Unable to resolve symbol:
if in this context, compiling:(NO_SOURCE_PATH:0:0)</code></pre>
<p>Next, let’s evaluate some local bindings. A <em>local binding</em> is
any association between a symbol and a value that wasn’t created by
<span class="literal1">def</span>. In the next example, the symbol <span
class="literal1">x</span> is bound to 5 using <span
class="literal1">let</span>. When the evaluator resolves <span
class="literal1">x</span>, it resolves the <em>symbol</em> <span
class="literal1">x</span> to the <em>value</em> 5:</p>
<pre class="programs"><code>(let [x 5]
  (+ x 3))
; =&gt; 8</code></pre>
<p>Now if we create a namespace mapping of <span
class="literal1">x</span> to 15, Clojure resolves it accordingly:</p>
<pre class="programs"><code>(def x 15)
(+ x 3)
; =&gt; 18</code></pre>
<p>In the next example, <span class="literal1">x</span> is mapped to 15,
but we introduce a local binding of <span class="literal1">x</span> to 5
using <span class="literal1">let</span>. So <span
class="literal1">x</span> is resolved to 5:</p>
<pre class="programs"><code>(def x 15)
(let [x 5]
  (+ x 3))
; =&gt; 8</code></pre>
<p><span id="text_part0018.html_page_158" class="calibre4"></span>You
can nest bindings, in which case the most recently defined binding takes
precedence:</p>
<pre class="programs"><code>(let [x 5]
  (let [x 6]
    (+ x 3)))
; =&gt; 9</code></pre>
<p>Functions also create local bindings, binding parameters to arguments
within the function body. In this next example, <span
class="literal1">exclaim</span> is mapped to a function. Within the
function body, the parameter name <span
class="literal1">exclamation</span> is bound to the argument passed to
the function:</p>
<pre class="programs"><code>(defn exclaim
  [exclamation]
  (str exclamation &quot;!&quot;))


(exclaim &quot;Hadoken&quot;)
; =&gt; &quot;Hadoken!&quot;</code></pre>
<p>Finally, in this last example, <span class="literal1">map</span> and
<span class="literal1">inc</span> both refer to functions:</p>
<pre class="programs"><code>(map inc [1 2 3])
; =&gt; (2 3 4)</code></pre>
<p>When Clojure evaluates this code, it first evaluates the <span
class="literal1">map</span> symbol, looking up the corresponding
function and applying it to its arguments. The symbol <span
class="literal1">map</span> refers to the map function, but it shouldn’t
be confused with the function itself. The <span
class="literal1">map</span> symbol is still a data structure, the same
way that the string <span class="literal1">"fried salad"</span> is a
data structure, but it’s not the same as the function itself:</p>
<pre class="programs"><code>(read-string (&quot;+&quot;))
; =&gt; +


(type (read-string &quot;+&quot;))
; =&gt; clojure.lang.Symbol


(list (read-string &quot;+&quot;) 1 2)
; =&gt; (+ 1 2)</code></pre>
<p>In these examples, you’re interacting with the plus symbol, <span
class="literal1">+</span>, as a data structure. You’re not interacting
with the addition function that it refers to. If you evaluate it,
Clojure looks up the function and applies it:</p>
<pre class="programs"><code>(eval (list (read-string &quot;+&quot;) 1 2))
; =&gt; 3</code></pre>
<p>On their own, symbols and their referents don’t actually do anything;
Clojure performs work by evaluating lists.</p>
<h4 class="h2" id="text_part0018.html_ch07lev2sec5"><span
id="text_part0018.html_page_159"
class="calibre1"></span><em><strong>Lists</strong></em></h4>
<p>If the data structure is an empty list, it evaluates to an empty
list:</p>
<pre class="programs"><code>(eval (read-string &quot;()&quot;))
; =&gt; ()</code></pre>
<p>Otherwise, it is evaluated as a <em>call</em> to the first element in
the list. The way the call is performed depends on the nature of that
first element.</p>
<h5 class="h3" id="text_part0018.html_ch07lev3sec1"><strong>Function
Calls</strong></h5>
<p>When performing a function call, each operand is fully evaluated and
then passed to the function as an argument. In this example, the <span
class="literal1">+</span> symbol resolves to a function:</p>
<pre class="programs"><code>(+ 1 2)
; =&gt; 3</code></pre>
<p>Clojure sees that the list’s head is a function, so it proceeds to
evaluate the rest of the elements in the list. The operands 1 and 2 both
evaluate to themselves, and after they’re evaluated, Clojure applies the
addition function to them.</p>
<p>You can also nest function calls:</p>
<pre class="programs"><code>(+ 1 (+ 2 3))
; =&gt; 6</code></pre>
<p>Even though the second argument is a list, Clojure follows the same
process here: look up the <span class="literal1">+</span> symbol and
evaluate each argument. To evaluate the list <span class="literal1">(+ 2
3)</span>, Clojure resolves the first member to the addition function
and proceeds to evaluate each of the arguments. In this way, evaluation
is recursive.</p>
<h5 class="h3" id="text_part0018.html_ch07lev3sec2"><strong>Special
Forms</strong></h5>
<p>You can also call <em>special forms.</em> In general, special forms
are special because they implement core behavior that can’t be
implemented with functions. For example:</p>
<pre class="programs"><code>(if true 1 2)
; =&gt; 1</code></pre>
<p>Here, we ask Clojure to evaluate a list beginning with the symbol
<span class="literal1">if</span>. That <span class="literal1">if</span>
symbol gets resolved to the <span class="literal1">if</span> special
form, and Clojure calls that special form with the operands <span
class="literal1">true</span>, <span class="literal1">1</span>, and <span
class="literal1">2</span>.</p>
<p>Special forms don’t follow the same evaluation rules as normal
functions. For example, when you call a function, each operand gets
evaluated. <span id="text_part0018.html_page_160"
class="calibre4"></span>However, with <span class="literal1">if</span>
you don’t want each operand to be evaluated. You only want certain
operands to be evaluated, depending on whether the condition is true or
false.</p>
<p>Another important special form is <span
class="literal1">quote</span>. You’ve seen lists represented like
this:</p>
<pre class="programs"><code>&#39;(a b c)</code></pre>
<p>As you saw in “<a href="#text_part0018.html_ch07lev1sec2"
class="calibre4">The Reader</a>” on <a
href="#text_part0018.html_page_153" class="calibre4">page 153</a>, this
invokes a reader macro so that we end up with this:</p>
<pre class="programs"><code>(quote (a b c))</code></pre>
<p>Normally, Clojure would try to resolve the <span
class="literal1">a</span> symbol and then call it because it’s the first
element in a list. The <span class="literal1">quote</span> special form
tells the evaluator, “Instead of evaluating my next data structure like
normal, just return the data structure itself.” In this case, you end up
with a list consisting of the symbols <span class="literal1">a</span>,
<span class="literal1">b</span>, and <span
class="literal1">c</span>.</p>
<p><span class="literal1">def</span>, <span class="literal1">let</span>,
<span class="literal1">loop</span>, <span class="literal1">fn</span>,
<span class="literal1">do</span>, and <span
class="literal1">recur</span> are all special forms as well. You can see
why: they don’t get evaluated the same way as functions. For example,
normally when the evaluator evaluates a symbol, it resolves that symbol,
but <span class="literal1">def</span> and <span
class="literal1">let</span> obviously don’t behave that way. Instead of
resolving symbols, they actually create associations between symbols and
values. So the evaluator receives a combination of data structures from
the reader, and it goes about resolving the symbols and calling the
functions or special forms at the beginning of each list. But there’s
more! You can also place a <em>macro</em> at the beginning of a list
instead of a function or a special form, and this can give you
tremendous power over how the rest of the data structures are
evaluated.</p>
<h4 class="h2"
id="text_part0018.html_ch07lev2sec6"><em><strong>Macros</strong></em></h4>
<p>Hmm . . . Clojure evaluates data structures—the same data structures
that we write and manipulate in our Clojure programs. Wouldn’t it be
awesome if we could use Clojure to manipulate the data structures that
Clojure evaluates? Yes, yes it would! And guess what? You can do this
with macros! Did your head just explode? Mine did!</p>
<p>To get an idea of what macros do, let’s look at some code. Say we
want to write a function that makes Clojure read infix notation (such as
<span class="literal1">1 + 1</span>) instead of its normal notation with
the operator first (<span class="literal1">+ 1 1</span>). This example
is <em>not</em> a macro. Rather, it merely shows that you can write code
using infix notation and then use Clojure to transform it so it will
actually execute. First, create a list that represents infix
addition:</p>
<pre class="programs"><code>(read-string &quot;(1 + 1)&quot;)
; =&gt; (1 + 1)</code></pre>
<p><span id="text_part0018.html_page_161"
class="calibre4"></span>Clojure will throw an exception if you try to
make it evaluate this list:</p>
<pre class="programs"><code>(eval (read-string &quot;(1 + 1)&quot;))
; =&gt; ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn</code></pre>
<p>However, <span class="literal1">read-string</span> returns a list,
and you can use Clojure to reorganize that list into something it
<em>can</em> successfully evaluate:</p>
<pre class="programs"><code>(let [infix (read-string &quot;(1 + 1)&quot;)]
  (list (second infix) (first infix) (last infix)))
; =&gt; (+ 1 1)</code></pre>
<p>If you <span class="literal1">eval</span> this, it returns <span
class="literal1">2</span>, just as you’d expect:</p>
<pre class="programs"><code>(eval
 (let [infix (read-string &quot;(1 + 1)&quot;)]
  (list (second infix) (first infix) (last infix))))
; =&gt; 2</code></pre>
<p>This is cool, but it’s also quite clunky. That’s where macros come
in. Macros give you a convenient way to manipulate lists before Clojure
evaluates them. Macros are a lot like functions: they take arguments and
return a value, just like a function would. They work on Clojure data
structures, just like functions do. What makes them unique and powerful
is the way they fit in to the evaluation process. They are executed in
between the reader and the evaluator—so they can manipulate the data
structures that the reader spits out and transform with those data
structures before passing them to the evaluator.</p>
<p>Let’s look at an example:</p>
<pre class="programs"><code>   (defmacro ignore-last-operand
     [function-call]
     (butlast function-call))


➊ (ignore-last-operand (+ 1 2 10))
   ; =&gt; 3


   ;; This will not print anything
   (ignore-last-operand (+ 1 2 (println &quot;look at me!!!&quot;)))
   ; =&gt; 3</code></pre>
<p>At <span class="ent">➊</span> the macro <span
class="literal1">ignore-last-operand</span> receives the list <span
class="literal1">(+ 1 2 10)</span> as its argument, <em>not</em> the
value <span class="literal1">13</span>. This is very different from a
function call, because function calls always evaluate all of the
arguments passed in, so there is no possible way for a function to reach
into one of its operands and alter or ignore it. By contrast, when you
call a macro, the operands are <em>not</em> evaluated. In particular,
symbols are not resolved; they are passed as symbols. Lists are not
evaluated either; that is, the first element in the list is not called
as a function, special form, or macro. Rather, the unevaluated list data
structure is passed in.</p>
<p><span id="text_part0018.html_page_162"
class="calibre4"></span>Another difference is that the data structure
returned by a function is <em>not</em> evaluated, but the data structure
returned by a macro <em>is</em>. The process of determining the return
value of a macro is called <em>macro expansion</em>, and you can use the
function <span class="literal1">macroexpand</span> to see what data
structure a macro returns before that data structure is evaluated. Note
that you have to quote the form that you pass to <span
class="literal1">macroexpand</span>:</p>
<pre class="programs"><code>(macroexpand &#39;(ignore-last-operand (+ 1 2 10)))
; =&gt; (+ 1 2)


(macroexpand &#39;(ignore-last-operand (+ 1 2 (println &quot;look at me!!!&quot;))))
; =&gt; (+ 1 2)</code></pre>
<div class="image">
<img src="images_00051.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0018.html_ch7fig6"
class="calibre4"></span><em>Figure 7-6: The full evaluation process for
(infix (1 + 2))</em></p>
<p>As you can see, both expansions result in the list <span
class="literal1">(+ 1 2)</span>. When this list is evaluated, as in the
previous example, the result is <span class="literal1">3</span>.</p>
<p>Just for fun, here’s a macro for doing simple infix notation:</p>
<pre class="programs"><code>(defmacro infix
  [infixed]
  (list (second infixed)
        (first infixed)
        (last infixed)))


(infix (1 + 2))
; =&gt; 3</code></pre>
<p>The best way to think about this whole process is to picture a phase
between reading and evaluation: the <em>macro expansion</em> phase. <a
href="#text_part0018.html_ch7fig6" class="calibre4">Figure 7-6</a> shows
how you can visualize the entire evaluation process for <span
class="literal1">(infix (1 + 2))</span>.</p>
<p>And that’s how macros fit into the evaluation process. But why would
you want to do this? The reason is that macros allow you to transform an
arbitrary data structure like <span class="literal1">(1 + 2)</span> into
one that can Clojure can evaluate, <span class="literal1">(+ 1
2)</span>. That means <em>you can use Clojure to extend itself</em> so
you can write programs however you please. In other words, macros enable
<em>syntactic abstraction</em>. Syntactic abstraction may sound a bit
abstract (ha ha!), so let’s explore that a little.</p>
<h4 class="h2" id="text_part0018.html_ch07lev2sec7"><span
id="text_part0018.html_page_163"
class="calibre1"></span><em><strong>Syntactic Abstraction and the -&gt;
Macro</strong></em></h4>
<p>Often, Clojure code consists of a bunch of nested function calls. For
example, I use the following function in one of my projects:</p>
<pre class="programs"><code>(defn read-resource
  &quot;Read a resource into a string&quot;
  [path]
  (read-string (slurp (clojure.java.io/resource path))))</code></pre>
<p>To understand the function body, you have to find the innermost form,
in this case <span class="literal1">(clojure.java.io/resource
path)</span>, and then work your way outward from right to left to see
how the result of each function gets passed to another function. This
right-to-left flow is opposite of what non-Lisp programmers are used to.
As you get used to writing in Clojure, this kind of code gets easier and
easier to understand. But if you want to translate Clojure code so you
can read it in a more familiar, left-to-right, top-to-bottom manner, you
can use the built-in <span class="literal1">-&gt;</span> macro, which is
also known as the <em>threading</em> or <em>stabby</em> macro. It lets
you rewrite the preceding function like this:</p>
<pre class="programs"><code>(defn read-resource
  [path]
  (-&gt; path
      clojure.java.io/resource
      slurp
      read-string))</code></pre>
<p>You can read this as a pipeline that goes from top to bottom instead
of from inner parentheses to outer parentheses. First, <span
class="literal1">path</span> gets passed to <span
class="literal1">io/resource</span>, then the result gets passed to
<span class="literal1">slurp</span>, and finally the result of that gets
passed to <span class="literal1">read-string</span>.</p>
<p>These two ways of defining <span
class="literal1">read-resource</span> are entirely equivalent. However,
the second one might be easier understand because we can approach it
from top to bottom, a direction we’re used to. The <span
class="literal1">-&gt;</span> also lets us omit parentheses, which means
there’s less visual noise to contend with. This is a <em>syntactic
abstraction</em> because it lets you write code in a syntax that’s
different from Clojure’s built-in syntax but is preferable for human
consumption. Better than lead into gold!!!</p>
<h3 class="h2" id="text_part0018.html_ch07lev1sec4"><span
id="text_part0018.html_page_164"
class="calibre1"></span><strong>Summary</strong></h3>
<p>In this chapter, you learned about Clojure’s evaluation process.
First, the reader transforms text into Clojure data structures. Next,
the macro expander transforms those data structures with macros,
converting your custom syntax into syntactically valid data structures.
Finally, those data structures get sent to the evaluator. The evaluator
processes data structures based on their type: symbols are resolved to
their referents; lists result in function, macro, or special form calls;
and everything else evaluates to itself.</p>
<p>The coolest thing about this process is that it allows you to use
Clojure to expand its own syntax. This process is made easier because
Clojure is homoiconic: its text represents data structures, and those
data structures represent abstract syntax trees, allowing you to more
easily reason about how to construct syntax-expanding macros.</p>
<p>With all these new concepts in your brainacles, you’re now ready to
blow stuff up on purpose, just like I promised. The next chapter will
teach you everything you need to know about writing macros. Hold on to
your socks or they’re liable to get knocked off!</p>
<h3 class="h2" id="text_part0018.html_ch07lev1sec5"><strong><span
class="bordera">Exercises</span></strong></h3>
<p>These exercises focus on reading and evaluation. <a
href="#text_part0019.html_ch08" class="calibre4">Chapter 8</a> has
exercises for writing macros.</p>
<p>1. Use the <span class="literal1">list</span> function, quoting, and
<span class="literal1">read-string</span> to create a list that, when
evaluated, prints your first name and your favorite sci-fi movie.</p>
<p>2. Create an infix function that takes a list like <span
class="literal1">(1 + 3 * 4 - 5)</span> and transforms it into the lists
that Clojure needs in order to correctly evaluate the expression using
operator precedence rules.</p>
<p><span id="text_part0019.html"></span></p>
<h2 class="h1" id="text_part0019.html_ch08"><span
id="text_part0019.html_page_165" class="calibre1"></span><strong><span
class="big1">8</span></strong><br />
<strong>Writing Macros</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>When I was 18, I got a job as a night auditor at a hotel in Santa Fe,
New Mexico, working four nights a week from 11 <span
class="small">PM</span> till 7 <span class="small">AM</span>. After a
few months of this sleepless schedule, my emotions took on a life of
their own. One night, at about 3 <span class="small">AM</span>, I was
watching an infomercial for a product claiming to restore men’s hair. As
I watched the story of a formerly bald individual, I became overwhelmed
with sincere joy. “At last!” my brain gushed. “This man has gotten the
love and success he deserves! What an incredible product, giving hope to
the hopeless!”</p>
<p>Since then I’ve found myself wondering if I could somehow re-create
the emotional abandon and appreciation for life induced by chronic sleep
deprivation. Some kind of potion, perhaps—a couple quaffs to unleash my
inner Richard Simmons, but not for too long.</p>
<p>Just as a potion would allow me to temporarily alter my fundamental
nature, macros allow you to modify Clojure in ways that just aren’t
possible with other languages. With macros, you can extend Clojure to
suit your problem space, building up the language.</p>
<p><span id="text_part0019.html_page_166" class="calibre4"></span>In
this chapter, you’ll thoroughly examine how to write macros, starting
with basic examples and moving up in complexity. You’ll close by donning
your make-believe cap and using macros to validate customer orders in
your imaginary online potion store.</p>
<p>By the end of the chapter, you’ll understand all the tools you’ll use
to write macros: quote, syntax quote, unquote, unquote splicing (aka the
piñata tool), and gensym. You’ll also learn about the dangers lying in
wait for unsuspecting macro authors: double evaluation, variable
capture, and macro infection.</p>
<div class="image">
<img src="images_00052.jpeg" class="calibre3" alt="image" />
</div>
<h3 class="h2" id="text_part0019.html_ch08lev1sec1"><strong>Macros Are
Essential</strong></h3>
<p>Before you start writing macros, I want to help you put them in the
proper context. Yes, macros are cooler than a polar bear’s toenails, but
you shouldn’t think of macros as some esoteric tool you pull out when
you feel like getting extra fancy with your code. In fact, macros allow
Clojure to derive a lot of its built-in functionality from a tiny core
of functions and special forms. Take <span class="literal1">when</span>,
for example. <span class="literal1">when</span> has this general
form:</p>
<pre class="programs"><code>(when boolean-expression
  expression-1
  expression-2
  expression-3
  ...
  expression-x)</code></pre>
<p>You might think that <span class="literal1">when</span> is a special
form like <span class="literal1">if</span>. Well guess what? It’s not!
In most other languages, you can only create conditional expressions
using special keywords, and there’s no way to create your own
conditional operators. However, <span class="literal1">when</span> is
actually a macro.</p>
<p>In this macro expansion, you can see that <span
class="literal1">when</span> is implemented in terms of <span
class="literal1">if</span> and <span class="literal1">do</span>:</p>
<pre class="programs"><code>(macroexpand &#39;(when boolean-expression
                expression-1
                expression-2
                expression-3))
; =&gt; (if boolean-expression
       (do expression-1
           expression-2
           expression-3))</code></pre>
<p><span id="text_part0019.html_page_167" class="calibre4"></span>This
shows that macros are an integral part of Clojure development—they’re
even used to provide fundamental operations. Macros aren’t reserved for
exotic special cases; you should think of macro writing as just another
tool in your tool satchel. As you learn to write your own macros, you’ll
see how they allow you to extend the language even further so that it
fits the shape of your particular problem domain.</p>
<h3 class="h2" id="text_part0019.html_ch08lev1sec2"><strong>Anatomy of a
Macro</strong></h3>
<p>Macro definitions look much like function definitions. They have a
name, an optional document string, an argument list, and a body. The
body will almost always return a list. This makes sense because macros
are a way of transforming a data structure into a form Clojure can
evaluate, and Clojure uses lists to represent function calls, special
form calls, and macro calls. You can use any function, macro, or special
form within the macro body, and you call macros just like you would a
function or special form.</p>
<p>As an example, here’s our old friend the <span
class="literal1">infix</span> macro:</p>
<pre class="programs"><code>(defmacro infix
  &quot;Use this macro when you pine for the notation of your childhood&quot;
  [infixed]
  (list (second infixed) (first infixed) (last infixed)))</code></pre>
<p>This macro rearranges a list into the correct order for infix
notation. Here’s an example:</p>
<pre class="programs"><code>(infix (1 + 1))
; =&gt; 2</code></pre>
<p>One key difference between functions and macros is that function
arguments are fully evaluated before they’re passed to the function,
whereas macros receive arguments as unevaluated data. You can see this
in the example. If you tried evaluating <span class="literal1">(1 +
1)</span> on its own, you would get an exception. However, because
you’re making a macro call, the unevaluated list <span
class="literal1">(1 + 1)</span> is passed to <span
class="literal1">infix</span>. Then the macro can use <span
class="literal1">first</span>, <span class="literal1">second</span>, and
<span class="literal1">last</span> to rearrange the list so Clojure can
evaluate it:</p>
<pre class="programs"><code>(macroexpand &#39;(infix (1 + 1)))
; =&gt; (+ 1 1)</code></pre>
<p>By expanding the macro, you can see that <span
class="literal1">infix</span> rearranges <span class="literal1">(1 +
1)</span> into <span class="literal1">(+ 1 1)</span>. Handy!</p>
<p>You can also use argument destructuring in macro definitions, just
like you can with functions:</p>
<pre class="programs"><code>(defmacro infix-2
  [[operand1 op operand2]]
  (list op operand1 operand2))</code></pre>
<p><span id="text_part0019.html_page_168"
class="calibre4"></span>Destructuring arguments lets you succinctly bind
values to symbols based on their position in a sequential argument.
Here, <span class="literal1">infix-2</span> takes a sequential data
structure as an argument and destructures by position so the first value
is named <span class="literal1">operand1</span>, the second value is
named <span class="literal1">op</span>, and the third value is named
<span class="literal1">operand2</span> within the macro.</p>
<p>You can also create multiple-arity macros, and in fact the
fundamental Boolean operations <span class="literal1">and</span> and
<span class="literal1">or</span> are defined as macros. Here’s <span
class="literal1">and</span>’s source code:</p>
<pre class="programs"><code>(defmacro and
  &quot;Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&#39;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.&quot;
  {:added &quot;1.0&quot;}
  ([] true)
  ([x] x)
  ([x &amp; next]
   `(let [and# ~x]
      (if and# (and ~@next) and#))))</code></pre>
<p>There’s a lot of stuff going on in this example, including the
symbols <span class="literal1">`</span> and <span
class="literal1">~@</span>, which you’ll learn about soon. What’s
important to realize for now is that there are three macro bodies here:
a 0-arity macro body that always returns <span
class="literal1">true</span>, a 1-arity macro body that returns the
operand, and an <em>n</em>-arity macro body that recursively calls
itself. That’s right: macros can be recursive, and they also can use
rest args (<span class="literal1">&amp; next</span> in the
<em>n</em>-arity macro body), just like functions.</p>
<p>Now that you’re comfortable with the anatomy of macros, it’s time to
strap yourself to your thinking mast Odysseus-style and learn to write
macro bodies.</p>
<h3 class="h2" id="text_part0019.html_ch08lev1sec3"><strong>Building
Lists for Evaluation</strong></h3>
<p>Macro writing is all about building a list for Clojure to evaluate,
and it requires a kind of inversion to your normal way of thinking. For
one, you’ll often need to quote expressions to get unevaluated data
structures in your final list (we’ll get back to that in a moment). More
generally, you’ll need to be extra careful about the difference between
a <em>symbol</em> and its <em>value</em>.</p>
<h4 class="h2"
id="text_part0019.html_ch08lev2sec1"><em><strong>Distinguishing Symbols
and Values</strong></em></h4>
<p>Say you want to create a macro that takes an expression and both
prints and returns its value. (This differs from <span
class="literal1">println</span> in that <span
class="literal1">println</span> always returns <span
class="literal1">nil</span>.) You want your macro to return lists that
look like this:</p>
<pre class="programs"><code>(let [result expression]
  (println result)
  result)</code></pre>
<p><span id="text_part0019.html_page_169" class="calibre4"></span>Your
first version of the macro might look like this, using the <span
class="literal1">list</span> function to create the list that Clojure
should evaluate:</p>
<pre class="programs"><code>(defmacro my-print-whoopsie
 [expression]
 (list let [result expression]
       (list println result)
       result))</code></pre>
<p>However, if you tried this, you’d get the exception <span
class="literal1">Can't take the value of a macro:
#'clojure.core/let</span>. What’s going on here?</p>
<p>The reason this happens is that your macro body tries to get the
<em>value</em> that the <em>symbol</em> <span
class="literal1">let</span> refers to, whereas what you actually want to
do is return the <span class="literal1">let</span> symbol itself. There
are other problems, too: you’re trying to get the value of <span
class="literal1">result</span>, which is unbound, and you’re trying to
get the value of <span class="literal1">println</span> instead of
returning its symbol. Here’s how you would write the macro to do what
you want:</p>
<pre class="programs"><code>(defmacro my-print
  [expression]
  (list &#39;let [&#39;result expression]
        (list &#39;println &#39;result)
        result))</code></pre>
<p>Here, you’re quoting each symbol you want to use as a symbol by
prefixing it with the single quote character, <span
class="literal1">'</span>. This tells Clojure to <em>turn off</em>
evaluation for whatever follows, in this case preventing Clojure from
trying to resolve the symbols and instead just returning the symbols.
The ability to use quoting to turn off evaluation is central to writing
macros, so let’s give the topic its own section.</p>
<h4 class="h2" id="text_part0019.html_ch08lev2sec2"><em><strong>Simple
Quoting</strong></em></h4>
<p>You’ll almost always use quoting within your macros to obtain an
unevaluated symbol. Let’s go through a brief refresher on quoting and
then see how you might use it in a macro.</p>
<p>First, here’s a simple function call with no quoting:</p>
<pre class="programs"><code>(+ 1 2)
; =&gt; 3</code></pre>
<p>If we add <span class="literal1">quote</span> at the beginning, it
returns an unevaluated data structure:</p>
<pre class="programs"><code>(quote (+ 1 2))
; =&gt; (+ 1 2)</code></pre>
<p><span id="text_part0019.html_page_170" class="calibre4"></span>Here
in the returned list, <span class="literal1">+</span> is a symbol. If we
evaluate this plus symbol, it yields the plus function:</p>
<pre class="programs"><code>+
; =&gt; #&lt;core$_PLUS_ clojure.core$_PLUS_@47b36583&gt;</code></pre>
<p>Whereas if we quote the plus symbol, it just yields the plus
symbol:</p>
<pre class="programs"><code>(quote +)
; =&gt; +</code></pre>
<p>Evaluating an unbound symbol raises an exception:</p>
<pre class="programs"><code>sweating-to-the-oldies
; =&gt; Unable to resolve symbol: sweating-to-the-oldies in this context</code></pre>
<p>But quoting the symbol returns a symbol regardless of whether the
symbol has a value associated with it:</p>
<pre class="programs"><code>(quote sweating-to-the-oldies)
; =&gt; sweating-to-the-oldies</code></pre>
<p>The single quote character is a reader macro for <span
class="literal1">(quote</span> <em>x</em><span
class="literal1">)</span>:</p>
<pre class="programs"><code>&#39;(+ 1 2)
; =&gt; (+ 1 2)


&#39;dr-jekyll-and-richard-simmons
; =&gt; dr-jekyll-and-richard-simmons</code></pre>
<p>You can see quoting at work in the <span class="literal1">when</span>
macro. This is <span class="literal1">when</span>’s actual source
code:</p>
<pre class="programs"><code>(defmacro when
  &quot;Evaluates test. If logical true, evaluates body in an implicit do.&quot;
  {:added &quot;1.0&quot;}
  [test &amp; body]
  (list &#39;if test (cons &#39;do body)))</code></pre>
<p>Notice that the macro definition quotes both <span
class="literal1">if</span> and <span class="literal1">do</span>. That’s
because you want these symbols to be in the final list that <span
class="literal1">when</span> returns for evaluation. Here’s an example
of what that returned list might look like:</p>
<pre class="programs"><code>(macroexpand &#39;(when (the-cows-come :home)
                (call me :pappy)
                (slap me :silly)))
; =&gt; (if (the-cows-come :home)
       (do (call me :pappy)
           (slap me :silly)))</code></pre>
<p><span id="text_part0019.html_page_171" class="calibre4"></span>Here’s
another example of source code for a built-in macro, this time for <span
class="literal1">unless</span>:</p>
<pre class="programs"><code>(defmacro unless
  &quot;Inverted &#39;if&#39;&quot;
  [test &amp; branches]
  (conj (reverse branches) test &#39;if))</code></pre>
<p>Again, you have to quote <span class="literal1">if</span> because you
want the unevaluated symbol to be placed in the resulting list, like
this one:</p>
<pre class="programs"><code>(macroexpand &#39;(unless (done-been slapped? me)
                      (slap me :silly)
                      (say &quot;I reckon that&#39;ll learn me&quot;)))
; =&gt; (if (done-been slapped? me)
       (say &quot;I reckon that&#39;ll learn me&quot;)
       (slap me :silly))</code></pre>
<p>In many cases, you’ll use simple quoting like this when writing
macros, but most often you’ll use the more powerful syntax quote.</p>
<h4 class="h2" id="text_part0019.html_ch08lev2sec3"><em><strong>Syntax
Quoting</strong></em></h4>
<p>So far, you’ve seen macros that build up lists by using the <span
class="literal1">list</span> function to create a list along with <span
class="literal1">'</span> (quote), and functions that operate on lists
like <span class="literal1">first</span>, <span
class="literal1">second</span>, <span class="literal1">last</span>, and
so on. Indeed, you could write macros that way until the cows come home.
Sometimes, though, it leads to tedious and verbose code.</p>
<p>Syntax quoting returns unevaluated data structures, similar to normal
quoting. However, there are two important differences. One difference is
that syntax quoting will return the <em>fully qualified</em> symbols
(that is, with the symbol’s namespace included). Let’s compare quoting
and syntax quoting.</p>
<p>Quoting does not include a namespace if your code doesn’t include a
namespace:</p>
<pre class="programs"><code>&#39;+
; =&gt; +</code></pre>
<p>Write out the namespace, and it’ll be returned by normal quote:</p>
<pre class="programs"><code>&#39;clojure.core/+
; =&gt; clojure.core/+</code></pre>
<p>Syntax quoting will always include the symbol’s full namespace:</p>
<pre class="programs"><code>`+
; =&gt; clojure.core/+</code></pre>
<p><span id="text_part0019.html_page_172"
class="calibre4"></span>Quoting a list recursively quotes all the
elements:</p>
<pre class="programs"><code>&#39;(+ 1 2)
; =&gt; (+ 1 2)</code></pre>
<p>Syntax quoting a list recursively syntax quotes all the elements:</p>
<pre class="programs"><code>`(+ 1 2)
; =&gt; (clojure.core/+ 1 2)</code></pre>
<p>The reason syntax quotes include the namespace is to help you avoid
name collisions, a topic covered in <a href="#text_part0017.html_ch06"
class="calibre4">Chapter 6</a>.</p>
<p>The other difference between quoting and syntax quoting is that the
latter allows you to <em>unquote</em> forms using the tilde, <span
class="literal1">~</span>. It’s kind of like kryptonite in that way:
whenever Superman is around kryptonite, his powers disappear. Whenever a
tilde appears within a syntax-quoted form, the syntax quote’s power to
return unevaluated, fully namespaced forms disappears. Here’s an
example:</p>
<pre class="programs"><code>`(+ 1 ~(inc 1))
; =&gt; (clojure.core/+ 1 2)</code></pre>
<p>Because it comes after the tilde, <span class="literal1">(inc
1)</span> is evaluated instead of being quoted. Without the unquote,
syntax quoting returns the unevaluated form with fully qualified
symbols:</p>
<pre class="programs"><code>`(+ 1 (inc 1))
; =&gt; (clojure.core/+ 1 (clojure.core/inc 1))</code></pre>
<p>If you’re familiar with string interpolation, you can think of syntax
quoting/unquoting similarly. In both cases, you’re creating a kind of
template, placing a few variables within a larger, static structure. For
example, in Ruby you can create the string <span class="literal1">"Churn
your butter, Jebediah"</span> through concatenation:</p>
<pre class="programs"><code>name = &quot;Jebediah&quot;
&quot;Churn your butter, &quot; + name + &quot;!&quot;</code></pre>
<p>or through interpolation:</p>
<pre class="programs"><code>&quot;Churn your butter, #{name}!&quot;</code></pre>
<p>In the same way that string interpolation leads to clearer and more
concise code, syntax quoting and unquoting allow you to create lists
more clearly and concisely. Compare using the <span
class="literal1">list</span> function, shown first, with using syntax
quoting:</p>
<pre class="programs"><code>(list &#39;+ 1 (inc 1))
; =&gt; (+ 1 2)
`(+ 1 ~(inc 1))
; =&gt; (clojure.core/+ 1 2)</code></pre>
<p>As you can see, the syntax-quote version is more concise. Also, its
visual form is closer to the final form of the list, making it easier to
understand.</p>
<h3 class="h2" id="text_part0019.html_ch08lev1sec4"><strong>Using Syntax
Quoting in a Macro</strong></h3>
<p>Now that you have a good handle on how syntax quoting works, take a
look at the <span class="literal1">code-critic</span> macro. You’re
going to write a more concise version using syntax quoting.</p>
<pre class="programs"><code>(defmacro code-critic
  &quot;Phrases are courtesy Hermes Conrad from Futurama&quot;
  [bad good]
  (list &#39;do
        (list &#39;println
              &quot;Great squid of Madrid, this is bad code:&quot;
              (list &#39;quote bad))
        (list &#39;println
              &quot;Sweet gorilla of Manila, this is good code:&quot;
              (list &#39;quote good))))


(code-critic (1 + 1) (+ 1 1))
; =&gt; Great squid of Madrid, this is bad code: (1 + 1)
; =&gt; Sweet gorilla of Manila, this is good code: (+ 1 1)</code></pre>
<p>Just looking at all those tedious repetitions of <span
class="literal1">list</span> and single quotes makes me cringe. But if
you rewrite <span class="literal1">code-critic</span> using syntax
quoting, you can make it sleek and concise:</p>
<pre class="programs"><code>(defmacro code-critic
  &quot;Phrases are courtesy Hermes Conrad from Futurama&quot;
  [bad good]
  `(do (println &quot;Great squid of Madrid, this is bad code:&quot;
                (quote ~bad))
       (println &quot;Sweet gorilla of Manila, this is good code:&quot;
                (quote ~good))))</code></pre>
<p>In this case, you want to quote everything except for the symbols
<span class="literal1">good</span> and <span
class="literal1">bad</span>. In the original version, you have to quote
each piece individually and explicitly place it in a list in an unwieldy
fashion, just to prevent those two symbols from being quoted. With
syntax quoting, you can just wrap the entire <span
class="literal1">do</span> expression in a quote and simply unquote the
two symbols that you want to evaluate.</p>
<p>And thus concludes the introduction to the mechanics of writing a
macro! Sweet sacred boa of Western and Eastern Samoa, that was a
lot!</p>
<p>To sum up, macros receive unevaluated, arbitrary data structures as
arguments and return data structures that Clojure evaluates. When <span
id="text_part0019.html_page_174" class="calibre4"></span>defining your
macro, you can use argument destructuring just like you can with
functions and <span class="literal1">let</span> bindings. You can also
write multiple-arity and recursive macros.</p>
<p>Most of the time, your macros will return lists. You can build up the
list to be returned by using <span class="literal1">list</span>
functions or by using syntax quoting. Syntax quoting usually leads to
code that’s clearer and more concise because it lets you create a
template of the data structure you want to return that’s easier to parse
visually. Whether you use syntax quoting or plain quoting, it’s
important to be clear about the distinction between a symbol and the
value it evaluates to when building up your list. And if you want your
macro to return multiple forms for Clojure to evaluate, make sure to
wrap them in a <span class="literal1">do</span>.</p>
<h3 class="h2" id="text_part0019.html_ch08lev1sec5"><strong>Refactoring
a Macro and Unquote Splicing</strong></h3>
<p>That <span class="literal1">code-critic</span> macro in the preceding
section could still use some improvement. Look at the duplication! The
two <span class="literal1">println</span> calls are nearly identical.
Let’s clean that up. First, let’s create a function to generate those
<span class="literal1">println</span> lists. Functions are easier to
think about and play with than macros, so it’s often a good idea to move
macro guts to helper functions:</p>
<pre class="programs"><code>(defn criticize-code
  [criticism code]
  `(println ~criticism (quote ~code)))


(defmacro code-critic
  [bad good]
  `(do ~(criticize-code &quot;Cursed bacteria of Liberia, this is bad code:&quot; bad)
       ~(criticize-code &quot;Sweet sacred boa of Western and Eastern Samoa, this
is good code:&quot; good)))</code></pre>
<p>Notice how the <span class="literal1">criticize-code</span> function
returns a syntax-quoted list. This is how you build up the list that the
macro will return.</p>
<p>There’s more room for improvement, though. The code still has
multiple, nearly identical calls to a function. In a situation like this
where you want to apply the same function to a collection of values, it
makes sense to use a seq function like <span
class="literal1">map</span>:</p>
<pre class="programs"><code>(defmacro code-critic
  [bad good]
  `(do ~(map #(apply criticize-code %)
             [[&quot;Great squid of Madrid, this is bad code:&quot; bad]
              [&quot;Sweet gorilla of Manila, this is good code:&quot; good]])))</code></pre>
<p>This is looking a little better. You’re mapping over each
criticism/code pair and applying the <span
class="literal1">criticize-code</span> function to the pair. Let’s try
to run the code:</p>
<pre class="programs"><code>(code-critic (1 + 1) (+ 1 1))
; =&gt; NullPointerException</code></pre>
<p><span id="text_part0019.html_page_175" class="calibre4"></span>Oh no!
That didn’t work at all! What happened? The problem is that <span
class="literal1">map</span> returns a list, and in this case, it
returned a list of <span class="literal1">println</span> expressions. We
just want the result of each <span class="literal1">println</span> call,
but instead, this code sticks both results in a list and then tries to
evaluate that list.</p>
<p>In other words, as it’s evaluating this code, Clojure gets to
something like this:</p>
<pre class="programs"><code>(do
 ((clojure.core/println &quot;criticism&quot; &#39;(1 + 1))
  (clojure.core/println &quot;criticism&quot; &#39;(+ 1 1))))</code></pre>
<p>then evaluates the first <span class="literal1">println</span> call
to give us this:</p>
<pre class="programs"><code>(do
 (nil
  (clojure.core/println &quot;criticism&quot; &#39;(+ 1 1))))</code></pre>
<p>and after evaluating the second <span class="literal1">println</span>
call, does this:</p>
<pre class="programs"><code>(do
 (nil nil))</code></pre>
<p>This is the cause of the exception. <span
class="literal1">println</span> evaluates to <span
class="literal1">nil</span>, so we end up with something like <span
class="literal1">(nil nil)</span>. <span class="literal1">nil</span>
isn’t callable, and we get a <span
class="literal1">NullPointerException</span>.</p>
<p>What an inconvenience! But as it happens, unquote splicing was
invented precisely to handle this kind of situation. Unquote splicing is
performed with <span class="literal1">~@</span>. If you merely unquote a
list, this is what you get:</p>
<pre class="programs"><code>`(+ ~(list 1 2 3))
; =&gt; (clojure.core/+ (1 2 3))</code></pre>
<p>However, if you use unquote splicing, this is what you get:</p>
<pre class="programs"><code>`(+ ~@(list 1 2 3))
; =&gt; (clojure.core/+ 1 2 3)</code></pre>
<p>Unquote splicing unwraps a seqable data structure, placing its
contents directly within the enclosing syntax-quoted data structure.
It’s like the <span class="literal1">~@</span> is a sledgehammer and
whatever follows it is a piñata, and the result is the most terrifying
and awesome party you’ve ever been to.</p>
<p>Anyway, if you use unquote splicing in your code critic, then
everything will work great:</p>
<pre class="programs"><code>(defmacro code-critic
  [{:keys [good bad]}]
  `(do ~@(map #(apply criticize-code %)
              [[&quot;Sweet lion of Zion, this is bad code:&quot; bad]
               [&quot;Great cow of Moscow, this is good code:&quot; good]])))
(code-critic (1 + 1) (+ 1 1))
; =&gt; Sweet lion of Zion, this is bad code: (1 + 1)
; =&gt; Great cow of Moscow, this is good code: (+ 1 1)</code></pre>
<p>Woohoo! You’ve successfully extracted repetitive code into a function
and made your macro code cleaner. Sweet guinea pig of Winnipeg, that is
good code!</p>
<h3 class="h2" id="text_part0019.html_ch08lev1sec6"><strong>Things to
Watch Out For</strong></h3>
<p>Macros have a couple of sneaky gotchas that you should be aware of.
In this section, you’ll learn about some macro pitfalls and how to avoid
them. I hope you haven’t unstrapped yourself from your thinking
mast.</p>
<h4 class="h2" id="text_part0019.html_ch08lev2sec4"><em><strong>Variable
Capture</strong></em></h4>
<p><em>Variable capture</em> occurs when a macro introduces a binding
that, unknown to the macro’s user, eclipses an existing binding. For
example, in the following code, a macro mischievously introduces its own
<span class="literal1">let</span> binding, and that messes with the
code:</p>
<pre class="programs"><code>(def message &quot;Good job!&quot;)
(defmacro with-mischief
  [&amp; stuff-to-do]
  (concat (list &#39;let [&#39;message &quot;Oh, big deal!&quot;])
          stuff-to-do))


(with-mischief
  (println &quot;Here&#39;s how I feel about that thing you did: &quot; message))
; =&gt; Here&#39;s how I feel about that thing you did: Oh, big deal!</code></pre>
<p>The <span class="literal1">println</span> call references the symbol
<span class="literal1">message</span>, which we think is bound to the
string <span class="literal1">"Good job!"</span>. However, the <span
class="literal1">with-mischief</span> macro has created a new binding
for <span class="literal1">message</span>.</p>
<p>Notice that this macro didn’t use syntax quoting. Doing so would
result in an exception:</p>
<pre class="programs"><code>(def message &quot;Good job!&quot;)
(defmacro with-mischief
  [&amp; stuff-to-do]
  `(let [message &quot;Oh, big deal!&quot;]
     ~@stuff-to-do))


(with-mischief
  (println &quot;Here&#39;s how I feel about that thing you did: &quot; message))
; Exception: Can&#39;t let qualified name: user/message</code></pre>
<p><span id="text_part0019.html_page_177" class="calibre4"></span>This
exception is for your own good: syntax quoting is designed to prevent
you from accidentally capturing variables within macros. If you want to
introduce <span class="literal1">let</span> bindings in your macro, you
can use a <em>gensym</em>. The <span class="literal1">gensym</span>
function produces unique symbols on each successive call:</p>
<pre class="programs"><code>(gensym)
; =&gt; G__655


(gensym)
; =&gt; G__658</code></pre>
<p>You can also pass a symbol prefix:</p>
<pre class="programs"><code>(gensym &#39;message)
; =&gt; message4760


(gensym &#39;message)
; =&gt; message4763</code></pre>
<p>Here’s how you could rewrite <span
class="literal1">with-mischief</span> to be less mischievous:</p>
<pre class="programs"><code>(defmacro without-mischief
  [&amp; stuff-to-do]
  (let [macro-message (gensym &#39;message)]
    `(let [~macro-message &quot;Oh, big deal!&quot;]
       ~@stuff-to-do
       (println &quot;I still need to say: &quot; ~macro-message))))


(without-mischief
  (println &quot;Here&#39;s how I feel about that thing you did: &quot; message))
; =&gt; Here&#39;s how I feel about that thing you did:  Good job!
; =&gt; I still need to say:  Oh, big deal!</code></pre>
<p>This example avoids variable capture by using <span
class="literal1">gensym</span> to create a new, unique symbol that then
gets bound to <span class="literal1">macro-message</span>. Within the
syntax-quoted <span class="literal1">let</span> expression, <span
class="literal1">macro-message</span> is unquoted, resolving to the
gensym’d symbol. This gensym’d symbol is distinct from any symbols
within <span class="literal1">stuff-to-do</span>, so you avoid variable
capture. Because this is such a common pattern, you can use an
<em>auto-gensym</em>. Auto-gensyms are more concise and convenient ways
to use gensyms:</p>
<pre class="programs"><code>`(blarg# blarg#)
(blarg__2869__auto__ blarg__2869__auto__)


`(let [name# &quot;Larry Potter&quot;] name#)
; =&gt; (clojure.core/let [name__2872__auto__ &quot;Larry Potter&quot;] name__2872__auto__)</code></pre>
<p>In this example, you create an auto-gensym by appending a hash mark
(or <em>hashtag</em>, if you must insist) to a symbol within a
syntax-quoted list. Clojure automatically ensures that each instance of
<span class="literal1"><em>x</em>#</span> resolves to the <span
id="text_part0019.html_page_178" class="calibre4"></span>same symbol
within the same syntax-quoted list, that each instance of <em><span
class="literal1">y</span></em><span class="literal1">#</span> resolves
similarly, and so on.</p>
<p><span class="literal1">gensym</span> and auto-gensym are both used
all the time when writing macros, and they allow you to avoid variable
capture.</p>
<h4 class="h2" id="text_part0019.html_ch08lev2sec5"><em><strong>Double
Evaluation</strong></em></h4>
<p>Another gotcha to watch out for when writing macros is <em>double
evaluation</em>, which occurs when a form passed to a macro as an
argument gets evaluated more than once. Consider the following:</p>
<pre class="programs"><code>(defmacro report
  [to-try]
  `(if ~to-try
     (println (quote ~to-try) &quot;was successful:&quot; ~to-try)
     (println (quote ~to-try) &quot;was not successful:&quot; ~to-try)))


;; Thread/sleep takes a number of milliseconds to sleep for
(report (do (Thread/sleep 1000) (+ 1 1)))</code></pre>
<p>This code is meant to test its argument for truthiness. If the
argument is truthy, it’s considered successful; if it’s falsey, it’s
unsuccessful. The macro prints whether or not its argument was
successful. In this case, you would actually sleep for two seconds
because <span class="literal1">(Thread/sleep 1000)</span> gets evaluated
twice: once right after <span class="literal1">if</span> and again when
<span class="literal1">println</span> gets called. This happens because
the code <span class="literal1">(do (Thread/sleep 1000) (+ 1 1))</span>
is repeated throughout the macro expansion. It’s as if you’d written
this:</p>
<pre class="programs"><code>(if (do (Thread/sleep 1000) (+ 1 1))
  (println &#39;(do (Thread/sleep 1000) (+ 1 1))
           &quot;was successful:&quot;
           (do (Thread/sleep 1000) (+ 1 1)))


  (println &#39;(do (Thread/sleep 1000) (+ 1 1))
           &quot;was not successful:&quot;
           (do (Thread/sleep 1000) (+ 1 1))))</code></pre>
<p>“Big deal!” your inner example critic says. Well, if your code did
something like transfer money between bank accounts, this would be a
very big deal. Here’s how you could avoid this problem:</p>
<pre class="programs"><code>(defmacro report
  [to-try]
  `(let [result# ~to-try]
     (if result#
       (println (quote ~to-try) &quot;was successful:&quot; result#)
       (println (quote ~to-try) &quot;was not successful:&quot; result#))))</code></pre>
<p>By placing <span class="literal1">to-try</span> in a <span
class="literal1">let</span> expression, you only evaluate that code once
and bind the result to an auto-gensym’d symbol, <span
class="literal1">result#</span>, which you can now reference without
reevaluating the <span class="literal1">to-try</span> code.</p>
<h4 class="h2" id="text_part0019.html_ch08lev2sec6"><span
id="text_part0019.html_page_179"
class="calibre1"></span><em><strong>Macros All the Way
Down</strong></em></h4>
<p>One subtle pitfall of using macros is that you can end up having to
write more and more of them to get anything done. This is a consequence
of the fact that macro expansion happens before evaluation.</p>
<p>For example, let’s say you wanted to <span
class="literal1">doseq</span> using the <span
class="literal1">report</span> macro. Instead of multiple calls to
report:</p>
<pre class="programs"><code>(report (= 1 1))
; =&gt; (= 1 1) was successful: true


(report (= 1 2))
; =&gt; (= 1 2) was not successful: false</code></pre>
<p>let’s iterate:</p>
<pre class="programs"><code>(doseq [code [&#39;(= 1 1) &#39;(= 1 2)]]
  (report code))
; =&gt; code was successful: (= 1 1)
; =&gt; code was successful: (= 1 2)</code></pre>
<p>The report macro works fine when we pass it functions individually,
but when we use <span class="literal1">doseq</span> to iterate <span
class="literal1">report</span> over multiple functions, it’s a worthless
failure. Here’s what a macro expansion for one of the <span
class="literal1">doseq</span> iterations would look like:</p>
<pre class="programs"><code>(if
 code
 (clojure.core/println &#39;code &quot;was successful:&quot; code)
 (clojure.core/println &#39;code &quot;was not successful:&quot; code))</code></pre>
<p>As you can see, <span class="literal1">report</span> receives the
unevaluated symbol <span class="literal1">code</span> in each iteration;
however, we want it to receive whatever <span
class="literal1">code</span> is bound to at evaluation time. But <span
class="literal1">report</span>, operating at macro expansion time, just
can’t access those values. It’s like it has T. rex arms, with runtime
values forever out of its reach.</p>
<p>To resolve this situation, we might write another macro, like
this:</p>
<pre class="programs"><code>(defmacro doseq-macro
  [macroname &amp; args]
  `(do
     ~@(map (fn [arg] (list macroname arg)) args)))


(doseq-macro report (= 1 1) (= 1 2))
; =&gt; (= 1 1) was successful: true
; =&gt; (= 1 2) was not successful: false</code></pre>
<p><span id="text_part0019.html_page_180" class="calibre4"></span>If you
are ever in this situation, take some time to rethink your approach.
It’s easy to paint yourself into a corner, making it impossible to
accomplish anything with run-of-the-mill function calls. You’ll be stuck
having to write more macros instead. Macros are extremely powerful and
awesome, and you shouldn’t be afraid to use them. They turn Clojure’s
facilities for working with data into facilities for creating new
languages informed by your programming problems. For some programs, it’s
appropriate for your code to be like 90 percent macros. As awesome as
they are, they also add new composition challenges. They only really
compose with each other, so by using them, you might be missing out on
the other kinds of composition (functional, object-oriented) available
to you in Clojure.</p>
<p>We’ve now covered all the mechanics of writing a macro. Pat yourself
on the back! It’s a pretty big deal!</p>
<p>To close out this chapter, it’s finally time to put on your
pretending cap and work on that online potion store I talked about at
the very beginning of the chapter.</p>
<h3 class="h2" id="text_part0019.html_ch08lev1sec7"><strong>Brews for
the Brave and True</strong></h3>
<p>At the beginning of this chapter, I revealed a dream: to find some
kind of drinkable that, once ingested, would temporarily give me the
power and temperament of an ’80s fitness guru, freeing me from a prison
of inhibition and self-awareness. I’m sure that someone somewhere will
someday invent such an elixir, so we might as well get to work on a
system for selling this mythical potion. Let’s call this hypothetical
concoction the <em>Brave and True Ale</em>. The name just came to me for
no reason whatsoever.</p>
<div class="image">
<img src="images_00053.jpeg" class="calibre3" alt="image" />
</div>
<p>Before the orders come <em>pouring</em> in (pun! high-five!), we’ll
need to have some validation in place. This section shows you a way to
do this validation functionally and how to write the code that performs
validations a bit more concisely using a macro you’ll write called <span
class="literal1">if-valid</span>. This will help you understand a
typical situation for writing your own macro. If you just want the macro
definition, it’s okay to skip ahead to “<span class="literal1"><a
href="#text_part0019.html_ch08lev2sec8"
class="calibre4">if-valid</a></span>” on <a
href="#text_part0019.html_page_182" class="calibre4">page 182</a>.</p>
<h4 class="h2"
id="text_part0019.html_ch08lev2sec7"><em><strong>Validation
Functions</strong></em></h4>
<p>To keep things simple, we’ll just worry about validating the name and
email for each order. For our store, I’m thinking we’ll want to have
those order details represented like this:</p>
<pre class="programs"><code>(def order-details
  {:name &quot;Mitchard Blimmons&quot;
   :email &quot;mitchard.blimmonsgmail.com&quot;})</code></pre>
<p><span id="text_part0019.html_page_181" class="calibre4"></span>This
particular map has an invalid email address (it’s missing the <span
class="literal1">@</span> symbol), so this is exactly the kind of order
that our validation code should catch! Ideally, we want to write code
that produces something like this:</p>
<pre class="programs"><code>(validate order-details order-details-validations)
; =&gt; {:email [&quot;Your email address doesn&#39;t look like an email address.&quot;]}</code></pre>
<p>That is, we want to be able to call a function, <span
class="literal1">validate</span>, with the data that needs validation
and a definition for how to validate it. The result should be a map
where each key corresponds to an invalid field, and each value is a
vector of one or more validation messages for that field. The following
two functions do the job.</p>
<p>Let’s look at <span class="literal1">order-details-validations</span>
first. Here’s how you could represent validations:</p>
<pre class="programs"><code>(def order-details-validations
  {:name
   [&quot;Please enter a name&quot; not-empty]


   :email
   [&quot;Please enter an email address&quot; not-empty


    &quot;Your email address doesn&#39;t look like an email address&quot;
    #(or (empty? %) (re-seq #&quot;@&quot; %))]})</code></pre>
<p>This is a map where each key is associated with a vector of error
message and validating function pairs. For example, <span
class="literal1">:name</span> has one validating function, <span
class="literal1">not-empty</span>; if that validation fails, you should
get the <span class="literal1">"Please enter a name"</span> error
message.</p>
<p>Next, we need to write out the <span class="literal1">validate</span>
function. The <span class="literal1">validate</span> function can be
decomposed into two functions: one to apply validations to a single
field and another to accumulate those error messages into a final map of
error messages like <span class="literal1">{:email ["Your email address
doesn't look like an email address."]}</span>. Here’s a function called
<span class="literal1">error-messages-for</span> that applies
validations to a single value:</p>
<pre class="programs"><code>(defn error-messages-for
  &quot;Return a seq of error messages&quot;
  [to-validate message-validator-pairs]
  (map first (filter #(not ((second %) to-validate))
                     (partition 2 message-validator-pairs))))</code></pre>
<p>The first argument, <span class="literal1">to-validate</span>, is the
field you want to validate. The second argument, <span
class="literal1">message-validator-pairs</span>, should be a seq with an
even number of elements. This seq gets grouped into pairs with <span
class="literal1">(partition 2 message-validator-pairs)</span>. The first
element of the pair should be an error message, and the second element
of the pair should be a function (just like <span
id="text_part0019.html_page_182" class="calibre4"></span>the pairs are
arranged in <span class="literal1">order-details-validation</span>). The
<span class="literal1">error-messages-for</span> function works by
filtering out all error message and validation pairs where the
validation function returns <span class="literal1">true</span> when
applied to <span class="literal1">to-validate</span>. It then uses <span
class="literal1">map first</span> to get the first element of each pair,
the error message. Here it is in action:</p>
<pre class="programs"><code>(error-messages-for &quot;&quot; [&quot;Please enter a name&quot; not-empty])
; =&gt; (&quot;Please enter a name&quot;)</code></pre>
<p>Now we need to accumulate these error messages in a map.</p>
<p>Here’s the complete <span class="literal1">validate</span> function,
as well as the output when we apply it to our <span
class="literal1">order-details</span> and <span
class="literal1">order-details-validations</span>:</p>
<pre class="programs"><code>(defn validate
  &quot;Returns a map with a vector of errors for each key&quot;
  [to-validate validations]
  (reduce (fn [errors validation]
            (let [[fieldname validation-check-groups] validation
                  value (get to-validate fieldname)
                  error-messages (error-messages-for value validation-check-groups)]
              (if (empty? error-messages)
                errors
                (assoc errors fieldname error-messages))))
          {}
          validations))


(validate order-details order-details-validations)
; =&gt; {:email (&quot;Your email address doesn&#39;t look like an email address&quot;)}</code></pre>
<p>Success! This works by reducing over <span
class="literal1">order-details-validations</span> and associating the
error messages (if there are any) for each key of <span
class="literal1">order-details</span> into a final map of error
messages.</p>
<h4 class="h2"
id="text_part0019.html_ch08lev2sec8"><em><strong>if-valid</strong></em></h4>
<p>With our validation code in place, we can now validate records to our
hearts’ content! Most often, validation will look something like
this:</p>
<pre class="programs"><code>(let [errors (validate order-details order-details-validations)]
  (if (empty? errors)
    (println :success)
    (println :failure errors)))</code></pre>
<p>The pattern is to do the following:</p>
<p>1. Validate a record and bind the result to <span
class="literal1">errors</span></p>
<p>2. Check whether there were any errors</p>
<p>3. If there were, do the success thing, here <span
class="literal1">(println :success)</span></p>
<p>4. Otherwise, do the failure thing, here <span
class="literal1">(println :failure errors)</span></p>
<p><span id="text_part0019.html_page_183" class="calibre4"></span>I’ve
actually used this validation code in real production websites. At
first, I found myself repeating minor variations of the code over and
over, a sure sign that I needed to introduce an abstraction that would
hide the repetitive parts: applying the <span
class="literal1">validate</span> function, binding the result to some
symbol, and checking whether the result is empty. To create this
abstraction, you might be tempted to write a function like this:</p>
<pre class="programs"><code>(defn if-valid
  [record validations success-code failure-code]
  (let [errors (validate record validations)]
    (if (empty? errors)
      success-code
      failure-code)))</code></pre>
<p>However, this wouldn’t work, because <span
class="literal1">success-code</span> and <span
class="literal1">failure-code</span> would get evaluated each time. A
macro would work because macros let you control evaluation. Here’s how
you’d use the macro:</p>
<pre class="programs"><code>(if-valid order-details order-details-validation errors
 (render :success)
 (render :failure errors))</code></pre>
<p>This macro hides the repetitive details and helps you express your
intention more succinctly. It’s like asking someone to give you the
bottle opener instead of saying, “Please give me the manual device for
removing the temporary sealant from a glass container of liquid.” Here’s
the implementation:</p>
<pre class="programs"><code>(defmacro if-valid
  &quot;Handle validation more concisely&quot;
  [to-validate validations errors-name &amp; then-else]
  `(let [~errors-name (validate ~to-validate ~validations)]
     (if (empty? ~errors-name)
       ~@then-else)))</code></pre>
<p>This macro takes four arguments: <span
class="literal1">to-validate</span>, <span
class="literal1">validations</span>, <span
class="literal1">errors-name</span>, and the rest argument <span
class="literal1">then-else</span>. Using <span
class="literal1">errors-name</span> like this is a new strategy. We want
to have access to the errors returned by the <span
class="literal1">validate</span> function within the <span
class="literal1">then-else</span> statements. To do this, we tell the
macro what symbol it should bind the result to. The following macro
expansion shows how this works:</p>
<pre class="programs"><code>(macroexpand
&#39;(if-valid order-details order-details-validations my-error-name
           (println :success)
           (println :failure my-error-name)))
(let*
 [my-error-name (user/validate order-details order-details-validations)]
 (if (clojure.core/empty? my-error-name)
  (println :success)
  (println :failure my-error-name)))</code></pre>
<p><span id="text_part0019.html_page_184" class="calibre4"></span>The
syntax quote abstracts the general form of the <span
class="literal1">let/validate/if</span> pattern you saw earlier. Then we
use unquote splicing to unpack the <span class="literal1">if</span>
branches, which were packed into the <span
class="literal1">then-else</span> rest argument.</p>
<p>That’s pretty simple! After all this talk about macros and going
through their mechanics in such detail, I bet you were expecting
something more complicated. Sorry, friend. If you’re having a hard time
coping with your disappointment, I know of a certain drink that will
help.</p>
<h3 class="h2"
id="text_part0019.html_ch08lev1sec8"><strong>Summary</strong></h3>
<p>In this chapter, you learned how to write your own macros. Macros are
defined very similarly to functions: they have arguments, a docstring,
and a body. They can use argument destructuring and rest args, and they
can be recursive. Your macros will almost always return lists. You’ll
sometimes use <span class="literal1">list</span> and <span
class="literal1">seq</span> functions for simple macros, but most of the
time you’ll use the syntax quote, <span class="literal1">`</span>, which
lets you write macros using a safe template.</p>
<p>When you’re writing macros, it’s important to keep in mind the
distinction between symbols and values: macros are expanded before code
is evaluated and therefore don’t have access to the results of
evaluation. Double evaluation and variable capture are two other subtle
traps for the unwary, but you can avoid them through the judicious use
of <span class="literal1">let</span> expressions and gensyms.</p>
<p>Macros are fun tools that allow you to code with fewer inhibitions.
By letting you control evaluation, macros give you a degree of freedom
and expression that other languages simply don’t allow. Throughout your
Clojure journey, you’ll probably hear people cautioning you against
their use, saying things like “Macros are evil” and “You should never
use macros.” Don’t listen to these prudes—at least, not at first! Go out
there and have a good time. That’s the only way you’ll learn the
situations where it’s appropriate to use macros. You’ll come out the
other side knowing how to use macros with skill and panache.</p>
<h3 class="h2" id="text_part0019.html_ch08lev1sec9"><strong><span
class="bordera">Exercises</span></strong></h3>
<p>1. Write the macro <span class="literal1">when-valid</span> so that
it behaves similarly to <span class="literal1">when</span>. Here is an
example of calling it:</p>
<pre class="programs1"><code>(when-valid order-details order-details-validation
 (println &quot;It&#39;s a success!&quot;)
 (render :success))</code></pre>
<p>When the data is valid, the <span class="literal1">println</span> and
<span class="literal1">render</span> forms should be evaluated, and
<span class="literal1">when-valid</span> should return <span
class="literal1">nil</span> if the data is invalid.</p>
<p>2. You saw that <span class="literal1">and</span> is implemented as a
macro. Implement <span class="literal1">or</span> as a macro.</p>
<p><span id="text_part0019.html_page_185" class="calibre4"></span>3. In
<a href="#text_part0016.html_ch05" class="calibre4">Chapter 5</a> you
created a series of functions (<span class="literal1">c-int</span>,
<span class="literal1">c-str</span>, <span
class="literal1">c-dex</span>) to read an RPG character’s attributes.
Write a macro that defines an arbitrary number of attribute-retrieving
functions using one macro call. Here’s how you would call it:</p>
<pre class="programs1"><code>(defattrs c-int :intelligence
          c-str :strength
          c-dex :dexterity)</code></pre>
<p><span id="text_part0020.html"></span></p>
<h1 class="part" id="text_part0020.html_part03"><span
id="text_part0020.html_page_187" class="calibre1"></span><strong><span
class="big">Part III</span></strong><br />
<strong>Advanced Topics</strong><span id="text_part0020.html_page_188"
class="calibre1"></span></h1>
<p><span id="text_part0021.html"></span></p>
<h2 class="h1" id="text_part0021.html_ch09"><span
id="text_part0021.html_page_189" class="calibre1"></span><strong><span
class="big1">9</span></strong><br />
<strong>The Sacred Art of Concurrent and Parallel
Programming</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>If I were the lord of a manor and you were my heir, I would sit you
down on your 13th name day and tell you, “The world of computing is
changing, lass, and ye must be prepared for the new world of multi-core
processors lest ye be trampled by it.</p>
<p>“Listen well: In recent years, CPU clock speeds have barely
increased, but dual-core and quad-core computers have become common. The
laws of physics are cruel and absolute, and they demand that increasing
clock speed requires exponentially more power. The realm’s best
engineers are unlikely to overcome this limitation anytime soon, if
ever. Therefore, you can expect the trend of increasing cores on a
single machine to continue—as will the expectation that you as a
programmer will know how to make the most of modern hardware.</p>
<p><span id="text_part0021.html_page_190"
class="calibre4"></span>“Learning to program in this new paradigm will
be fun and fascinating, verily. But beware: it is also fraught with
peril. You must learn <em>concurrent and parallel programming</em>,
which is the sacred art of structuring your application to safely manage
multiple, simultaneously executing tasks.</p>
<p>“You begin your instruction in this art with an overview of
concurrency and parallelism concepts. You’ll then study the three
goblins that harry every practitioner: reference cells, mutual
exclusion, and dwarven berserkers. And you’ll learn three tools that
will aid you: futures, promises, and delays.”</p>
<p>And then I’d tap you on the shoulder with a keyboard, signaling that
you were ready to begin.</p>
<h3 class="h2" id="text_part0021.html_ch09lev1sec1"><strong>Concurrency
and Parallelism Concepts</strong></h3>
<p>Concurrent and parallel programming involves a lot of messy details
at all levels of program execution, from the hardware to the operating
system to programming language libraries to the code that springs from
your heart and lands in your editor. But before you worry your head with
any of those details, in this section I’ll walk through the high-level
concepts that surround concurrency and parallelism.</p>
<h4 class="h2" id="text_part0021.html_ch09lev2sec1"><em><strong>Managing
Multiple Tasks vs. Executing Tasks Simultaneously</strong></em></h4>
<p><em>Concurrency</em> refers to managing more than one task at the
same time. <em>Task</em> just means “something that needs to get done,”
and it doesn’t imply anything regarding implementation in your hardware
or software. We can illustrate concurrency with the song “Telephone” by
Lady Gaga. Gaga sings,</p>
<p>I cannot text you with a drink in my hand, eh</p>
<p>Here, she’s explaining that she can only manage one task (drinking).
She flat-out rejects the suggestion that she can manage more than one
task. However, if she decided to process tasks concurrently, she would
sing,</p>
<p>I will put down this drink to text you, then put my phone away and
continue drinking, eh</p>
<p>In this hypothetical universe, Lady Gaga is managing two tasks:
drinking and texting. However, she is not executing both tasks at the
same time. Instead, she’s switching between the two, or
<em>interleaving</em>. Note that, while interleaving, you don’t have to
fully complete a task before switching: Gaga could type one word, put
down her phone, pick up her drink and take a sip, and then switch back
to her phone and type another word.</p>
<p><em>Parallelism</em> refers to executing more than one task at the
same time. If Madame Gaga were to execute her two tasks in parallel, she
would sing,</p>
<p>I can text you with one hand while I use the other to drink, eh</p>
<p>Parallelism is a subclass of concurrency: before you execute multiple
tasks simultaneously, you first have to manage multiple tasks.</p>
<p><span id="text_part0021.html_page_191"
class="calibre4"></span>Clojure has many features that allow you to
achieve parallelism easily. While the Lady Gaga system achieves
parallelism by simultaneously executing tasks on multiple hands,
computer systems generally achieve parallelism by simultaneously
executing tasks on multiple processors.</p>
<p>It’s important to distinguish parallelism from <em>distribution</em>.
Distributed computing is a special version of parallel computing where
the processors are in different computers and tasks are distributed to
computers over a network. It’d be like Lady Gaga asking Beyoncé, “Please
text this guy while I drink.” Although you can do distributed
programming in Clojure with the aid of libraries, this book covers only
parallel programming, and here I’ll use <em>parallel</em> to refer only
to cohabiting processors. If you’re interested in distributed
programming, check out Kyle Kingsbury’s <em>Call Me Maybe</em> series at
<em><a href="https://aphyr.com/"
class="calibre4">https://aphyr.com/</a></em>.</p>
<h4 class="h2" id="text_part0021.html_ch09lev2sec2"><em><strong>Blocking
and Asynchronous Tasks</strong></em></h4>
<p>One of the major use cases for concurrent programming is for
<em>blocking</em> operations. Blocking really just means waiting for an
operation to finish. You’ll most often hear it used in relation to I/O
operations, like reading a file or waiting for an HTTP request to
finish. Let’s examine this using the concurrent Lady Gaga example.</p>
<p>If Lady Gaga texts her interlocutor and then stands there with her
phone in her hand, staring at the screen for a response and not
drinking, then you would say that the <em>read next text message</em>
operation is blocking and that these tasks are executing
<em>synchronously</em>.</p>
<p>If, instead, she tucks her phone away so she can drink until it
alerts her by beeping or vibrating, then the <em>read next text
message</em> task is not blocking and you would say she’s handling the
task <em>asynchronously.</em></p>
<h4 class="h2"
id="text_part0021.html_ch09lev2sec3"><em><strong>Concurrent Programming
and Parallel Programming</strong></em></h4>
<p>Concurrent programming and parallel programming refer to techniques
for decomposing a task into subtasks that can execute in parallel and
managing the risks that arise when your program executes more than one
task at the same time. For the rest of the chapter, I’ll use the two
terms interchangeably because the risks are pretty much the same for
both.</p>
<p>To better understand those risks and how Clojure helps you avoid
them, let’s examine how concurrency and parallelism are implemented in
Clojure.</p>
<h3 class="h2" id="text_part0021.html_ch09lev1sec2"><strong>Clojure
Implementation: JVM Threads</strong></h3>
<p>I’ve been using the term <em>task</em> in an abstract sense to refer
to a series of related operations without regard for how a computer
might implement the task concept. For example, texting is a task that
consists of a series of related operations that are totally separate
from the operations involved in pouring a drink into your face.</p>
<p><span id="text_part0021.html_page_192" class="calibre4"></span>In
Clojure, you can think of your normal, <em>serial</em> code as a
sequence of tasks. You indicate that tasks can be performed concurrently
by placing them on JVM <em>threads</em>.</p>
<h4 class="h2" id="text_part0021.html_ch09lev2sec4"><em><strong>What’s a
Thread?</strong></em></h4>
<p>I’m glad you asked! A thread is a subprogram. A program can have many
threads, and each thread executes its own set of instructions while
enjoying shared access to the program’s state.</p>
<p>Thread management functionality can exist at multiple levels in a
computer. For example, the operating system kernel typically provides
system calls to create and manage threads. The JVM provides its own
platform-independent thread management functionality, and since Clojure
programs run in the JVM, they use JVM threads. You’ll learn more about
the JVM in <a href="#text_part0024.html_ch12" class="calibre4">Chapter
12</a>.</p>
<div class="image">
<img src="images_00054.jpeg" class="calibre3" alt="image" />
</div>
<p>You can think of a thread as an actual, physical piece of thread that
strings together a sequence of instructions. In my mind, the
instructions are marshmallows, because marshmallows are delicious. The
processor executes these instructions in order. I picture this as an
alligator consuming the instructions, because alligators love
marshmallows (true fact!). So executing a program looks like a bunch of
marshmallows strung out on a line with an alligator traveling down the
line and eating them one by one. <a href="#text_part0021.html_ch9fig1"
class="calibre4">Figure 9-1</a> shows this model for a single-core
processor executing a single-threaded program.</p>
<div class="image">
<img src="images_00055.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0021.html_ch9fig1"
class="calibre4"></span><em>Figure 9-1: Single-core processor executing
a single-threaded program</em></p>
<p>A thread can <em>spawn</em> a new thread to execute tasks
concurrently. In a single-processor system, the processor switches back
and forth between the threads (interleaving). Here’s where potential
concurrency issues get introduced. Although the processor executes the
instructions on each thread in order, it makes no guarantees about when
it will switch back and forth between threads.</p>
<p><span id="text_part0021.html_page_193" class="calibre4"></span><a
href="#text_part0021.html_ch9fig2" class="calibre4">Figure 9-2</a> shows
an illustration of two threads, A and B, and a timeline of how their
instructions could be executed. I’ve shaded the instructions on thread B
to help distinguish them from the instructions on thread A.</p>
<div class="image">
<img src="images_00056.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0021.html_ch9fig2"
class="calibre4"></span><em>Figure 9-2: Single-core processor executing
two threads</em></p>
<p>Note that this is just one possible order of instruction execution.
The processor could also have executed the instructions in the order A1,
A2, A3, B1, A4, B2, B3 for example. This makes the program
<em>nondeterministic</em>. You can’t know beforehand what the result
will be because you can’t know the execution order, and different
execution orders can yield different results.</p>
<p>This example shows concurrent execution on a single processor through
interleaving, whereas a multi-core system assigns a thread to each core,
allowing the computer to execute more than one thread simultaneously.
Each core executes its thread’s instructions in order, as shown in <a
href="#text_part0021.html_ch9fig3" class="calibre4">Figure 9-3</a>.</p>
<div class="image">
<img src="images_00057.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0021.html_ch9fig3"
class="calibre4"></span><em>Figure 9-3: Two threads, two
processors</em></p>
<p>As with interleaving on a single core, there are no guarantees for
the overall execution order, so the program is nondeterministic. When
you add a second thread to a program, it becomes nondeterministic, and
this makes it possible for your program to fall prey to three kinds of
problems.</p>
<h4 class="h2" id="text_part0021.html_ch09lev2sec5"><em><strong>The
Three Goblins: Reference Cells, Mutual Exclusion, and Dwarven
Berserkers</strong></em></h4>
<p>There are three central challenges in concurrent programming, also
known as the <em>The Three Concurrency Goblins</em>. To see why these
are scary, imagine that the program in the image in <a
href="#text_part0021.html_ch9fig3" class="calibre4">Figure 9-3</a>
includes the pseudoinstructions in <a href="#text_part0021.html_ch9tab1"
class="calibre4">Table 9-1</a>.</p>
<p><span id="text_part0021.html_page_194" class="calibre4"></span><span
id="text_part0021.html_ch9tab1" class="calibre4"></span><strong>Table
9-1:</strong> Instructions for a Program with a Nondeterministic
Outcome</p>
<table class="topbot" data-border="0" data-cellpadding="0"
data-cellspacing="0" width="100%">
<thead class="calibre12">
<tr class="calibre13">
<th class="table_th" data-valign="top"><p><strong>ID</strong></p></th>
<th class="table_th"
data-valign="top"><p><strong>Instruction</strong></p></th>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre13">
<td class="table1" data-valign="top"><p>A1</p></td>
<td class="table1" data-valign="top"><p>WRITE <span class="literal1">X =
0</span></p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p>A2</p></td>
<td class="table1" data-valign="top"><p>READ <span
class="literal1">X</span></p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p>A3</p></td>
<td class="table1" data-valign="top"><p>WRITE <span class="literal1">X =
X + 1</span></p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p>B1</p></td>
<td class="table1" data-valign="top"><p>READ <span
class="literal1">X</span></p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p>B2</p></td>
<td class="table1" data-valign="top"><p>WRITE <span class="literal1">X =
X + 1</span></p></td>
</tr>
</tbody>
</table>
<p>If the processor follows the order A1, A2, A3, B1, B2, then <span
class="literal1">X</span> will have a value of <span
class="literal1">2</span>, as you’d expect. But if it follows the order
A1, A2, B1, A3, B2, <span class="literal1">X</span>’s value will be
<span class="literal1">1</span>, as you can see in <a
href="#text_part0021.html_ch9fig4" class="calibre4">Figure 9-4</a>.</p>
<div class="image">
<img src="images_00058.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0021.html_ch9fig4"
class="calibre4"></span><em>Figure 9-4: Two threads interacting with a
reference cell</em></p>
<p>We’ll call this the <em>reference cell</em> problem (the first
Concurrency Goblin). The reference cell problem occurs when two threads
can read and write to the same location, and the value at the location
depends on the order of the reads and writes.</p>
<p>The second Concurrency Goblin is <em>mutual exclusion</em>. Imagine
two threads, each trying to write a spell to a file. Without any way to
claim exclusive write access to the file, the spell will end up garbled
because the write instructions will be interleaved. Consider the
following two spells:</p>
<p>By the power invested in me<br />
by the state of California,<br />
I now pronounce you man and wife</p>
<p>Thunder, lightning, wind, and rain,<br />
a delicious sandwich, I summon again</p>
<p>If you write these to a file without mutual exclusion, you could end
up with this:</p>
<p>By the power invested in me<br />
by Thunder, lightning, wind, and rain, <span
id="text_part0021.html_page_195" class="calibre4"></span><br />
the state of California,<br />
I now pronounce you a delicious man sandwich, and wife<br />
I summon again</p>
<p>The third Concurrency Goblin is what I’ll call the <em>dwarven
berserker</em> problem (aka <em>deadlock</em>). Imagine four berserkers
sitting around a rough-hewn, circular wooden table comforting each
other. “I know I’m distant toward my children, but I just don’t know how
to communicate with them,” one growls. The rest sip their coffee and nod
knowingly, care lines creasing their eye places.</p>
<p>Now, as everyone knows, the dwarven berserker ritual for ending a
comforting coffee klatch is to pick up their “comfort sticks”
(double-bladed war axes) and scratch each other’s backs. One war axe is
placed between each pair of dwarves, as shown in <a
href="#text_part0021.html_ch9fig5" class="calibre4">Figure 9-5</a>.</p>
<p>Their ritual proceeds thusly:</p>
<p>1. Pick up the <em>left</em> war axe, when available.</p>
<p>2. Pick up the <em>right</em> war axe, when available.</p>
<p>3. Comfort your neighbor with vigorous swings of your “comfort
sticks.”</p>
<p>4. Release both war axes.</p>
<p>5. Repeat.</p>
<div class="image">
<img src="images_00059.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0021.html_ch9fig5"
class="calibre4"></span><em>Figure 9-5: Dwarven berserkers at a
comforting coffee klatch</em></p>
<p>Following this ritual, it’s entirely possible that all the dwarven
berserkers will pick up their left comfort stick and then block
indefinitely while waiting for the comfort stick to their right to
become available, resulting in deadlock. (By the way, if you want to
look into this phenomenon further, it’s <span
id="text_part0021.html_page_196" class="calibre4"></span>usually
referred to as the <em>dining philosophers problem</em>, but that’s a
more boring scenario.) This book doesn’t discuss deadlock in much
detail, but it’s good to know the concept and its terminology.</p>
<p>Concurrent programming has its goblins, but with the right tools,
it’s manageable and even fun. Let’s start looking at the right
tools.</p>
<h3 class="h2" id="text_part0021.html_ch09lev1sec3"><strong>Futures,
Delays, and Promises</strong></h3>
<p>Futures, delays, and promises are easy, lightweight tools for
concurrent programming. In this section, you’ll learn how each one works
and how to use them together to defend against the reference cell
Concurrency Goblin and the mutual exclusion Concurrency Goblin. You’ll
discover that, although simple, these tools go a long way toward meeting
your concurrency needs.</p>
<p>They do this by giving you more flexibility than is possible with
serial code. When you write serial code, you bind together these three
events:</p>
<p>• Task definition</p>
<p>• Task execution</p>
<p>• Requiring the task’s result</p>
<p>As an example, look at this hypothetical code, which defines a simple
API call task:</p>
<pre class="programs"><code>(web-api/get :dwarven-beard-waxes)</code></pre>
<p>As soon as Clojure encounters this task definition, it executes it.
It also requires the result <em>right now</em>, blocking until the API
call finishes. Part of learning concurrent programming is learning to
identify when these chronological couplings aren’t necessary. Futures,
delays, and promises allow you to separate task definition, task
execution, and requiring the result. Onward!</p>
<h4 class="h2"
id="text_part0021.html_ch09lev2sec6"><em><strong>Futures</strong></em></h4>
<p>In Clojure, you can use <em>futures</em> to define a task and place
it on another thread without requiring the result immediately. You can
create a future with the <span class="literal1">future</span> macro. Try
this in a REPL:</p>
<pre class="programs"><code>(future (Thread/sleep 4000)
        (println &quot;I&#39;ll print after 4 seconds&quot;))
(println &quot;I&#39;ll print immediately&quot;)</code></pre>
<p><span class="literal1">Thread/sleep</span> tells the current thread
to just sit on its bum and do nothing for the specified number of
milliseconds. Normally, if you evaluated <span
class="literal1">Thread/sleep</span> in your REPL, you wouldn’t be able
to evaluate any other statements until the REPL was done sleeping; the
thread executing your REPL <span id="text_part0021.html_page_197"
class="calibre4"></span>would be blocked. However, <span
class="literal1">future</span> creates a new thread and places each
expression you pass it on the new thread, including <span
class="literal1">Thread/sleep</span>, allowing the REPL’s thread to
continue, unblocked.</p>
<p>You can use futures to run tasks on a separate thread and then forget
about them, but often you’ll want to use the result of the task. The
<span class="literal1">future</span> function returns a reference value
that you can use to request the result. The reference is like the ticket
that a dry cleaner gives you: at any time you can use it to request your
clean dress, but if your dress isn’t clean yet, you’ll have to wait.
Similarly, you can use the reference value to request a future’s result,
but if the future isn’t done computing the result, you’ll have to
wait.</p>
<p>Requesting a future’s result is called <em>dereferencing</em> the
future, and you do it with either the <span
class="literal1">deref</span> function or the <span
class="literal1">@</span> reader macro. A future’s result value is the
value of the last expression evaluated in its body. A future’s body
executes only once, and its value gets cached. Try the following:</p>
<pre class="programs"><code>(let [result (future (println &quot;this prints once&quot;)
                     (+ 1 1))]
  (println &quot;deref: &quot; (deref result))
  (println &quot;@: &quot; @result))
; =&gt; &quot;this prints once&quot;
; =&gt; deref: 2
; =&gt; @: 2</code></pre>
<p>Notice that the string <span class="literal1">"this prints
once"</span> indeed prints only once, even though you dereference the
future twice. This shows that the future’s body ran only once and the
result, <span class="literal1">2</span>, got cached.</p>
<p>Dereferencing a future will block if the future hasn’t finished
running, like so:</p>
<pre class="programs"><code>(let [result (future (Thread/sleep 3000)
                     (+ 1 1))]
  (println &quot;The result is: &quot; @result)
  (println &quot;It will be at least 3 seconds before I print&quot;))
; =&gt; The result is: 2
; =&gt; It will be at least 3 seconds before I print</code></pre>
<p>Sometimes you want to place a time limit on how long to wait for a
future. To do that, you can pass <span class="literal1">deref</span> a
number of milliseconds to wait along with the value to return if the
<span class="literal1">deref</span> times out:</p>
<pre class="programs"><code>(deref (future (Thread/sleep 1000) 0) 10 5)
; =&gt; 5</code></pre>
<p>This code tells <span class="literal1">deref</span> to return the
value <span class="literal1">5</span> if the future doesn’t return a
value within 10 milliseconds.</p>
<p><span id="text_part0021.html_page_198"
class="calibre4"></span>Finally, you can interrogate a future using
<span class="literal1">realized?</span> to see if it’s done running:</p>
<pre class="programs"><code>(realized? (future (Thread/sleep 1000)))
; =&gt; false


(let [f (future)]
  @f
  (realized? f))
; =&gt; true</code></pre>
<p>Futures are a dead-simple way to sprinkle some concurrency on your
program.</p>
<p>On their own, they give you the power to chuck tasks onto other
threads, which can make your program more efficient. They also let your
program behave more flexibly by giving you control over when a task’s
result is required.</p>
<p>When you dereference a future, you indicate that the result is
required <em>right now</em> and that evaluation should stop until the
result is obtained. You’ll see how this can help you deal with the
mutual exclusion problem in just a bit. Alternatively, you can ignore
the result. For example, you can use futures to write to a log file
asynchronously, in which case you don’t need to dereference the future
to get any value back.</p>
<p>The flexibility that futures give you is very cool. Clojure also
allows you to treat task definition and requiring the result
independently with delays and promises.</p>
<h4 class="h2"
id="text_part0021.html_ch09lev2sec7"><em><strong>Delays</strong></em></h4>
<p><em>Delays</em> allow you to define a task without having to execute
it or require the result immediately. You can create a delay using <span
class="literal1">delay</span>:</p>
<pre class="programs"><code>(def jackson-5-delay
  (delay (let [message &quot;Just call my name and I&#39;ll be there&quot;]
           (println &quot;First deref:&quot; message)
           message)))</code></pre>
<p>In this example, nothing is printed, because we haven’t yet asked the
<span class="literal1">let</span> form to be evaluated. You can evaluate
the delay and get its result by dereferencing it or by using <span
class="literal1">force</span>. <span class="literal1">force</span>
behaves identically to <span class="literal1">deref</span> in that it
communicates more clearly that you’re causing a task to start as opposed
to waiting for a task to finish:</p>
<pre class="programs"><code>(force jackson-5-delay)
; =&gt; First deref: Just call my name and I&#39;ll be there
; =&gt; &quot;Just call my name and I&#39;ll be there&quot;</code></pre>
<p><span id="text_part0021.html_page_199" class="calibre4"></span>Like
futures, a delay is run only once and its result is cached. Subsequent
dereferencing will return the Jackson 5 message without printing
anything:</p>
<pre class="programs"><code>@jackson-5-delay
; =&gt; &quot;Just call my name and I&#39;ll be there&quot;</code></pre>
<p>One way you can use a delay is to fire off a statement the first time
one future out of a group of related futures finishes. For example,
pretend your app uploads a set of headshots to a headshot-sharing site
and notifies the owner as soon as the first one is up, as in the
following:</p>
<pre class="programs"><code>(def gimli-headshots [&quot;serious.jpg&quot; &quot;fun.jpg&quot; &quot;playful.jpg&quot;])
(defn email-user
  [email-address]
  (println &quot;Sending headshot notification to&quot; email-address))
(defn upload-document
  &quot;Needs to be implemented&quot;
  [headshot]
  true)
(let [notify (delay ➊(email-user &quot;and-my-axe@gmail.com&quot;))]
  (doseq [headshot gimli-headshots]
    (future (upload-document headshot)
            ➋(force notify))))</code></pre>
<p>In this example, you define a vector of headshots to upload (<span
class="literal1">gimli-headshots</span>) and two functions (<span
class="literal1">email-user</span> and <span
class="literal1">upload-document</span>) to pretend-perform the two
operations. Then you use <span class="literal1">let</span> to bind <span
class="literal1">notify</span> to a delay. The body of the delay, <span
class="literal1">(email-user "and-my-axe@gmail.com")</span> <span
class="ent">➊</span>, isn’t evaluated when the delay is created.
Instead, it gets evaluated the first time one of the futures created by
the <span class="literal1">doseq</span> form evaluates <span
class="literal1">(force notify)</span> <span class="ent">➋</span>. Even
though <span class="literal1">(force notify)</span> will be evaluated
three times, the delay body is evaluated only once. Gimli will be
grateful to know when the first headshot is available so he can begin
tweaking it and sharing it. He’ll also appreciate not being spammed, and
you’ll appreciate not facing his dwarven wrath.</p>
<p>This technique can help protect you from the mutual exclusion
Concurrency Goblin—the problem of making sure that only one thread can
access a particular resource at a time. In this example, the delay
guards the email server resource. Because the body of a delay is
guaranteed to fire only once, you can be sure that you will never run
into a situation where two threads send the same email. Of course, no
thread will ever be able to use the delay to send an email again. That
might be too drastic a constraint for most situations, but in cases like
this example, it works perfectly.</p>
<h4 class="h2" id="text_part0021.html_ch09lev2sec8"><span
id="text_part0021.html_page_200"
class="calibre1"></span><em><strong>Promises</strong></em></h4>
<p><em>Promises</em> allow you to express that you expect a result
without having to define the task that should produce it or when that
task should run. You create promises using <span
class="literal1">promise</span> and deliver a result to them using <span
class="literal1">deliver</span>. You obtain the result by
dereferencing:</p>
<pre class="programs"><code>(def my-promise (promise))
(deliver my-promise (+ 1 2))
@my-promise
; =&gt; 3</code></pre>
<p>Here, you create a promise and then deliver a value to it. Finally,
you obtain the value by dereferencing the promise. Dereferencing is how
you express that you expect a result, and if you had tried to
dereference <span class="literal1">my-promise</span> without first
delivering a value, the program would block until a promise was
delivered, just like with futures and delays. You can only deliver a
result to a promise once.</p>
<p>One use for promises is to find the first satisfactory element in a
collection of data. Suppose, for example, that you’re gathering
ingredients to make your parrot sound like James Earl Jones. Because
James Earl Jones has the smoothest voice on earth, one of the
ingredients is premium yak butter with a smoothness rating of 97 or
greater. You have a budget of $100 for one pound.</p>
<div class="image">
<img src="images_00060.jpeg" class="calibre3" alt="image" />
</div>
<p>You are a modern practitioner of the magicoornithological arts, so
rather than tediously navigating each yak butter retail site, you create
a script to give you the URL of the first yak butter that meets your
needs.</p>
<p>The following code defines some yak butter products, creates a
function to mock up an API call, and creates another function to test
whether a product is satisfactory:</p>
<pre class="programs"><code>(def yak-butter-international
  {:store &quot;Yak Butter International&quot;
    :price 90
    :smoothness 90})
(def butter-than-nothing
  {:store &quot;Butter Than Nothing&quot;
   :price 150
   :smoothness 83})

;; This is the butter that meets our requirements
(def baby-got-yak
  {:store &quot;Baby Got Yak&quot;
   :price 94
   :smoothness 99})


(defn mock-api-call
  [result]
  (Thread/sleep 1000)
  result)


(defn satisfactory?
  &quot;If the butter meets our criteria, return the butter, else return false&quot;
  [butter]
  (and (&lt;= (:price butter) 100)
       (&gt;= (:smoothness butter) 97)
       butter))</code></pre>
<p>The API call waits one second before returning a result to simulate
the time it would take to perform an actual call.</p>
<p>To show how long it will take to check the sites synchronously, we’ll
use <span class="literal1">some</span> to apply the <span
class="literal1">satisfactory?</span> function to each element of the
collection and return the first truthy result, or nil if there are none.
When you check each site synchronously, it could take more than one
second per site to obtain a result, as the following code shows:</p>
<pre class="programs"><code>(time (some (comp satisfactory? mock-api-call)
            [yak-butter-international butter-than-nothing baby-got-yak]))
; =&gt; &quot;Elapsed time: 3002.132 msecs&quot;
; =&gt; {:store &quot;Baby Got Yak&quot;, :smoothness 99, :price 94}</code></pre>
<p>Here I’ve used <span class="literal1">comp</span> to compose
functions, and I’ve used <span class="literal1">time</span> to print the
time taken to evaluate a form. You can use a promise and futures to
perform each check on a separate thread. If your computer has multiple
cores, this could reduce the time it takes to about one second:</p>
<pre class="programs"><code>(time
 (let [butter-promise (promise)]
   (doseq [butter [yak-butter-international butter-than-nothing baby-got-yak]]
     (future (if-let [satisfactory-butter (satisfactory? (mock-api-call butter))]
               (deliver butter-promise satisfactory-butter))))
   (println &quot;And the winner is:&quot; @butter-promise)))
; =&gt; &quot;Elapsed time: 1002.652 msecs&quot;
; =&gt; And the winner is: {:store Baby Got Yak, :smoothness 99, :price 94}</code></pre>
<p>In this example, you first create a promise, <span
class="literal1">@butter-promise</span>, and then create three futures
with access to that promise. Each future’s task is to evaluate a yak
butter site and to deliver the site’s data to the promise if it’s
satisfactory. Finally, you dereference <span
class="literal1">@butter-promise</span>, causing the program to block
until the site data is delivered. This takes about one second instead
<span id="text_part0021.html_page_202" class="calibre4"></span>of three
because the site evaluations happen in parallel. By decoupling the
requirement for a result from how the result is actually computed, you
can perform multiple computations in parallel and save some time.</p>
<p>You can view this as a way to protect yourself from the reference
cell Concurrency Goblin. Because promises can be written to only once,
you prevent the kind of inconsistent state that arises from
nondeterministic reads and writes.</p>
<p>You might be wondering what happens if none of the yak butter is
satisfactory. If that happens, the dereference would block forever and
tie up the thread. To avoid that, you can include a timeout:</p>
<pre class="programs"><code>(let [p (promise)]
  (deref p 100 &quot;timed out&quot;))</code></pre>
<p>This creates a promise, <span class="literal1">p</span>, and tries to
dereference it. The number 100 tells <span class="literal1">deref</span>
to wait 100 milliseconds, and if no value is available by then, to use
the timeout value, <span class="literal1">"timed out"</span>.</p>
<p>The last detail I should mention is that you can also use promises to
register callbacks, achieving the same functionality that you might be
used to in JavaScript. JavaScript callbacks are a way of defining code
that should execute asynchronously once some other code finishes. Here’s
how to do it in Clojure:</p>
<pre class="programs"><code>(let [ferengi-wisdom-promise (promise)]
  (future (println &quot;Here&#39;s some Ferengi wisdom:&quot; @ferengi-wisdom-promise))
  (Thread/sleep 100)
  (deliver ferengi-wisdom-promise &quot;Whisper your way to success.&quot;))
; =&gt; Here&#39;s some Ferengi wisdom: Whisper your way to success.</code></pre>
<p>This example creates a future that begins executing immediately.
However, the future’s thread is blocking because it’s waiting for a
value to be delivered to <span
class="literal1">ferengi-wisdom-promise</span>. After 100 milliseconds,
you deliver the value and the <span class="literal1">println</span>
statement in the future runs.</p>
<p>Futures, delays, and promises are great, simple ways to manage
concurrency in your application. In the next section, we’ll look at one
more fun way to keep your concurrent applications under control.</p>
<h4 class="h2" id="text_part0021.html_ch09lev2sec9"><em><strong>Rolling
Your Own Queue</strong></em></h4>
<p>So far you’ve looked at some simple ways to combine futures, delays,
and promises to make your concurrent programs a little safer. In this
section, you’ll use a macro to combine futures and promises in a
slightly more complex manner. You might not necessarily ever use this
code, but it’ll show the power of these modest tools a bit more. The
macro will require you to hold runtime logic and macro expansion logic
in your head at the same time to understand what’s going on; if you get
stuck, just skip ahead.</p>
<p><span id="text_part0021.html_page_203" class="calibre4"></span>One
characteristic The Three Concurrency Goblins have in common is that they
all involve tasks concurrently accessing a shared resource—a variable, a
printer, a dwarven war axe—in an uncoordinated way. If you want to
ensure that only one task will access a resource at a time, you can
place the resource access portion of a task on a queue that’s executed
serially. It’s kind of like making a cake: you and a friend can
separately retrieve the ingredients (eggs, flour, eye of newt, what have
you), but some steps you’ll have to perform serially. You have to
prepare the batter before you put it in the oven. <a
href="#text_part0021.html_ch9fig6" class="calibre4">Figure 9-6</a>
illustrates this strategy.</p>
<div class="image">
<img src="images_00061.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0021.html_ch9fig6"
class="calibre4"></span><em>Figure 9-6: Dividing tasks into a serial
portion and a concurrent portion lets you safely make your code more
efficient.</em></p>
<p>To implement the queuing macro, you’ll pay homage to the British,
because they invented queues. You’ll use a queue to ensure that the
customary British greeting “Ello, gov’na! Pip pip! Cheerio!” is
delivered in the correct order. This demonstration will involve an
abundance of <span class="literal1">sleep</span>ing, so here’s a macro
to do that more concisely:</p>
<pre class="programs"><code>(defmacro wait
  &quot;Sleep `timeout` seconds before evaluating body&quot;
  [timeout &amp; body]
  `(do (Thread/sleep ~timeout) ~@body))</code></pre>
<p>All this code does is take whatever forms you give it and insert a
call to <span class="literal1">Thread/sleep</span> before them, all
wrapped up in <span class="literal1">do</span>.</p>
<p>The code in <a href="#text_part0021.html_ch9list1"
class="calibre4">Listing 9-1</a> splits up tasks into a concurrent
portion and a serialized portion:</p>
<pre class="programs"><code>  (let [saying3 (promise)]
    (future (deliver saying3 (wait 100 &quot;Cheerio!&quot;)))
    @(let [saying2 (promise)]
       (future (deliver saying2 (wait 400 &quot;Pip pip!&quot;)))
➊      @(let [saying1 (promise)]
          (future (deliver saying1 (wait 200 &quot;&#39;Ello, gov&#39;na!&quot;)))

      (println @saying1)
      saying1)
   (println @saying2)
   saying2)
(println @saying3)
saying3)</code></pre>
<p><span id="text_part0021.html_ch9list1"
class="calibre4"></span><em>Listing 9-1: The expansion of an enqueue
macro call</em></p>
<p>The overall strategy is to create a promise for each task (in this
case, printing part of the greeting) to create a corresponding future
that will deliver a concurrently computed value to the promise. This
ensures that all of the futures are created before any of the promises
are dereferenced, and it ensures that the serialized portions are
executed in the correct order. The value of <span
class="literal1">saying1</span> is printed first—<span
class="literal1">"'Ello, gov'na!"</span>—then the value of <span
class="literal1">saying2</span>, and finally <span
class="literal1">saying3</span>. Returning <span
class="literal1">saying1</span> in a <span class="literal1">let</span>
block and dereferencing the <span class="literal1">let</span> block at
<span class="ent">➊</span> ensures that you’ll be completely finished
with <span class="literal1">saying1</span> before the code moves on to
do anything to <span class="literal1">saying2</span>, and this pattern
is repeated with <span class="literal1">saying2</span> and <span
class="literal1">saying3</span>.</p>
<p>It might seem silly to dereference the <span
class="literal1">let</span> block, but doing so lets you abstract this
code with a macro. And you will definitely want to use a macro, because
writing out code like the previous example would drive you mental (as
the British would say). Ideally, the macro would work as shown in <a
href="#text_part0021.html_ch9list2" class="calibre4">Listing
9-2</a>:</p>
<pre class="programs"><code>(-&gt; (enqueue ➊saying ➋(wait 200 &quot;&#39;Ello, gov&#39;na!&quot;) ➌(println @saying))
  ➍ (enqueue saying (wait 400 &quot;Pip pip!&quot;) (println @saying))
    (enqueue saying (wait 100 &quot;Cheerio!&quot;) (println @saying)))</code></pre>
<p><span id="text_part0021.html_ch9list2"
class="calibre4"></span><em>Listing 9-2: This is how you’d use
enqueue.</em></p>
<p>The macro lets you name the promise that gets created <span
class="ent">➊</span>, define how to derive the value to deliver that
promise <span class="ent">➋</span>, and define what to do with the
promise <span class="ent">➌</span>. The macro can also take another
<span class="literal1">enqueue</span> macro call as its first argument,
which lets you thread it <span class="ent">➍</span>. <a
href="#text_part0021.html_ch9list3" class="calibre4">Listing 9-3</a>
shows how you can define the <span class="literal1">enqueue</span>
macro. After defining <span class="literal1">enqueue</span>, the code in
<a href="#text_part0021.html_ch9list2" class="calibre4">Listing 9-2</a>
will expand into the code in <a href="#text_part0021.html_ch9list1"
class="calibre4">Listing 9-1</a>, with all the nested <span
class="literal1">let</span> expressions:</p>
<pre class="programs"><code>   (defmacro enqueue
➊   ([q concurrent-promise-name concurrent serialized]
➋    `(let [~concurrent-promise-name (promise)]
        (future (deliver ~concurrent-promise-name ~concurrent))
➌       (deref ~q)
         ~serialized
         ~concurrent-promise-name))
➍   ([concurrent-promise-name concurrent serialized]
      `(enqueue (future) ~concurrent-promise-name ~concurrent ~serialized)))</code></pre>
<p><span id="text_part0021.html_ch9list3"
class="calibre4"></span><em>Listing 9-3: enqueue’s
implementation</em></p>
<p><span id="text_part0021.html_page_205" class="calibre4"></span>Notice
first that this macro has two arities in order to supply a default
value. The first arity <span class="ent">➊</span> is where the real work
is done. It has the parameter <span class="literal1">q</span>, and the
second arity does not. The second arity <span class="ent">➍</span> calls
the first with value <span class="literal1">(future)</span> supplied for
<span class="literal1">q</span>; you’ll see why in a minute. At <span
class="ent">➋</span>, the macro returns a form that creates a promise,
delivers its value in a future, dereferences whatever form is supplied
for <span class="literal1">q</span>, evaluates the serialized code, and
finally returns the promise. <span class="literal1">q</span> will
usually be a nested <span class="literal1">let</span> expression
returned by another call to <span class="literal1">enqueue</span>, like
in <a href="#text_part0021.html_ch9list2" class="calibre4">Listing
9-2</a>. If no value is supplied for <span class="literal1">q</span>,
the macro supplies a future so that the <span
class="literal1">deref</span> at <span class="ent">➌</span> doesn’t
cause an exception.</p>
<p>Now that we’ve written the <span class="literal1">enqueue</span>
macro, let’s try it out to see whether it reduces the execution
time!</p>
<pre class="programs"><code>(time @(-&gt; (enqueue saying (wait 200 &quot;&#39;Ello, gov&#39;na!&quot;) (println @saying))
           (enqueue saying (wait 400 &quot;Pip pip!&quot;) (println @saying))
           (enqueue saying (wait 100 &quot;Cheerio!&quot;) (println @saying))))
; =&gt; &#39;Ello, gov&#39;na!
; =&gt; Pip pip!
; =&gt; Cheerio!
; =&gt; &quot;Elapsed time: 401.635 msecs&quot;</code></pre>
<p>Blimey! The greeting is delivered in the correct order, and you can
see by the elapsed time that the “work” of sleeping was handled
concurrently.</p>
<h3 class="h2"
id="text_part0021.html_ch09lev1sec4"><strong>Summary</strong></h3>
<p>It’s important for programmers like you to learn concurrent and
parallel programming techniques so you can design programs that run
efficiently on modern hardware. Concurrency refers to a program’s
ability to carry out more than one task, and in Clojure you achieve this
by placing tasks on separate threads. Programs execute in parallel when
a computer has more than one CPU, which allows more than one thread to
be executed at the same time.</p>
<p>Concurrent programming refers to the techniques used to manage three
concurrency risks: reference cells, mutual exclusion, and deadlock.
Clojure gives you three basic tools that help you mitigate those risks:
futures, delays, and promises. Each tool lets you decouple the three
events of defining a task, executing a task, and requiring a task’s
result. Futures let you define a task and execute it immediately,
allowing you to require the result later or never. Futures also cache
their results. Delays let you define a task that doesn’t get executed
until later, and a delay’s result gets cached. Promises let you express
that you require a result without having to know about the task that
produces that result. You can only deliver a value to a promise
once.</p>
<p>In the next chapter, you’ll explore the philosophical side of
concurrent programming and learn more sophisticated tools for managing
the risks.</p>
<h3 class="h2" id="text_part0021.html_ch09lev1sec5"><span
id="text_part0021.html_page_206" class="calibre1"></span><strong><span
class="bordera">Exercises</span></strong></h3>
<p>1. Write a function that takes a string as an argument and searches
for it on Bing and Google using the <span class="literal1">slurp</span>
function. Your function should return the HTML of the first page
returned by the search.</p>
<p>2. Update your function so it takes a second argument consisting of
the search engines to use.</p>
<p>3. Create a new function that takes a search term and search engines
as arguments, and returns a vector of the URLs from the first page of
search results from each search engine.</p>
<p><span id="text_part0022.html"></span></p>
<h2 class="h1" id="text_part0022.html_ch10"><span
id="text_part0022.html_page_207" class="calibre1"></span><strong><span
class="big1">10</span></strong><br />
<strong>Clojure Metaphysics: Atoms, Refs, Vars, and Cuddle
Zombies</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>The Three Concurrency Goblins are all spawned from the same pit of
evil: shared access to mutable state. You can see this in the reference
cell discussion in <a href="#text_part0021.html_ch09"
class="calibre4">Chapter 9</a>. When two threads make uncoordinated
changes to the reference cell, the result is unpredictable.</p>
<p>Rich Hickey designed Clojure to specifically address the problems
that develop from shared access to mutable state. In fact, Clojure
embodies a very clear conception of state that makes it inherently safer
for concurrency than most popular programming languages. It’s safe all
the way down to its <em>meta-freakin-physics</em>.</p>
<p>In this chapter, you’ll learn about Clojure’s underlying metaphysics,
as compared to the metaphysics of typical object-oriented (OO)
languages. Learning this philosophy will prepare you to handle Clojure’s
remaining concurrency tools, the <em>atom</em>, <em>ref</em>, and
<em>var</em> reference types. (Clojure has one additional reference
type, <em>agents</em>, which this book doesn’t cover.) Each of <span
id="text_part0022.html_page_208" class="calibre4"></span>these types
enables you to safely perform state-modifying operations concurrently.
You’ll also learn about easy ways to make your program more efficient
without introducing state at all.</p>
<p>Metaphysics attempts to answer two basic questions in the broadest
possible terms:</p>
<p>• What is there?</p>
<p>• What is it like?</p>
<p>To draw out the differences between Clojure and OO languages, I’ll
explain two different ways of modeling a cuddle zombie. Unlike a regular
zombie, a cuddle zombie does not want to devour your brains. It only
wants to spoon you and maybe smell your neck. That makes its undead,
shuffling, decaying state all the more tragic. How could you try to kill
something that only wants love? Who’s the real monster here?</p>
<h3 class="h2"
id="text_part0022.html_ch10lev1sec1"><strong>Object-Oriented
Metaphysics</strong></h3>
<p>OO metaphysics treats the cuddle zombie as an object that exists in
the world. The object has properties that may change over time, but it’s
still treated as a single, constant object. If that seems like a totally
obvious, uncontroversial approach to zombie metaphysics, you probably
haven’t spent hours in an intro philosophy class arguing about what it
means for a chair to exist and what really makes it a chair in the first
place.</p>
<p>The tricky part is that the cuddle zombie is always changing. Its
body slowly deteriorates. Its undying hunger for cuddles grows fiercer
with time. In OO terms, we would say that the cuddle zombie is an object
with mutable state and that its state is ever fluctuating. But no matter
how much the zombie changes, we still identify it as the same zombie.
Here’s how you might model and interact with a cuddle zombie in
Ruby:</p>
<pre class="programs"><code>class CuddleZombie
  # attr_accessor is just a shorthand way for creating getters and
  # setters for the listed instance variables
  attr_accessor :cuddle_hunger_level, :percent_deteriorated


  def initialize(cuddle_hunger_level = 1, percent_deteriorated = 0)
    self.cuddle_hunger_level = cuddle_hunger_level
    self.percent_deteriorated = percent_deteriorated
  end
end


fred = CuddleZombie.new(2, 3)
fred.cuddle_hunger_level  # =&gt; 2
fred.percent_deteriorated # =&gt; 3


fred.cuddle_hunger_level = 3
fred.cuddle_hunger_level # =&gt; 3</code></pre>
<p><span id="text_part0022.html_page_209" class="calibre4"></span>In
this example, you create a cuddle zombie, <span
class="literal1">fred</span>, with two attributes: <span
class="literal1">cuddle_hunger_level</span> and <span
class="literal1">percent_deteriorated</span>. <span
class="literal1">fred</span> starts out with a <span
class="literal1">cuddle_hunger_level</span> of just 2, but you can
change it to whatever you want and it’s still good ol’ Fred, the same
cuddle zombie. In this case, you changed its <span
class="literal1">cuddle_hunger_level</span> to 3.</p>
<p>You can see that this object is just a fancy reference cell. It’s
subject to the same nondeterministic results in a multithreaded
environment. For example, if two threads try to increment Fred’s hunger
level with something like <span
class="literal1">fred.cuddle_hunger_level = fred.cuddle_hunger_level +
1</span>, one of the increments could be lost, just like in the example
with two threads writing to <span class="literal1">X</span> in “<a
href="#text_part0021.html_ch09lev2sec5" class="calibre4">The Three
Goblins: Reference Cells, Mutual Exclusion, and Dwarven Berserkers</a>”
on <a href="#text_part0021.html_page_193" class="calibre4">page
193</a>.</p>
<div class="image">
<img src="images_00062.jpeg" class="calibre3" alt="image" />
</div>
<p>Even if you’re only performing reads on a separate thread, the
program will still be nondeterministic. For example, suppose you’re
conducting research on cuddle zombie behavior. You want to log a
zombie’s hunger level whenever it reaches 50 percent deterioration, but
you want to do this on another thread to increase performance, using
code like that in <a href="#text_part0022.html_ch10list1"
class="calibre4">Listing 10-1</a>:</p>
<pre class="programs"><code>if fred.percent_deteriorated &gt;= 50
  Thread.new { database_logger.log(fred.cuddle_hunger_level) }
end</code></pre>
<p><span id="text_part0022.html_ch10list1"
class="calibre4"></span><em>Listing 10-1: This Ruby code isn’t safe for
concurrent execution.</em></p>
<p>The problem is that another thread could change <span
class="literal1">fred</span> before the write actually takes place.</p>
<p>For example, <a href="#text_part0022.html_ch10fig1"
class="calibre4">Figure 10-1</a> shows two threads executing from top to
bottom. In this situation, it would be correct to write 5 to the
database, but 10 gets written instead.</p>
<div class="image">
<img src="images_00063.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0022.html_ch10fig1"
class="calibre4"></span><em>Figure 10-1: Logging inconsistent cuddle
zombie data</em></p>
<p><span id="text_part0022.html_page_210" class="calibre4"></span>This
would be unfortunate. You don’t want your data to be inconsistent when
you’re trying to recover from the cuddle zombie apocalypse. However,
there’s no way to retain the state of an object at a specific moment in
time.</p>
<p>Additionally, in order to change the <span
class="literal1">cuddle_hunger_level</span> and <span
class="literal1">percent_deteriorated</span> simultaneously, you must be
extra careful. Otherwise, it’s possible for <span
class="literal1">fred</span> to be viewed in an inconsistent state,
because another thread might <span class="literal1">read</span> the
<span class="literal1">fred</span> object in between the two changes
that you intend to be simultaneous, like so:</p>
<pre class="programs"><code>fred.cuddle_hunger_level = fred.cuddle_hunger_level + 1
# At this time, another thread could read fred&#39;s attributes and
# &quot;perceive&quot; fred in an inconsistent state unless you use a mutex
fred.percent_deteriorated = fred.percent_deteriorated + 1</code></pre>
<p>This is another version of the mutual exclusion problem. In
object-oriented programming (OOP), you can manually address this problem
with a <em>mutex</em>, which ensures that only one thread can access a
resource (in this case, the <span class="literal1">fred</span> object)
at a time for the duration of the mutex.</p>
<p>The fact that objects are never stable doesn’t stop us from treating
them as the fundamental building blocks of programs. In fact, this is
considered an advantage of OOP. It doesn’t matter how the state changes;
you can still interact with a stable interface and everything will work
as it should. This conforms to our intuitive sense of the world. A piece
of wax is still the same piece of wax even if its properties change: if
I change its color, melt it, and pour it on the face of my enemy, I’d
still think of it as the same wax object I started with.</p>
<p>Also, in OOP, objects do things. They act on each other, changing
state as the program runs. Again, this conforms to our intuitive sense
of the world: change is the result of objects acting on each other. A
Person object pushes on a Door object and enters a House object.</p>
<h3 class="h2" id="text_part0022.html_ch10lev1sec2"><strong>Clojure
Metaphysics</strong></h3>
<p>In Clojure metaphysics, we would say that we never encounter the same
cuddle zombie twice. The cuddle zombie is not a discrete thing that
exists in the world independent of its mutations: it’s actually a
succession of <em>values.</em></p>
<p>The term <em>value</em> is used often by Clojurists, and its specific
meaning might differ from what you’re used to. Values are
<em>atomic</em> in the sense that they form a single irreducible unit or
component in a larger system; they’re indivisible, unchanging, stable
entities. Numbers are values: it wouldn’t make sense for the number 15
to mutate into another number. When you add or subtract from 15, you
don’t change the number 15; you just wind up with a different number.
Clojure’s data structures are also values because they’re immutable.
When you use <span class="literal1">assoc</span> on a map, you don’t
modify the original map; instead, you derive a new map.</p>
<p><span id="text_part0022.html_page_211" class="calibre4"></span>So a
value doesn’t change, but you can apply a <em>process</em> to a value to
produce a new value. For example, say we start with a value <em>F1</em>,
and then we apply the <em>Cuddle Zombie</em> process to <em>F1</em> to
produce the value <em>F2</em>. The process then gets applied to the
value <em>F2</em> to produce the value <em>F3</em>, and so on.</p>
<p>This leads to a different conception of <em>identity</em>. Instead of
understanding identity as inherent to a changing object, as in OO
metaphysics, Clojure metaphysics construes identity as something we
humans impose on a succession of unchanging values produced by a process
over time. We use <em>names</em> to designate identities. The name
<em>Fred</em> is a handy way to refer to a series of individual states
<em>F1</em>, <em>F2</em>, <em>F3</em>, and so on. From this viewpoint,
there’s no such thing as mutable state. Instead, <em>state</em> means
the value of an identity at a point in time.</p>
<p>Rich Hickey has used the analogy of phone numbers to explain state.
<em>Alan’s phone number</em> has changed 10 times, but we will always
call these numbers by the same name, <em>Alan’s phone number</em>.
Alan’s phone number five years ago is a different value than Alan’s
phone number today, and both are two states of Alan’s phone number
identity.</p>
<p>This makes sense when you consider that in your programs you are
dealing with information about the world. Rather than saying that
information has changed, you would say you’ve received new information.
At 12:00 <span class="small">PM</span> on Friday, Fred the Cuddle Zombie
was in a state of 50 percent decay. At 1:00 <span
class="small">PM</span>, he was 60 percent decayed. These are both facts
that you can process, and the introduction of a new fact does not
invalidate a previous fact. Even though Fred’s decay increased from 50
percent to 60 percent, it’s still true that at 12:00 <span
class="small">PM</span> he was in a state of 50 percent decay.</p>
<p><a href="#text_part0022.html_ch10fig2" class="calibre4">Figure
10-2</a> shows how you might visualize values, process, identity, and
state.</p>
<div class="image">
<img src="images_00064.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0022.html_ch10fig2"
class="calibre4"></span><em>Figure 10-2: Values, process, identity, and
state</em></p>
<p>These values don’t act on each other, and they can’t be changed. They
can’t <em>do</em> anything. Change only occurs when a) a process
generates a new value and b) we choose to associate the identity with
the new value.</p>
<p>To handle this sort of change, Clojure uses <em>reference types</em>.
Reference types let you manage identities in Clojure. Using them, you
can name an identity and retrieve its state. Let’s look at the simplest
of these, the <em>atom</em>.</p>
<h3 class="h2" id="text_part0022.html_ch10lev1sec3"><span
id="text_part0022.html_page_212"
class="calibre1"></span><strong>Atoms</strong></h3>
<p>Clojure’s atom reference type allows you to endow a succession of
related values with an identity. Here’s how you create one:</p>
<pre class="programs"><code>(def fred (atom {:cuddle-hunger-level 0
                 :percent-deteriorated 0}))</code></pre>
<p>This creates a new atom and binds it to the name <span
class="literal1">fred</span>. This atom <em>refers</em> to the value
<span class="literal1">{:cuddle-hunger-level 0 :percent-deteriorated
0}</span>, and you would say that that’s its current state.</p>
<p>To get an atom’s current state, you dereference it. Here’s Fred’s
current state:</p>
<pre class="programs"><code>@fred
; =&gt; {:cuddle-hunger-level 0, :percent-deteriorated 0}</code></pre>
<p>Unlike futures, delays, and promises, dereferencing an atom (or any
other reference type) will never block. When you dereference futures,
delays, and promises, it’s like you’re saying “I need a value now, and I
will wait until I get it,” so it makes sense that the operation would
block. However, when you dereference a reference type, it’s like you’re
saying “give me the value I’m currently referring to,” so it makes sense
that the operation doesn’t block, because it doesn’t have to wait for
anything.</p>
<p>In the Ruby example in <a href="#text_part0022.html_ch10list1"
class="calibre4">Listing 10-1</a>, we saw how object data could change
while you try to log it on a separate thread. There’s no danger of that
happening when using atoms to manage state, because each state is
immutable. Here’s how you could log a zombie’s state with <span
class="literal1">println</span>:</p>
<pre class="programs"><code>(let [zombie-state @fred]
  (if (&gt;= (:percent-deteriorated zombie-state) 50)
    (future (println (:percent-deteriorated zombie-state)))))</code></pre>
<p>The problem with the Ruby example in <a
href="#text_part0022.html_ch10list1" class="calibre4">Listing 10-1</a>
was that it took two steps to read the zombie’s two attributes, and some
other thread could have changed those attributes in between the two
steps. However, by using atoms to refer to immutable data structures,
you only have to perform one read, and the data structure returned won’t
get altered by another thread.</p>
<p>To update the atom so that it refers to a new state, you use <span
class="literal1">swap!</span>. This might seem contradictory, because I
said that atomic values are unchanging. Indeed, they are! But now we’re
working with the atom <em>reference type</em>, a construct that refers
to atomic values. The atomic values don’t change, but the reference type
can be updated and assigned a new value.</p>
<p><span class="literal1">swap!</span> receives an atom and a function
as arguments. It applies the function to the atom’s current state to
produce a new value, and then it updates <span
id="text_part0022.html_page_213" class="calibre4"></span>the atom to
refer to this new value. The new value is also returned. Here’s how you
might increase Fred’s cuddle hunger level by one:</p>
<pre class="programs"><code>(swap! fred
       (fn [current-state]
         (merge-with + current-state {:cuddle-hunger-level 1})))
; =&gt; {:cuddle-hunger-level 1, :percent-deteriorated 0}</code></pre>
<p>Dereferencing <span class="literal1">fred</span> will return the new
state:</p>
<pre class="programs"><code>@fred
; =&gt; {:cuddle-hunger-level 1, :percent-deteriorated 0}</code></pre>
<p>Unlike Ruby, it’s not possible for <span class="literal1">fred</span>
to be in an inconsistent state, because you can update the hunger level
and deterioration percentage at the same time, like this:</p>
<pre class="programs"><code>(swap! fred
       (fn [current-state]
         (merge-with + current-state {:cuddle-hunger-level 1
                                      :percent-deteriorated 1})))
; =&gt; {:cuddle-hunger-level 2, :percent-deteriorated 1}</code></pre>
<p>This code passes <span class="literal1">swap!</span> a function that
takes only one argument, <span class="literal1">current-state</span>.
You can also pass <span class="literal1">swap!</span> a function that
takes multiple arguments. For example, you could create a function that
takes two arguments, a zombie state and the amount by which to increase
its cuddle hunger level:</p>
<pre class="programs"><code>(defn increase-cuddle-hunger-level
  [zombie-state increase-by]
  (merge-with + zombie-state {:cuddle-hunger-level increase-by}))</code></pre>
<p>Let’s test <span class="literal1">increase-cuddle-hunger-level</span>
out real quick on a zombie state.</p>
<pre class="programs"><code>(increase-cuddle-hunger-level @fred 10)
; =&gt; {:cuddle-hunger-level 12, :percent-deteriorated 1}</code></pre>
<p>Note that this code doesn’t actually update <span
class="literal1">fred</span>, because we’re not using <span
class="literal1">swap!</span> We’re just making a normal function call
to <span class="literal1">increase-cuddle-hunger-level</span>, which
returns a result.</p>
<p>Now call <span class="literal1">swap!</span> with the additional
arguments, and <span class="literal1">@fred</span> will be updated, like
this:</p>
<pre class="programs"><code>(swap! fred increase-cuddle-hunger-level 10)
; =&gt; {:cuddle-hunger-level 12, :percent-deteriorated 1}


@fred
; =&gt; {:cuddle-hunger-level 12, :percent-deteriorated 1}</code></pre>
<p><span id="text_part0022.html_page_214" class="calibre4"></span>Or you
could express the whole thing using Clojure’s built-in functions. The
<span class="literal1">update-in</span> function takes three arguments:
a collection, a vector for identifying which value to update, and a
function to update that value. It can also take additional arguments
that get passed to the update function. Here are a couple of
examples:</p>
<pre class="programs"><code>(update-in {:a {:b 3}} [:a :b] inc)
; =&gt; {:a {:b 4}}


(update-in {:a {:b 3}} [:a :b] + 10)
; =&gt; {:a {:b 13}}</code></pre>
<p>In the first example, you’re updating the map <span
class="literal1">{:a {:b 3}}</span>. Clojure uses the vector <span
class="literal1">[:a :b]</span> to traverse the nested maps; <span
class="literal1">:a</span> yields the nested map <span
class="literal1">{:b 3}</span>, and <span class="literal1">:b</span>
yields the value <span class="literal1">3</span>. Clojure applies the
<span class="literal1">inc</span> function to <span
class="literal1">3</span> and returns a new map with <span
class="literal1">3</span> replaced by <span class="literal1">4</span>.
The second example is similar. The only difference is that you’re using
the addition function and you’re supplying <span
class="literal1">10</span> as an additional argument; Clojure ends up
calling <span class="literal1">(+ 3 10)</span>.</p>
<p>Here’s how you can use the <span class="literal1">update-in</span>
function to change Fred’s state:</p>
<pre class="programs"><code>(swap! fred update-in [:cuddle-hunger-level] + 10)
; =&gt; {:cuddle-hunger-level 22, :percent-deteriorated 1}</code></pre>
<p>By using atoms, you can retain past state. You can dereference an
atom to retrieve State 1, and then update the atom, creating State 2,
and still make use of State 1:</p>
<pre class="programs"><code>(let [num (atom 1)
      s1 @num]
  (swap! num inc)
  (println &quot;State 1:&quot; s1)
  (println &quot;Current state:&quot; @num))
; =&gt; State 1: 1
; =&gt; Current state: 2</code></pre>
<p>This code creates an atom named <span class="literal1">num</span>,
retrieves its state, updates its state, and then prints its past state
and its current state, showing that I wasn’t trying to trick you when I
said you can retain past state, and therefore you can trust me with all
manner of things—including your true name, which I promise to utter only
to save you from mortal danger.</p>
<p>This is all interesting and fun, but what happens if two separate
threads call <span class="literal1">(swap! fred
increase-cuddle-hunger-level 1)</span>? Is it possible for one of the
increments to get lost the way it did in the Ruby example at <a
href="#text_part0022.html_ch10list1" class="calibre4">Listing
10-1</a>?</p>
<p>The answer is no! <span class="literal1">swap!</span> implements
<em>compare-and-set</em> semantics, meaning it does the following
internally:</p>
<p>1. It reads the current state of the atom.</p>
<p>2. It then applies the update function to that state.</p>
<p><span id="text_part0022.html_page_215" class="calibre4"></span>3.
Next, it checks whether the value it read in step 1 is identical to the
atom’s current value.</p>
<p>4. If it is, then <span class="literal1">swap!</span> updates the
atom to refer to the result of step 2.</p>
<p>5. If it isn’t, then <span class="literal1">swap!</span> retries,
going through the process again with step 1.</p>
<p>This process ensures that no swaps will ever get lost.</p>
<p>One detail to note about <span class="literal1">swap!</span> is that
atom updates happen synchronously; they will block their thread. For
example, if your update function calls <span
class="literal1">Thread/sleep 1000</span> for some reason, the thread
will block for at least a second while <span
class="literal1">swap!</span> completes.</p>
<p>Sometimes you’ll want to update an atom without checking its current
value. For example, you might develop a serum that sets a cuddle
zombie’s hunger level and deterioration back to zero. For those cases,
you can use the <span class="literal1">reset!</span> function:</p>
<pre class="programs"><code>(reset! fred {:cuddle-hunger-level 0
              :percent-deteriorated 0})</code></pre>
<p>And that covers all the core functionality of atoms! To recap: atoms
implement Clojure’s concept of state. They allow you to endow a series
of immutable values with an identity. They offer a solution to the
reference cell and mutual exclusion problems through their
compare-and-set semantics. They also allow you to work with past states
without fear of them mutating in place.</p>
<p>In addition to these core features, atoms also share two features
with the other reference types. You can attach both <em>watches</em> and
<em>validators</em> to atoms. Let’s look at those now.</p>
<h3 class="h2" id="text_part0022.html_ch10lev1sec4"><strong>Watches and
Validators</strong></h3>
<p>Watches allow you to be super creepy and check in on your reference
types’ every move. Validators allow you to be super controlling and
restrict what states are allowable. Both watches and validators are
plain ol’ functions.</p>
<h4 class="h2"
id="text_part0022.html_ch10lev2sec1"><em><strong>Watches</strong></em></h4>
<p>A <em>watch</em> is a function that takes four arguments: a key, the
reference being watched, its previous state, and its new state. You can
register any number of watches with a reference type.</p>
<p>Let’s say that a zombie’s shuffle speed (measured in shuffles per
hour, or SPH) is dependent on its hunger level and deterioration. Here’s
how you’d calculate it, multiplying the cuddle hunger level by how whole
it is:</p>
<pre class="programs"><code>(defn shuffle-speed
  [zombie]
  (* (:cuddle-hunger-level zombie)
     (- 100 (:percent-deteriorated zombie))))</code></pre>
<p><span id="text_part0022.html_page_216" class="calibre4"></span>Let’s
also say that you want to be alerted whenever a zombie’s shuffle speed
reaches the dangerous level of 5,000 SPH. Otherwise, you want to be told
that everything’s okay. Here’s a watch function you could use to print a
warning message if the SPH is above 5,000 and print an all’s-well
message otherwise:</p>
<pre class="programs"><code>(defn shuffle-alert
  [key watched old-state new-state]
  (let [sph (shuffle-speed new-state)]
    (if (&gt; sph 5000)
      (do
        (println &quot;Run, you fool!&quot;)
        (println &quot;The zombie&#39;s SPH is now &quot; sph)
        (println &quot;This message brought to your courtesy of &quot; key))
      (do
        (println &quot;All&#39;s well with &quot; key)
        (println &quot;Cuddle hunger: &quot; (:cuddle-hunger-level new-state))
        (println &quot;Percent deteriorated: &quot; (:percent-deteriorated new-state))
        (println &quot;SPH: &quot; sph)))))</code></pre>
<p>Watch functions take four arguments: a key that you can use for
reporting, the atom being watched, the state of the atom before its
update, and the state of the atom after its update. This watch function
calculates the shuffle speed of the new state and prints a warning
message if it’s too high and an all’s-well message when the shuffle
speed is safe, as mentioned above. In both sets of messages, the <span
class="literal1">key</span> is used to let you know the source of the
message.</p>
<p>You can attach this function to <span class="literal1">fred</span>
with <span class="literal1">add-watch.</span> The general form of <span
class="literal1">add-watch</span> is <span
class="literal1">(add-watch</span> <em><span class="literal1">ref key
watch-fn</span></em><span class="literal1">)</span>. In this example,
we’re resetting <span class="literal1">fred</span>’s state, adding the
<span class="literal1">shuffle-alert</span> watch function, and then
updating <span class="literal1">fred</span>’s state a couple of times to
trigger <span class="literal1">shuffle-alert</span>:</p>
<pre class="programs"><code>(reset! fred {:cuddle-hunger-level 22
              :percent-deteriorated 2})
(add-watch fred :fred-shuffle-alert shuffle-alert)
(swap! fred update-in [:percent-deteriorated] + 1)
; =&gt; All&#39;s well with  :fred-shuffle-alert
; =&gt; Cuddle hunger:  22
; =&gt; Percent deteriorated:  3
; =&gt; SPH:  2134


(swap! fred update-in [:cuddle-hunger-level] + 30)
; =&gt; Run, you fool!
; =&gt; The zombie&#39;s SPH is now 5044
; =&gt; This message brought to your courtesy of :fred-shuffle-alert</code></pre>
<p>This example watch function didn’t use <span
class="literal1">watched</span> or <span
class="literal1">old-state</span>, but they’re there for you if the need
arises. Now let’s cover validators.</p>
<h4 class="h2" id="text_part0022.html_ch10lev2sec2"><span
id="text_part0022.html_page_217"
class="calibre1"></span><em><strong>Validators</strong></em></h4>
<p><em>Validators</em> let you specify what states are allowable for a
reference. For example, here’s a validator that you could use to ensure
that a zombie’s <span class="literal1">:percent-deteriorated</span> is
between 0 and 100:</p>
<pre class="programs"><code>(defn percent-deteriorated-validator
  [{:keys [percent-deteriorated]}]
  (and (&gt;= percent-deteriorated 0)
       (&lt;= percent-deteriorated 100)))</code></pre>
<p>As you can see, the validator takes only one argument. When you add a
validator to a reference, the reference is modified so that, whenever
it’s updated, it will call this validator with the value returned from
the update function as its argument. If the validator fails by returning
<span class="literal1">false</span> or throwing an exception, the
reference won’t change to point to the new value.</p>
<p>You can attach a validator during atom creation:</p>
<pre class="programs"><code>(def bobby
  (atom
   {:cuddle-hunger-level 0 :percent-deteriorated 0}
    :validator percent-deteriorated-validator))
(swap! bobby update-in [:percent-deteriorated] + 200)
; This throws &quot;Invalid reference state&quot;</code></pre>
<p>In this example, <span
class="literal1">percent-deteriorated-validator</span> returned <span
class="literal1">false</span> and the atom update failed.</p>
<p>You can throw an exception to get a more descriptive error
message:</p>
<pre class="programs"><code>(defn percent-deteriorated-validator
  [{:keys [percent-deteriorated]}]
  (or (and (&gt;= percent-deteriorated 0)
           (&lt;= percent-deteriorated 100))
      (throw (IllegalStateException. &quot;That&#39;s not mathy!&quot;))))
(def bobby
  (atom
   {:cuddle-hunger-level 0 :percent-deteriorated 0}
    :validator percent-deteriorated-validator))
(swap! bobby update-in [:percent-deteriorated] + 200)
; This throws &quot;IllegalStateException That&#39;s not mathy!&quot;</code></pre>
<p>Pretty great! Now let’s look at refs.</p>
<h3 class="h2" id="text_part0022.html_ch10lev1sec5"><span
id="text_part0022.html_page_218"
class="calibre1"></span><strong>Refs</strong></h3>
<p>Atoms are ideal for managing the state of independent identities.
Sometimes, though, we need to express that an event should update the
state of more than one identity simultaneously. <em>Refs</em> are the
perfect tool for this scenario.</p>
<p>A classic example of this is recording sock gnome transactions. As we
all know, sock gnomes take a single sock from every clothes dryer around
the world. They use these socks to incubate their young. In return for
this <em>“</em>gift,” sock gnomes protect your home from El Chupacabra.
If you haven’t been visited by El Chupacabra lately, you have sock
gnomes to thank.</p>
<div class="image">
<img src="images_00065.jpeg" class="calibre3" alt="image" />
</div>
<p>To model sock transfers, we need to express that a dryer has lost a
sock and a gnome has gained a sock simultaneously. One moment the sock
belongs to the dryer; the next it belongs to the gnome. The sock should
never appear to belong to both the dryer and the gnome, nor should it
appear to belong to neither.</p>
<h4 class="h2" id="text_part0022.html_ch10lev2sec3"><em><strong>Modeling
Sock Transfers</strong></em></h4>
<p>You can model this sock transfer with refs. Refs allow you to update
the state of multiple identities using transaction semantics. These
transactions have three features:</p>
<p>• They are <em>atomic</em>, meaning that all refs are updated or none
of them are.</p>
<p>• They are <em>consistent</em>, meaning that the refs always appear
to have valid states. A sock will always belong to a dryer or a gnome,
but never both or neither.</p>
<p>• They are <em>isolated</em>, meaning that transactions behave as if
they executed serially; if two threads are simultaneously running
transactions that alter the same ref, one transaction will retry. This
is similar to the compare-and-set semantics of atoms.</p>
<p>You might recognize these as the <em>A</em>, <em>C</em>, and
<em>I</em> in the ACID properties of database transactions. You can
think of refs as giving you the same concurrency safety as database
transactions, only with in-memory data.</p>
<p>Clojure uses <em>software transactional memory (STM)</em> to
implement this behavior. STM is very cool, but when you’re starting with
Clojure, you don’t need to know much about it; you just need to know how
to use it, which is what this section shows you.</p>
<p>Let’s start transferring some socks! First, you’ll need to code up
some sock- and gnome-creation technology. The following code defines
some sock varieties, then defines a couple of helper functions: <span
class="literal1">sock-count</span> will be <span
id="text_part0022.html_page_219" class="calibre4"></span>used to help
keep track of how many of each kind of sock belongs to either a gnome or
a dryer, and <span class="literal1">generate-sock-gnome</span> creates a
fresh, sockless gnome:</p>
<pre class="programs"><code>(def sock-varieties
  #{&quot;darned&quot; &quot;argyle&quot; &quot;wool&quot; &quot;horsehair&quot; &quot;mulleted&quot;
    &quot;passive-aggressive&quot; &quot;striped&quot; &quot;polka-dotted&quot;
    &quot;athletic&quot; &quot;business&quot; &quot;power&quot; &quot;invisible&quot; &quot;gollumed&quot;})


(defn sock-count
  [sock-variety count]
  {:variety sock-variety
   :count count})


(defn generate-sock-gnome
  &quot;Create an initial sock gnome state with no socks&quot;
  [name]
  {:name name
   :socks #{}})</code></pre>
<p>Now you can create your actual refs. The gnome will have 0 socks. The
dryer, on the other hand, will have a set of sock pairs generated from
the set of sock varieties. Here are our refs:</p>
<pre class="programs"><code>(def sock-gnome (ref (generate-sock-gnome &quot;Barumpharumph&quot;)))
(def dryer (ref {:name &quot;LG 1337&quot;
                 :socks (set (map #(sock-count % 2) sock-varieties))}))</code></pre>
<p>You can dereference refs just like you can dereference atoms. In this
example, the order of your socks will probably be different because
we’re using an unordered set:</p>
<pre class="programs"><code>(:socks @dryer)
; =&gt; #{{:variety &quot;passive-aggressive&quot;, :count 2} {:variety &quot;power&quot;, :count 2}
       {:variety &quot;athletic&quot;, :count 2} {:variety &quot;business&quot;, :count 2}
       {:variety &quot;argyle&quot;, :count 2} {:variety &quot;horsehair&quot;, :count 2}
       {:variety &quot;gollumed&quot;, :count 2} {:variety &quot;darned&quot;, :count 2}
       {:variety &quot;polka-dotted&quot;, :count 2} {:variety &quot;wool&quot;, :count 2}
       {:variety &quot;mulleted&quot;, :count 2} {:variety &quot;striped&quot;, :count 2}
       {:variety &quot;invisible&quot;, :count 2}}</code></pre>
<p>Now everything’s in place to perform the transfer. We’ll want to
modify the <span class="literal1">sock-gnome</span> ref to show that it
has gained a sock and modify the <span class="literal1">dryer</span> ref
to show that it’s lost a sock. You modify refs using <span
class="literal1">alter</span>, and you must use <span
class="literal1">alter</span> within a transaction. <span
class="literal1">dosync</span> initiates a transaction and defines its
extent; you put all transaction operations in its body. Here we use
these tools to define a <span class="literal1">steal-sock</span>
function, and then call it on our two refs:</p>
<pre class="programs"><code>(defn steal-sock
  [gnome dryer]
  (dosync

  (when-let [pair (some #(if (= (:count %) 2) %) (:socks @dryer))]
    (let [updated-count (sock-count (:variety pair) 1)]
      (alter gnome update-in [:socks] conj updated-count)
      (alter dryer update-in [:socks] disj pair)
      (alter dryer update-in [:socks] conj updated-count)))))
(steal-sock sock-gnome dryer)


(:socks @sock-gnome)
; =&gt; #{{:variety &quot;passive-aggressive&quot;, :count 1}}</code></pre>
<p>Now the gnome has one passive-aggressive sock, and the dryer has one
less (your gnome may have stolen a different sock because the socks are
stored in an unordered set). Let’s make sure all passive-aggressive
socks are accounted for:</p>
<pre class="programs"><code>(defn similar-socks
  [target-sock sock-set]
  (filter #(= (:variety %) (:variety target-sock)) sock-set))


(similar-socks (first (:socks @sock-gnome)) (:socks @dryer))
; =&gt; ({:variety &quot;passive-aggressive&quot;, :count 1})</code></pre>
<p>There are a couple of details to note here: when you <span
class="literal1">alter</span> a ref, the change isn’t immediately
visible outside of the current transaction. This is what lets you call
<span class="literal1">alter</span> on the <span
class="literal1">dryer</span> twice within a transaction without
worrying about whether <span class="literal1">dryer</span> will be read
in an inconsistent state. Similarly, if you <span
class="literal1">alter</span> a ref and then <span
class="literal1">deref</span> it within the same transaction, the <span
class="literal1">deref</span> will return the new state.</p>
<p>Here’s an example to demonstrate this idea of in-transaction
state:</p>
<pre class="programs"><code>(def counter (ref 0))
(future
  (dosync
   (alter counter inc)
   (println @counter)
   (Thread/sleep 500)
   (alter counter inc)
   (println @counter)))
(Thread/sleep 250)
(println @counter)</code></pre>
<p>This prints 1, 0 , and 2, in that order. First, you create a ref,
<span class="literal1">counter</span>, which holds the number 0. Then
you use <span class="literal1">future</span> to create a new thread to
run a transaction on. On the transaction thread, you increment the
counter and print it, and the number 1 gets printed. Meanwhile, the main
thread waits 250 milliseconds and prints the counter’s value, too.
However, the value of counter on the main thread is still 0—the main
thread is outside of the transaction and doesn’t have access to the
transaction’s state. It’s like the transaction has its own private area
for trying out changes to the state, and the rest of the world can’t
know about them until the transaction <span
id="text_part0022.html_page_221" class="calibre4"></span>is done. This
is further illustrated in the transaction code: after it prints the
first time, it increments the counter again from 1 to 2 and prints the
result, 2.</p>
<p>The transaction will try to commit its changes only when it ends. The
commit works similarly to the compare-and-set semantics of atoms. Each
ref is checked to see whether it’s changed since you first tried to
alter it. If <em>any</em> of the refs have changed, then <em>none</em>
of the refs is updated and the transaction is retried. For example, if
Transaction A and Transaction B are both attempted at the same time and
events occur in the following order, Transaction A will be retried:</p>
<p>1. Transaction A: alter gnome</p>
<p>2. Transaction B: alter gnome</p>
<p>3. Transaction B: alter dryer</p>
<p>4. Transaction B: alter dryer</p>
<p>5. Transaction B: commit—successfully updates gnome and dryer</p>
<p>6. Transaction A: alter dryer</p>
<p>7. Transaction A: alter dryer</p>
<p>8. Transaction A: commit—fails because dryer and gnome have changed;
retries.</p>
<p>And there you have it! Safe, easy, concurrent coordination of state
changes. But that’s not all! Refs have one more trick up their
suspiciously long sleeve: <span class="literal1">commute</span>.</p>
<h4 class="h2"
id="text_part0022.html_ch10lev2sec4"><em><strong>commute</strong></em></h4>
<p><span class="literal1">commute</span> allows you to update a ref’s
state within a transaction, just like <span
class="literal1">alter</span>. However, its behavior at commit time is
completely different. Here’s how <span class="literal1">alter</span>
behaves:</p>
<p>1. Reach outside the transaction and read the ref’s current
state.</p>
<p>2. Compare the current state to the state the ref started with within
the transaction.</p>
<p>3. If the two differ, make the transaction retry.</p>
<p>4. Otherwise, commit the altered ref state.</p>
<p><span class="literal1">commute</span>, on the other hand, behaves
like this at commit time:</p>
<p>1. Reach outside the transaction and read the ref’s current
state.</p>
<p>2. Run the <span class="literal1">commute</span> function again using
the current state.</p>
<p>3. Commit the result.</p>
<p>As you can see, <span class="literal1">commute</span> doesn’t ever
force a transaction retry. This can help improve performance, but it’s
important that you only use <span class="literal1">commute</span> when
you’re sure that it’s not possible for your refs to end up in an invalid
state. Let’s look at examples of safe and unsafe uses of <span
class="literal1">commute</span>.</p>
<p><span id="text_part0022.html_page_222" class="calibre4"></span>Here’s
an example of a safe use. The <span
class="literal1">sleep-print-update</span> function returns the updated
state but also sleeps the specified number of milliseconds so we can
force transaction overlap. It prints the state that it’s attempting to
update so we can gain insight into what’s going on:</p>
<pre class="programs"><code>(defn sleep-print-update
  [sleep-time thread-name update-fn]
  (fn [state]
    (Thread/sleep sleep-time)
    (println (str thread-name &quot;: &quot; state))
    (update-fn state)))
(def counter (ref 0))
(future (dosync (commute counter (sleep-print-update 100 &quot;Thread A&quot; inc))))
(future (dosync (commute counter (sleep-print-update 150 &quot;Thread B&quot; inc))))</code></pre>
<p>Here’s a timeline of what prints:</p>
<pre class="programs"><code>Thread A: 0 | 100ms
Thread B: 0 | 150ms
Thread A: 0 | 200ms
Thread B: 1 | 300ms</code></pre>
<p>Notice that the last printed line reads <span class="literal1">Thread
B: 1</span>. That means that <span
class="literal1">sleep-print-update</span> receives <span
class="literal1">1</span> as the argument for state the second time it
runs. That makes sense, because Thread A has committed its result by
that point. If you dereference <span class="literal1">counter</span>
after the transactions run, you’ll see that the value is <span
class="literal1">2</span>.</p>
<p>Now, here’s an example of unsafe commuting:</p>
<pre class="programs"><code>(def receiver-a (ref #{}))
(def receiver-b (ref #{}))
(def giver (ref #{1}))
(do (future (dosync (let [gift (first @giver)]
                      (Thread/sleep 10)
                      (commute receiver-a conj gift)
                      (commute giver disj gift))))
    (future (dosync (let [gift (first @giver)]
                      (Thread/sleep 50)
                      (commute receiver-b conj gift)
                      (commute giver disj gift)))))


@receiver-a
; =&gt; #{1}


@receiver-b
; =&gt; #{1}


@giver
; =&gt; #{}</code></pre>
<p>The <span class="literal1">1</span> was given to both <span
class="literal1">receiver-a</span> and <span
class="literal1">receiver-b</span>, and you’ve ended up with two
instances of <span class="literal1">1</span>, which isn’t valid for your
program. What’s different <span id="text_part0022.html_page_223"
class="calibre4"></span>about this example is that the functions that
are applied, essentially <span class="literal1">#(conj % gift)</span>
and <span class="literal1">#(disj % gift)</span>, are derived from the
state of <span class="literal1">giver</span>. Once <span
class="literal1">giver</span> changes, the derived functions produce an
invalid state, but <span class="literal1">commute</span> doesn’t care
that the resulting state is invalid and commits the result anyway. The
lesson here is that although <span class="literal1">commute</span> can
help speed up your programs, you have to be judicious about when to use
it.</p>
<p>Now you’re ready to start using refs safely and sanely. Refs have a
few more nuances that I won’t cover here, but if you’re curious about
them, you can research the <span class="literal1">ensure</span> function
and the phenomenon <em>write skew</em>.</p>
<p>On to the final reference type that this book covers:
<em>vars</em>.</p>
<h3 class="h2"
id="text_part0022.html_ch10lev1sec6"><strong>Vars</strong></h3>
<p>You’ve already learned a bit about vars in <a
href="#text_part0017.html_ch06" class="calibre4">Chapter 6</a>. To recap
briefly, <em>vars</em> are associations between symbols and objects. You
create new vars with <span class="literal1">def</span>.</p>
<p>Although vars aren’t used to manage state in the same way as atoms
and refs, they do have a couple of concurrency tricks: you can
dynamically bind them, and you can alter their roots. Let’s look at
dynamic binding first.</p>
<h4 class="h2" id="text_part0022.html_ch10lev2sec5"><em><strong>Dynamic
Binding</strong></em></h4>
<p>When I first introduced <span class="literal1">def</span>, I implored
you to treat it as if it’s defining a constant. It turns out that vars
are a bit more flexible than that: you can create a <em>dynamic</em> var
whose binding can be changed. Dynamic vars can be useful for creating a
global name that should refer to different values in different
contexts.</p>
<h5 class="h3" id="text_part0022.html_ch10lev3sec1"><strong>Creating and
Binding Dynamic Vars</strong></h5>
<p>First, create a dynamic var:</p>
<pre class="programs"><code>(def ^:dynamic *notification-address* &quot;dobby@elf.org&quot;)</code></pre>
<p>Notice two important details here. First, you use <span
class="literal1">^:dynamic</span> to signal to Clojure that a var is
dynamic. Second, the var’s name is enclosed by asterisks. Lispers call
these <em>earmuffs</em>, which is adorable. Clojure requires you to
enclose the names of dynamic vars in earmuffs. This helps signal the
var’s <em>dynamicaltude</em> to other programmers.</p>
<p>Unlike regular vars, you can temporarily change the value of dynamic
vars by using <span class="literal1">binding</span>:</p>
<pre class="programs"><code>(binding [*notification-address* &quot;test@elf.org&quot;]
  *notification-address*)
; =&gt; &quot;test@elf.org&quot;</code></pre>
<p>You can also stack bindings (just like you can with <span
class="literal1">let</span>):</p>
<pre class="programs"><code>(binding [*notification-address* &quot;tester-1@elf.org&quot;]
  (println *notification-address*)

  (binding [*notification-address* &quot;tester-2@elf.org&quot;]
    (println *notification-address*))
  (println *notification-address*))
; =&gt; tester-1@elf.org
; =&gt; tester-2@elf.org
; =&gt; tester-1@elf.org</code></pre>
<p>Now that you know how to dynamically bind a var, let’s look at a
real-world application.</p>
<h5 class="h3" id="text_part0022.html_ch10lev3sec2"><strong>Dynamic Var
Uses</strong></h5>
<p>Let’s say you have a function that sends a notification email. In
this example, we’ll just return a string but pretend that the function
actually sends the email:</p>
<pre class="programs"><code>(defn notify
  [message]
  (str &quot;TO: &quot; *notification-address* &quot;\n&quot;
       &quot;MESSAGE: &quot; message))
(notify &quot;I fell.&quot;)
; =&gt; &quot;TO: dobby@elf.org\nMESSAGE: I fell.&quot;</code></pre>
<p>What if you want to test this function without spamming Dobby every
time your specs run? Here comes <span class="literal1">binding</span> to
the rescue:</p>
<pre class="programs"><code>(binding [*notification-address* &quot;test@elf.org&quot;]
  (notify &quot;test!&quot;))
; =&gt; &quot;TO: test@elf.org\nMESSAGE: test!&quot;</code></pre>
<p>Of course, you could have just defined <span
class="literal1">notify</span> to take an email address as an argument.
In fact, that’s often the right choice. Why would you want to use
dynamic vars instead?</p>
<p>Dynamic vars are most often used to name a resource that one or more
functions target. In this example, you can view the email address as a
resource that you write to. In fact, Clojure comes with a ton of
built-in dynamic vars for this purpose. <span
class="literal1">*out*</span>, for example, represents the standard
output for print operations. In your program, you could re-bind <span
class="literal1">*out*</span> so that print statements write to a file,
like so:</p>
<pre class="programs"><code>(binding [*out* (clojure.java.io/writer &quot;print-output&quot;)]
  (println &quot;A man who carries a cat by the tail learns
something he can learn in no other way.
-- Mark Twain&quot;))
(slurp &quot;print-output&quot;)
; =&gt; A man who carries a cat by the tail learns
     something he can learn in no other way.
     -- Mark Twain</code></pre>
<p><span id="text_part0022.html_page_225" class="calibre4"></span>This
is much less burdensome than passing an output destination to every
invocation of <span class="literal1">println</span>. Dynamic vars are a
great way to specify a common resource while retaining the flexibility
to change it on an ad hoc basis.</p>
<p>Dynamic vars are also used for configuration. For example, the
builtin var <span class="literal1">*print-length*</span> allows you to
specify how many items in a collection Clojure should print:</p>
<pre class="programs"><code>(println [&quot;Print&quot; &quot;all&quot; &quot;the&quot; &quot;things!&quot;])
; =&gt; [Print all the things!]


(binding [*print-length* 1]
  (println [&quot;Print&quot; &quot;just&quot; &quot;one!&quot;]))
; =&gt; [Print ...]</code></pre>
<p>Finally, it’s possible to <span class="literal1">set!</span> dynamic
vars that have been bound. Whereas the examples you’ve seen so far allow
you to convey information <em>in</em> to a function without having to
pass in the information as an argument, <span
class="literal1">set!</span> allows you convey information <em>out</em>
of a function without having to return it as an argument.</p>
<div class="image">
<img src="images_00066.jpeg" class="calibre3" alt="image" />
</div>
<p>For example, let’s say you’re a telepath, but your mind-reading
powers are a bit delayed. You can read people’s thoughts only after the
moment when it would have been useful for you to know them. Don’t feel
too bad, though; you’re still a telepath, which is awesome. Anyway, say
you’re trying to cross a bridge guarded by a troll who will eat you if
you don’t answer his riddle. His riddle is “What number between 1 and 2
am I thinking of?” In the event that the troll devours you, you can at
least die knowing what the troll was actually thinking.</p>
<p>In this example, you create the dynamic var <span
class="literal1">*troll-thought*</span> to convey the troll’s thought
out of the <span class="literal1">troll-riddle</span> function:</p>
<pre class="programs"><code>  (def ^:dynamic *troll-thought* nil)
  (defn troll-riddle
    [your-answer]
    (let [number &quot;man meat&quot;]
➊    (when (thread-bound? #&#39;*troll-thought*)
➋      (set! *troll-thought* number))
      (if (= number your-answer)
        &quot;TROLL: You can cross the bridge!&quot;
        &quot;TROLL: Time to eat you, succulent human!&quot;)))
(binding [*troll-thought* nil]
  (println (troll-riddle 2))
  (println &quot;SUCCULENT HUMAN: Oooooh! The answer was&quot; *troll-thought*))


; =&gt; TROLL: Time to eat you, succulent human!
; =&gt; SUCCULENT HUMAN: Oooooh! The answer was man meat</code></pre>
<p>You use the <span class="literal1">thread-bound?</span> function at
<span class="ent">➊</span> to check that the var has been bound, and if
it has, you <span class="literal1">set! *troll-thought*</span> to the
troll’s thought at <span class="ent">➋</span>.</p>
<p>The var returns to its original value outside of binding:</p>
<pre class="programs"><code>*troll-thought*
; =&gt; nil</code></pre>
<p>Notice that you have to pass <span
class="literal1">#'*troll-thought*</span> (including <span
class="literal1">#'</span>), not <span
class="literal1">*troll-thought*</span>, to the function <span
class="literal1">thread-bound?</span>. This is because <span
class="literal1">thread-bound?</span> takes the var itself as an
argument, not the value it refers to.</p>
<h5 class="h3" id="text_part0022.html_ch10lev3sec3"><strong>Per-Thread
Binding</strong></h5>
<p>One final point to note about binding: if you access a dynamically
bound var from within a manually created thread, the var will evaluate
to the original value. If you’re new to Clojure (and Java), this feature
won’t be immediately relevant; you can probably skip this section and
come back to it later.</p>
<p>Ironically, this binding behavior prevents us from easily creating a
fun demonstration in the REPL, because the REPL binds <span
class="literal1">*out*</span>. It’s as if all the code you run in the
REPL is implicitly wrapped in something like <span
class="literal1">(binding [*out* repl-printer] your-code</span>. If you
create a new thread, <span class="literal1">*out*</span> won’t be bound
to the REPL printer.</p>
<p>The following example uses some basic Java interop. Even if it looks
unfamiliar, the gist of the following code should be clear, and you’ll
learn exactly what’s going on in <a href="#text_part0024.html_ch12"
class="calibre4">Chapter 12</a>.</p>
<p>This code prints output to the REPL:</p>
<pre class="programs"><code>(.write *out* &quot;prints to repl&quot;)
; =&gt; prints to repl</code></pre>
<p>The following code doesn’t print output to the REPL, because <span
class="literal1">*out*</span> is not bound to the REPL printer:</p>
<pre class="programs"><code>(.start (Thread. #(.write *out* &quot;prints to standard out&quot;)))</code></pre>
<p>You can work around this by using this goofy code:</p>
<pre class="programs"><code>(let [out *out*]
  (.start
   (Thread. #(binding [*out* out]
               (.write *out* &quot;prints to repl from thread&quot;)))))</code></pre>
<p><span id="text_part0022.html_page_227" class="calibre4"></span>Or you
can use <span class="literal1">bound-fn</span>, which carries all the
current bindings to the new thread:</p>
<pre class="programs"><code>(.start (Thread. (bound-fn [] (.write *out* &quot;prints to repl from thread&quot;))))</code></pre>
<p>The <span class="literal1">let</span> binding captures <span
class="literal1">*out*</span> so we can then rebind it in the child
thread, which is goofy as hell. The point is that bindings don’t get
passed on to <em>manually</em> created threads. They do, however, get
passed on to futures. This is called <em>binding conveyance</em>.
Throughout this chapter, we’ve been printing from futures without any
problem, for example.</p>
<p>That’s it for dynamic binding. Let’s turn our attention to the last
var topic: altering var <em>roots</em>.</p>
<h4 class="h2" id="text_part0022.html_ch10lev2sec6"><em><strong>Altering
the Var Root</strong></em></h4>
<p>When you create a new var, the initial value that you supply is its
<em>root</em>:</p>
<pre class="programs"><code>(def power-source &quot;hair&quot;)</code></pre>
<p>In this example, <span class="literal1">"hair"</span> is the root
value of <span class="literal1">power-source</span>. Clojure lets you
permanently change this root value with the function <span
class="literal1">alter-var-root</span>:</p>
<pre class="programs"><code>(alter-var-root #&#39;power-source (fn [_] &quot;7-eleven parking lot&quot;))
power-source
; =&gt; &quot;7-eleven parking lot&quot;</code></pre>
<p>Just like when using <span class="literal1">swap!</span> to update an
atom or <span class="literal1">alter!</span> to update a ref, you use
<span class="literal1">alter-var-root</span> along with a function to
update the state of a var. In this case, the function is just returning
a new string that bears no relation to the previous value, unlike the
<span class="literal1">alter!</span> examples where we used <span
class="literal1">inc</span> to derive a new number from the current
number.</p>
<p>You’ll hardly ever want to do this. You especially don’t want to do
this to perform simple variable assignment. If you did, you’d be going
out of your way to create the binding as a mutable variable, which goes
against Clojure’s philosophy; it’s best to use the functional
programming techniques you learned in <a href="#text_part0016.html_ch05"
class="calibre4">Chapter 5</a>.</p>
<p>You can also temporarily alter a var’s root with <span
class="literal1">with-redefs</span>. This works similarly to binding
except the alteration will appear in child threads. Here’s an
example:</p>
<pre class="programs"><code>(with-redefs [*out* *out*]
        (doto (Thread. #(println &quot;with redefs allows me to show up in the REPL&quot;))
          .start
          .join))</code></pre>
<p>Using <span class="literal1">with-redefs</span> may be more
appropriate than using <span class="literal1">bindings</span> for
setting up a test environment. It’s also more widely applicable, in that
you can use it for any var, not just dynamic ones.</p>
<p>Now you know all about vars! Try not to hurt yourself or anyone you
know with them.</p>
<h3 class="h2" id="text_part0022.html_ch10lev1sec7"><span
id="text_part0022.html_page_228"
class="calibre1"></span><strong>Stateless Concurrency and Parallelism
with pmap</strong></h3>
<p>So far, this chapter has focused on tools that are designed to
mitigate the risks inherent in concurrent programming. You’ve learned
about the dangers born of shared access to mutable state and how Clojure
implements a reconceptualization of state that helps you write
concurrent programs safely.</p>
<p>Often, though, you’ll want to concurrent-ify tasks that are
completely independent of each other. There is no shared access to a
mutable state; therefore, there are no risks to running the tasks
concurrently and you don’t have to bother with using any of the tools
I’ve just been blabbing on about.</p>
<p>As it turns out, Clojure makes it easy for you to write code for
achieving stateless concurrency. In this section, you’ll learn about
<span class="literal1">pmap</span>, which gives you concurrency
performance benefits virtually for free.</p>
<p><span class="literal1">map</span> is a perfect candidate for
parallelization: when you use it, all you’re doing is deriving a new
collection from an existing collection by applying a function to each
element of the existing collection. There’s no need to maintain state;
each function application is completely independent. Clojure makes it
easy to perform a parallel map with <span class="literal1">pmap</span>.
With <span class="literal1">pmap</span>, Clojure handles the running of
each application of the mapping function on a separate thread.</p>
<p>To compare <span class="literal1">map</span> and <span
class="literal1">pmap</span>, we need a lot of example data, and to
generate this data, we’ll use the <span
class="literal1">repeatedly</span> function. This function takes another
function as an argument and returns a lazy sequence. The elements of the
lazy sequence are generated by calling the passed function, like
this:</p>
<pre class="programs"><code>(defn always-1
  []
  1)
(take 5 (repeatedly always-1))
; =&gt; (1 1 1 1 1)</code></pre>
<p>Here’s how you’d create a lazy seq of random numbers between 0 and
9:</p>
<pre class="programs"><code>(take 5 (repeatedly (partial rand-int 10)))
; =&gt; (1 5 0 3 4)</code></pre>
<p>Let’s use <span class="literal1">repeatedly</span> to create example
data that consists of a sequence of 3,000 random strings, each 7,000
characters long. We’ll compare <span class="literal1">map</span> and
<span class="literal1">pmap</span> by using them to run <span
class="literal1">clojure.string/lowercase</span> on the <span
class="literal1">orc-names</span> sequence created here:</p>
<pre class="programs"><code>(def alphabet-length 26)


;; Vector of chars, A-Z
(def letters (mapv (comp str char (partial + 65)) (range alphabet-length)))

(defn random-string
  &quot;Returns a random string of specified length&quot;
  [length]
  (apply str (take length (repeatedly #(rand-nth letters)))))


(defn random-string-list
  [list-length string-length]
  (doall (take list-length (repeatedly (partial random-string string-length)))))


(def orc-names (random-string-list 3000 7000))</code></pre>
<p>Because <span class="literal1">map</span> and <span
class="literal1">pmap</span> are lazy, we have to force them to be
realized. We don’t want the result to be printed to the REPL, though,
because that would take forever. The <span class="literal1">dorun</span>
function does just what we need: it realizes the sequence but returns
<span class="literal1">nil</span>:</p>
<pre class="programs"><code>(time (dorun (map clojure.string/lower-case orc-names)))
; =&gt; &quot;Elapsed time: 270.182 msecs&quot;


(time (dorun (pmap clojure.string/lower-case orc-names)))
; =&gt; &quot;Elapsed time: 147.562 msecs&quot;</code></pre>
<p>The serial execution with <span class="literal1">map</span> took
about 1.8 times longer than <span class="literal1">pmap,</span> and all
you had to do was add one extra letter! Your performance may be even
better, depending on the number of cores your computer has; this code
was run on a dual-core machine.</p>
<p>You might be wondering why the parallel version didn’t take exactly
half as long as the serial version. After all, it should take two cores
only half as much time as a single core, shouldn’t it? The reason is
that there’s always some overhead involved with creating and
coordinating threads. Sometimes, in fact, the time taken by this
overhead can dwarf the time of each function application, and <span
class="literal1">pmap</span> can actually take longer than <span
class="literal1">map</span>. <a href="#text_part0022.html_ch10fig3"
class="calibre4">Figure 10-3</a> shows how you can visualize this.</p>
<div class="image">
<img src="images_00067.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0022.html_ch10fig3"
class="calibre4"></span><em>Figure 10-3: Parallelization overhead can
dwarf task time, resulting in a performance decrease.</em></p>
<p><span id="text_part0022.html_page_230" class="calibre4"></span>We can
see this effect at work if we run a function on 20,000 abbreviated orc
names, each 300 characters long:</p>
<pre class="programs"><code>(def orc-name-abbrevs (random-string-list 20000 300))
(time (dorun (map clojure.string/lower-case orc-name-abbrevs)))
; =&gt; &quot;Elapsed time: 78.23 msecs&quot;
(time (dorun (pmap clojure.string/lower-case orc-name-abbrevs)))
; =&gt; &quot;Elapsed time: 124.727 msecs&quot;</code></pre>
<p>Now <span class="literal1">pmap</span> actually takes 1.6 times
<em>longer</em>.</p>
<p>The solution to this problem is to increase the <em>grain size</em>,
or the amount of work done by each parallelized task. In this case, the
task is to apply the mapping function to one element of the collection.
Grain size isn’t measured in any standard unit, but you’d say that the
grain size of <span class="literal1">pmap</span> is one by default.
Increasing the grain size to two would mean that you’re applying the
mapping function to two elements instead of one, so the thread that the
task is on is doing more work. <a href="#text_part0022.html_ch10fig4"
class="calibre4">Figure 10-4</a> shows how an increased grain size can
improve performance.</p>
<div class="image">
<img src="images_00068.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0022.html_ch10fig4"
class="calibre4"></span><em>Figure 10-4: Visualizing grain size in
relation to parallelization overhead</em></p>
<p>To actually accomplish this in Clojure, you can increase the grain
size by making each thread apply <span
class="literal1">clojure.string/lower-case</span> to multiple elements
instead of just one, using <span class="literal1">partition-all</span>.
<span class="literal1">partition-all</span> takes a seq and divides it
into seqs of the specified length:</p>
<pre class="programs"><code>(def numbers [1 2 3 4 5 6 7 8 9 10])
(partition-all 3 numbers)
; =&gt; ((1 2 3) (4 5 6) (7 8 9) (10))</code></pre>
<p>Now suppose you started out with code that looked like this:</p>
<pre class="programs"><code>(pmap inc numbers)</code></pre>
<p><span id="text_part0022.html_page_231" class="calibre4"></span>In
this case, the grain size is one because each thread applies <span
class="literal1">inc</span> to an element.</p>
<p>Now suppose you changed the code to this:</p>
<pre class="programs"><code>(pmap (fn [number-group] (doall (map inc number-group)))
      (partition-all 3 numbers))
; =&gt; ((2 3 4) (5 6 7) (8 9 10) (11))</code></pre>
<p>There are a few things going on here. First, you’ve now increased the
grain size to three because each thread now executes three applications
of the <span class="literal1">inc</span> function instead of one.
Second, notice that you have to call <span class="literal1">doall</span>
within the mapping function. This forces the lazy sequence returned by
<span class="literal1">(map inc number-group)</span> to be realized
within the thread. Third, we need to ungroup the result. Here’s how we
can do that:</p>
<pre class="programs"><code>(apply concat
       (pmap (fn [number-group] (doall (map inc number-group)))
             (partition-all 3 numbers)))</code></pre>
<p>Using this technique, we can increase the grain size of the orc name
lowercase-ification so each thread runs <span
class="literal1">clojure.string/lower-case</span> on 1,000 names instead
of just one:</p>
<pre class="programs"><code>(time
 (dorun
  (apply concat
         (pmap (fn [name] (doall (map clojure.string/lower-case name)))
               (partition-all 1000 orc-name-abbrevs)))))
; =&gt; &quot;Elapsed time: 44.677 msecs&quot;</code></pre>
<p>Once again the parallel version takes nearly half the time. Just for
fun, we can generalize this technique into a function called <span
class="literal1">ppmap</span>, for <em>partitioned pmap</em>. It can
receive more than one collection, just like <span
class="literal1">map</span>:</p>
<pre class="programs"><code>(defn ppmap
  &quot;Partitioned pmap, for grouping map ops together to make parallel
  overhead worthwhile&quot;
  [grain-size f &amp; colls]
  (apply concat
   (apply pmap
          (fn [&amp; pgroups] (doall (apply map f pgroups)))
          (map (partial partition-all grain-size) colls))))
(time (dorun (ppmap 1000 clojure.string/lower-case orc-name-abbrevs)))
; =&gt; &quot;Elapsed time: 44.902 msecs&quot;</code></pre>
<p>I don’t know about you, but I think this stuff is just fun. For even
more fun, check out the clojure.core.reducers library (<em><a
href="http://clojure.org/reducers/"
class="calibre4">http://clojure.org/reducers/</a></em>). This library
provides alternative implementations of seq functions like <span
class="literal1">map</span> and <span class="literal1">reduce</span>
that are usually speedier than their cousins in <span
class="literal1">clojure.core</span>. The <span
id="text_part0022.html_page_232" class="calibre4"></span>trade-off is
that they’re not lazy. Overall, the clojure.core.reducers library offers
a more refined and composable way of creating and using functions like
<span class="literal1">ppmap</span>.</p>
<h3 class="h2"
id="text_part0022.html_ch10lev1sec8"><strong>Summary</strong></h3>
<p>In this chapter, you learned more than most people know about safely
handling concurrent tasks. You learned about the metaphysics that
underlies Clojure’s reference types. In Clojure metaphysics, state is
the value of an identity at a point in time, and identity is a handy way
to refer to a succession of values produced by some process. Values are
atomic in the same way numbers are atomic. They’re immutable, and this
makes them safe to work with concurrently; you don’t have to worry about
other threads changing them while you’re using them.</p>
<p>The atom reference type allows you to create an identity that you can
safely update to refer to new values using <span
class="literal1">swap!</span> and <span class="literal1">reset!</span>.
The ref reference type is handy when you want to update more than one
identity using transaction semantics, and you update it with <span
class="literal1">alter!</span> and <span
class="literal1">commute!</span>.</p>
<p>Additionally, you learned how to increase performance by performing
stateless data transformations with <span class="literal1">pmap</span>
and the core.reducers library. Woohoo!</p>
<h3 class="h2" id="text_part0022.html_ch10lev1sec9"><strong><span
class="bordera">Exercises</span></strong></h3>
<p>1. Create an atom with the initial value 0, use <span
class="literal1">swap!</span> to increment it a couple of times, and
then dereference it.</p>
<p>2. Create a function that uses futures to parallelize the task of
downloading random quotes from <em><a
href="http://www.braveclojure.com/random-quote"
class="calibre4">http://www.braveclojure.com/random-quote</a></em> using
<span class="literal1">(slurp
"http://www.braveclojure.com/random-quote")</span>. The futures should
update an atom that refers to a total word count for all quotes. The
function will take the number of quotes to download as an argument and
return the atom’s final value. Keep in mind that you’ll need to ensure
that all futures have finished before returning the atom’s final value.
Here’s how you would call it and an example result:</p>
<pre class="programs"><code>(quote-word-count 5)
; =&gt; {&quot;ochre&quot; 8, &quot;smoothie&quot; 2}</code></pre>
<p>3. Create representations of two characters in a game. The first
character has 15 hit points out of a total of 40. The second character
has a healing potion in his inventory. Use refs and transactions to
model the consumption of the healing potion and the first character
healing.</p>
<p><span id="text_part0023.html"></span></p>
<h2 class="h1" id="text_part0023.html_ch11"><span
id="text_part0023.html_page_233" class="calibre1"></span><strong><span
class="big1">11</span></strong><br />
<strong>Mastering Concurrent Processes with core.async</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>One day, while you are walking down the street, you will be
surprised, intrigued, and a little disgusted to discover a hot dog
vending machine. Your scalp tingling with guilty curiosity, you won’t be
able to help yourself from pulling out three dollars and seeing if this
contraption actually works. After accepting your money with a click and
a whir, it pops out a fresh hot dog, bun and all.</p>
<p>The vending machine exhibits simple behavior: when it receives money,
it releases a hot dog and then gets ready for the next purchase. When
it’s out of hot dogs, it stops. All around us are hot dog vending
machines in different guises—independent entities concurrently
responding to events in the world. The espresso machine at your favorite
coffee shop, the pet hamster you loved as a child—everything can be
deconstructed into a set of behaviors that follow the general form “when
<em>x</em> happens, do <em>y</em>.” Even the programs we write are just
glorified hot dog vending machines, each one an <span
id="text_part0023.html_page_234" class="calibre4"></span>independent
process waiting for the next event, whether it’s a keystroke, a timeout,
or the arrival of data on a socket.</p>
<div class="image">
<img src="images_00069.jpeg" class="calibre3" alt="image" />
</div>
<p>Clojure’s core.async library allows you to create multiple
independent processes within a single program. This chapter describes a
useful model for thinking about this style of programming as well as the
practical details you need to know to actually write code. You’ll learn
how to use channels to communicate between independent processes created
by go blocks and <span class="literal1">thread</span>; a bit about how
Clojure manages threads efficiently with parking and blocking; how to
use <span class="literal1">alts!!</span>; and a more straightforward way
of creating queues. Finally, you’ll learn how to kick callbacks in the
butt with process pipelines.</p>
<h3 class="h2" id="text_part0023.html_ch11lev1sec1"><strong>Getting
Started with Processes</strong></h3>
<p>At the heart of core.async is the <em>process</em>, a concurrently
running unit of logic that responds to events. The process corresponds
to our mental model of the real world: entities interact with and
respond to each other independently without some kind of central control
mechanism pulling the strings. You put your money in the machine, and
out comes a hot dog, all without the Illuminati or Big Brother
orchestrating the whole thing. This differs from the view of concurrency
you’ve been exploring so far, where you’ve defined tasks that are either
mere extensions of the main thread of control (for example, achieving
data parallelism with <span class="literal1">pmap</span>) or tasks that
you have no interest in communicating with (like one-off tasks created
with <span class="literal1">future</span>).</p>
<p>It might be strange to think of a vending machine as a process:
vending machines are noun-y and thing-y, and processes are verb-y and
do-y. To get in the right mindset, try defining real-world objects as
the sum of their event-driven behavior. When a seed gets watered, it
sprouts; when a mother looks at her newborn child, she feels love; and
when you watch <em>Star Wars Episode I</em>, you are filled with anger
and despair. If you want to get super philosophical, consider whether
it’s possible to define every thing’s essence as the set of the events
it recognizes and how it responds. Is reality just the composition of
hot dog vending machines?</p>
<p><span id="text_part0023.html_page_235"
class="calibre4"></span>Anyway, enough of my yakking! Let’s move from
the theoretical to the concrete by creating some simple processes.
First, create a new Leiningen project called <em>playsync</em> with
<span class="literal1">lein new app playsync</span>. Then, open the file
<em>project.clj</em> and add core.async to the <span
class="literal1">:dependencies</span> vector so it reads as follows:</p>
<pre class="programs"><code>[[org.clojure/clojure &quot;1.7.0&quot;]
[org.clojure/core.async &quot;0.1.346.0-17112a-alpha&quot;]]</code></pre>
<div class="note">
<p><strong><span class="bordera1">NOTE</span></strong></p>
<p><em>It’s possible that the core.async version has advanced since I
wrote this. For the latest version, check the core.async GitHub project
page. But for the purpose of these exercises, please use the version
listed here.</em></p>
</div>
<p>Next, open <em>src/playsync/core.clj</em> and make it look like
this:</p>
<pre class="programs"><code>(ns playsync.core
  (:require [clojure.core.async
             :as a
             :refer [&gt;! &lt;! &gt;!! &lt;!! go chan buffer close! thread
                     alts! alts!! timeout]]))</code></pre>
<p>Now when you open this in a REPL, you’ll have the most frequently
used core.async functions at your disposal. Great! Before creating
something as sophisticated and revolutionary as a hot dog vending
machine, create a process that simply prints the message it
receives:</p>
<pre class="programs"><code>(def echo-chan (chan))
(go (println (&lt;! echo-chan)))
(&gt;!! echo-chan &quot;ketchup&quot;)
; =&gt; true
; =&gt; ketchup</code></pre>
<p>At the first line of code, you used the <span
class="literal1">chan</span> function to create a <em>channel</em> named
<span class="literal1">echo-chan</span>. Channels communicate
<em>messages</em>. You can <em>put</em> messages on a channel and
<em>take</em> messages off a channel. Processes <em>wait</em> for the
completion of put and take—these are the events that processes respond
to. You can think of processes as having two rules: 1) when trying to
put a message on a channel or take a message off of it, wait and do
nothing until the put or take succeeds, and 2) when the put or take
succeeds, continue executing.</p>
<p>On the next line, you used <span class="literal1">go</span> to create
a new process. Everything within the <span class="literal1">go</span>
expression—called a <em>go block</em>—runs concurrently on a separate
thread. Go blocks run your processes on a thread pool that contains a
number of threads equal to two plus the number of cores on your machine,
which means your program doesn’t have to create a new thread for each
process. This often results in better performance because you avoid the
overhead associated with creating threads.</p>
<p>In this case, the process <span class="literal1">(println (&lt;!
echo-chan))</span> expresses “when I take a message from <span
class="literal1">echo-chan</span>, print it.” The process is shunted to
another thread, freeing up the current thread and allowing you to
continue interacting with the REPL.</p>
<p><span id="text_part0023.html_page_236" class="calibre4"></span>In the
expression <span class="literal1">(&lt;! echo-chan)</span>, <span
class="literal1">&lt;!</span> is the <em>take</em> function. It listens
to the channel you give it as an argument, and the process it belongs to
waits until another process puts a message on the channel. When <span
class="literal1">&lt;!</span> retrieves a value, the value is returned
and the <span class="literal1">println</span> expression is
executed.</p>
<p>The expression <span class="literal1">(&gt;!! echo-chan
"ketchup")</span> <em>puts</em> the string <span
class="literal1">"ketchup"</span> on <span
class="literal1">echo-chan</span> and returns <span
class="literal1">true</span>. When you put a message on a channel, the
process blocks until another process takes the message. In this case,
the REPL process didn’t have to wait at all, because there was already a
process listening to the channel, waiting to take something off it.
However, if you do the following, your REPL will block indefinitely:</p>
<pre class="programs"><code>(&gt;!! (chan) &quot;mustard&quot;)</code></pre>
<p>You’ve created a new channel and put something on it, but there’s no
process listening to that channel. Processes don’t just wait to receive
messages; they also wait for the messages they put on a channel to be
taken.</p>
<h4 class="h2"
id="text_part0023.html_ch11lev2sec1"><em><strong>Buffering</strong></em></h4>
<p>It’s worth noting that the previous exercise contained <em>two</em>
processes: the one you created with <span class="literal1">go</span> and
the REPL process. These processes don’t have explicit knowledge of each
other, and they act independently.</p>
<p>Let’s imagine that these processes take place in a diner. The REPL is
the ketchup chef, and when he’s done with a batch, he belts out,
“Ketchup!” It’s entirely possible that the rest of the staff is outside
admiring the latest batch of oregano in their organic garden, and the
chef just sits and waits until someone shows up to take his ketchup. On
the flip side, the <span class="literal1">go</span> process represents
one of the staff, and he’s waiting patiently for something to respond
to. It could be that nothing ever happens, and he just waits
indefinitely until the restaurant closes.</p>
<p>This situation seems a little silly: what self-respecting ketchup
chef would just sit and wait for someone to take his latest batch before
making more ketchup? To avoid this tragedy, you can create buffered
channels:</p>
<pre class="programs"><code>(def echo-buffer (chan 2))
(&gt;!! echo-buffer &quot;ketchup&quot;)
; =&gt; true
(&gt;!! echo-buffer &quot;ketchup&quot;)
; =&gt; true
(&gt;!! echo-buffer &quot;ketchup&quot;)
; This blocks because the channel buffer is full</code></pre>
<p>(Be careful evaluating the last <span class="literal1">(&gt;!!
echo-buffer "ketchup")</span> because it will block your REPL. If you’re
using a Leiningen REPL, <span class="small">CTRL</span>-C will unblock
it.)</p>
<p>In this case, you’ve created a channel with buffer size 2. That means
you can put two values on the channel without waiting, but putting a
third one on means the process will wait until another process takes a
value from the channel. You can also create <em>sliding</em> buffers
with <span class="literal1">sliding-buffer</span>, <span
id="text_part0023.html_page_237" class="calibre4"></span>which drops
values in a first-in, first-out fashion; and <em>dropping</em> buffers
with <span class="literal1">dropping-buffer</span>, which discards
values in a last-in, first-out fashion. Neither of these buffers will
ever cause <span class="literal1">&gt;!!</span> to block.</p>
<p>By using buffers, the master ketchup chef can keep whipping up
batches of mouthwatering ketchup without having to wait for his staff to
take them away. If he’s using a regular buffer, it’s like he has a shelf
to put all his ketchup batches on; once the shelf is full, he’ll still
have to wait for space to open up. If he’s using a sliding buffer, he’d
throw away the oldest batch of ketchup when the shelf is full, slide all
the ketchup down, and put the new batch in the vacant space. With a
dropping buffer, he’d just knock the freshest batch off of the shelf and
put his new batch in that space.</p>
<p>Buffers are just elaborations of the core model: processes are
independent, concurrently executing units of logic that respond to
events. You can create processes with go blocks and communicate events
over channels.</p>
<h4 class="h2" id="text_part0023.html_ch11lev2sec2"><em><strong>Blocking
and Parking</strong></em></h4>
<p>You may have noticed that the take function <span
class="literal1">&lt;!</span> used only one exclamation point, whereas
the put function <span class="literal1">&gt;!!</span> used two. In fact,
both put and take have one-exclamation-point and two-exclamation-point
varieties. When do you use which? The simple answer is that you can use
one exclamation point inside go blocks, but you have to use two
exclamation points outside of them:</p>
<table class="topbot" data-border="0" data-cellpadding="0"
data-cellspacing="0" width="100%">
<thead class="calibre12">
<tr class="calibre13">
<th class="table_th" data-valign="top"><p> </p></th>
<th class="table_th" data-valign="top"><p><strong>Inside go
block</strong></p></th>
<th class="table_th" data-valign="top"><p><strong>Outside go
block</strong></p></th>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre13">
<td class="table1" data-valign="top"><p>put</p></td>
<td class="table1" data-valign="top"><p>&gt;! or &gt;!!</p></td>
<td class="table1" data-valign="top"><p>&gt;!!</p></td>
</tr>
<tr class="calibre13">
<td class="table1" data-valign="top"><p>take</p></td>
<td class="table1" data-valign="top"><p>&lt;! or &lt;!!</p></td>
<td class="table1" data-valign="top"><p>&lt;!!</p></td>
</tr>
</tbody>
</table>
<p>It all comes down to efficiency. Because go blocks use a thread pool
with a fixed size, you can create 1,000 go processes but use only a
handful of threads:</p>
<pre class="programs"><code>(def hi-chan (chan))
(doseq [n (range 1000)]
  (go (&gt;! hi-chan (str &quot;hi &quot; n))))</code></pre>
<p>To understand how Clojure accomplishes this, we need to explore how
processes <em>wait</em>. Waiting is a key aspect of working with
core.async processes: we’ve already established that <em>put</em> waits
until another process does a <em>take</em> on the same channel, and vice
versa. In this example, 1,000 processes are waiting for another process
to take from <span class="literal1">hi-chan</span>.</p>
<p>There are two varieties of waiting: <em>parking</em> and
<em>blocking</em>. Blocking is the kind of waiting you’re familiar with:
a thread stops execution until a task is complete. Usually this happens
when you’re doing some kind of I/O operation. The thread remains alive
but doesn’t do any work, so you have to create a new thread if you want
your program to continue working. In <a href="#text_part0021.html_ch09"
class="calibre4">Chapter 9</a>, you learned how to do this with <span
class="literal1">future</span>.</p>
<p><span id="text_part0023.html_page_238"
class="calibre4"></span>Parking frees up the thread so it can keep doing
work. Let’s say you have one thread and two processes, Process A and
Process B. Process A is running on the thread and then waits for a put
or take. Clojure moves Process A off the thread and moves Process B onto
the thread. If Process B starts waiting and Process A’s put or take has
finished, then Clojure will move Process B off the thread and put
Process A back on it. Parking allows the instructions from multiple
processes to interleave on a single thread, similar to the way that
using multiple threads allows interleaving on a single core. The
implementation of parking isn’t important; suffice it to say that it’s
only possible within go blocks, and it’s only possible when you use
<span class="literal1">&gt;!</span> and <span
class="literal1">&lt;!</span>, or <em>parking put</em> and <em>parking
take</em>. <span class="literal1">&gt;!!</span> and <span
class="literal1">&lt;!!</span> are <em>blocking put</em> and
<em>blocking take</em>.</p>
<h4 class="h2"
id="text_part0023.html_ch11lev2sec3"><em><strong>thread</strong></em></h4>
<p>There are definitely times when you’ll want to use blocking instead
of parking, like when your process will take a long time before putting
or taking, and for those occasions you should use <span
class="literal1">thread</span>:</p>
<pre class="programs"><code>(thread (println (&lt;!! echo-chan)))
(&gt;!! echo-chan &quot;mustard&quot;)
; =&gt; true
; =&gt; mustard</code></pre>
<p><span class="literal1">thread</span> acts almost exactly like <span
class="literal1">future</span>: it creates a new thread and executes a
process on that thread. Unlike <span class="literal1">future</span>,
instead of returning an object that you can dereference, <span
class="literal1">thread</span> returns a channel. When <span
class="literal1">thread</span>’s process stops, the process’s return
value is put on the channel that <span class="literal1">thread</span>
returns:</p>
<pre class="programs"><code>(let [t (thread &quot;chili&quot;)]
  (&lt;!! t))
; =&gt; &quot;chili&quot;</code></pre>
<p>In this case, the process doesn’t wait for any events; instead, it
stops immediately. Its return value is <span
class="literal1">"chili"</span>, which gets put on the channel that’s
bound to <span class="literal1">t.</span> We take from <span
class="literal1">t</span>, returning <span
class="literal1">"chili"</span>.</p>
<p>The reason you should use <span class="literal1">thread</span>
instead of a go block when you’re performing a long-running task is so
you don’t clog your thread pool. Imagine you’re running four processes
that download humongous files, save them, and then put the file paths on
a channel. While the processes are downloading files and saving these
files, Clojure can’t park their threads. It can park the thread only at
the last step, when the process puts the files’ paths on a channel.
Therefore, if your thread pool has only four threads, all four threads
will be used for downloading, and no other process will be allowed to
run until one of the downloads finishes.</p>
<p><span class="literal1">go</span>, <span
class="literal1">thread</span>, <span class="literal1">chan</span>,
<span class="literal1">&lt;!</span>, <span
class="literal1">&lt;!!</span>, <span class="literal1">&gt;!</span>, and
<span class="literal1">&gt;!!</span> are the core tools you’ll use for
creating and communicating with processes. Both put and take will cause
a process to wait until its complement is performed on the given
channel. <span class="literal1">go</span> allows you to use the parking
variants of put and take, which could improve performance. <span
id="text_part0023.html_page_239" class="calibre4"></span>You should use
the blocking variants, along with <span class="literal1">thread</span>,
if you’re performing long-running tasks before the put or take.</p>
<p>And that should give you everything you need to fulfill your heart’s
desire and create a machine that turns money into hot dogs.</p>
<h3 class="h2" id="text_part0023.html_ch11lev1sec2"><strong>The Hot Dog
Machine Process You’ve Been Longing For</strong></h3>
<p>Behold, your dreams made real!</p>
<pre class="programs"><code>(defn hot-dog-machine
  []
  (let [in (chan)
        out (chan)]
    (go (&lt;! in)
        (&gt;! out &quot;hot dog&quot;))
    [in out]))</code></pre>
<p>This function creates an <span class="literal1">in</span> channel for
receiving money and an <span class="literal1">out</span> channel for
dispensing a hot dog. It then creates an asynchronous process with <span
class="literal1">go</span>, which waits for money and then dispenses a
hot dog. Finally, it returns the <span class="literal1">in</span> and
<span class="literal1">out</span> channels as a vector.</p>
<p>Time for a hot dog!</p>
<pre class="programs"><code>(let [[in out] (hot-dog-machine)]
  (&gt;!! in &quot;pocket lint&quot;)
  (&lt;!! out))
; =&gt; &quot;hot dog&quot;</code></pre>
<p>In this snippet, you use destructuring (covered in <a
href="#text_part0014.html_ch03" class="calibre4">Chapter 3</a>) with
<span class="literal1">let</span> to bind the <span
class="literal1">in</span> and <span class="literal1">out</span>
channels to the <span class="literal1">in</span> and <span
class="literal1">out</span> symbols. You then put <span
class="literal1">"pocket lint"</span> on the <span
class="literal1">in</span> channel. The hot dog machine process waits
for something, anything, to arrive on the <span
class="literal1">in</span> channel; once <span class="literal1">"pocket
lint"</span> arrives, the hot dog machine process resumes execution,
putting <span class="literal1">"hot dog"</span> on the <span
class="literal1">out</span> channel.</p>
<p>Wait a minute . . . that’s not right. I mean, yay, free hot dogs, but
someone’s bound to get upset that the machine’s accepting pocket lint as
payment. Not only that, but this machine will only dispense one hot dog
before shutting down. Let’s alter the hot dog machine function so that
you can specify how many hot dogs it has and so it only dispenses a hot
dog when you give it the number 3:</p>
<pre class="programs"><code>(defn hot-dog-machine-v2
  [hot-dog-count]
  (let [in (chan)
        out (chan)]
    (go (loop [hc hot-dog-count]
          (if (&gt; hc 0)
            (let [input (&lt;! in)]
             ➊(if (= 3 input)
               (do (&gt;! out &quot;hot dog&quot;)

                 (recur (dec hc)))
             (do (&gt;! out &quot;wilted lettuce&quot;)
                 (recur hc))))
       ➋(do (close! in)
           (close! out)))))
[in out]))</code></pre>
<p>There’s a lot more code here, but the strategy is straightforward.
The new function <span class="literal1">hot-dog-machine-v2</span> allows
you to specify the <span class="literal1">hot-dog-count</span>. Within
the go block at <span class="ent">➊</span>, it dispenses a hot dog only
if the number 3 (meaning three dollars) is placed on the <span
class="literal1">in</span> channel; otherwise, it dispenses wilted
lettuce, which is definitely not a hot dog. Once a process has taken the
output, the hot dog machine process loops back with an updated hot dog
count and is ready to receive money again.</p>
<p>When the machine process runs out of hot dogs, the process
<em>closes</em> the channels at <span class="ent">➋</span>. When you
close a channel, you can no longer perform puts on it, and once you’ve
taken all values off a closed channel, any subsequent takes will return
<span class="literal1">nil.</span></p>
<p>Let’s give the upgraded hot dog machine a go in <a
href="#text_part0023.html_ch11list1" class="calibre4">Listing 11-1</a>
by putting in money and pocket lint:</p>
<pre class="programs"><code>(let [[in out] (hot-dog-machine-v2 2)]
  (&gt;!! in &quot;pocket lint&quot;)
  (println (&lt;!! out))


  (&gt;!! in 3)
  (println (&lt;!! out))


  (&gt;!! in 3)
  (println (&lt;!! out))


  (&gt;!! in 3)
  (&lt;!! out))
; =&gt; wilted lettuce
; =&gt; hotdog
; =&gt; hotdog
; =&gt; nil</code></pre>
<p><span id="text_part0023.html_ch11list1"
class="calibre4"></span><em>Listing 11-1: Interacting with a robust hot
dog vending machine process</em></p>
<p>First, we try the ol’ pocket lint trick and get wilted lettuce. Next,
we put in 3 dollars twice and get a hot dog both times. Then, we try to
put in another 3 dollars, but that’s ignored because the channel is
closed; the number 3 is not put on the channel. When we try to take from
the <span class="literal1">out</span> channel, we get <span
class="literal1">nil</span>, again because the channel is closed. You
might notice a couple of interesting details about <span
class="literal1">hot-dog-machine-v2</span>. First, it does a put and a
take within the same go block. This isn’t that unusual, and it’s one way
you can create a <em>pipeline</em> of processes: just make the
<em>in</em> channel of one process the <em>out</em> channel of another.
The following example does just that, <span
id="text_part0023.html_page_241" class="calibre4"></span>passing a
string through a series of processes that perform transformations until
the string finally gets printed by the last process:</p>
<pre class="programs"><code>(let [c1 (chan)
      c2 (chan)
      c3 (chan)]
  (go (&gt;! c2 (clojure.string/upper-case (&lt;! c1))))
  (go (&gt;! c3 (clojure.string/reverse (&lt;! c2))))
  (go (println (&lt;! c3)))
  (&gt;!! c1 &quot;redrum&quot;))
; =&gt; MURDER</code></pre>
<p>I’ll have more to say about process pipelines and how you can use
them instead of callbacks toward the end of the chapter.</p>
<p>Back to <a href="#text_part0023.html_ch11list1"
class="calibre4">Listing 11-1</a>! Another thing to note is that the hot
dog machine doesn’t accept more money until you’ve dealt with whatever
it’s dispensed. This allows you to model state-machine-like behavior,
where the completion of channel operations triggers state transitions.
For example, you can think of the vending machine as having two states:
<em>ready to receive money</em> and <em>dispensed item</em>. Inserting
money and taking the item trigger transitions between the two.</p>
<h4 class="h2"
id="text_part0023.html_ch11lev2sec4"><strong>alts!!</strong></h4>
<p>The core.async function <span class="literal1">alts!!</span> lets you
use the result of the first successful channel operation among a
collection of operations. We did something similar to this with delays
and futures in “<a href="#text_part0021.html_ch09lev2sec7"
class="calibre4">Delays</a>” on <a href="#text_part0021.html_page_198"
class="calibre4">page 198</a>. In that example, we uploaded a set of
headshots to a headshot-sharing site and notified the headshot owner
when the first photo was uploaded. Here’s how you’d do the same with
<span class="literal1">alts!!</span>:</p>
<pre class="programs"><code>  (defn upload
    [headshot c]
    (go (Thread/sleep (rand 100))
        (&gt;! c headshot)))


➊ (let [c1 (chan)
        c2 (chan)
        c3 (chan)]
    (upload &quot;serious.jpg&quot; c1)
    (upload &quot;fun.jpg&quot; c2)
    (upload &quot;sassy.jpg&quot; c3)
➋   (let [[headshot channel] (alts!! [c1 c2 c3])]
      (println &quot;Sending headshot notification for&quot; headshot)))
  ; =&gt; Sending headshot notification for sassy.jpg</code></pre>
<p>Here, the <span class="literal1">upload</span> function takes a
headshot and a channel, and creates a new process that sleeps for a
random amount of time (to simulate the <span
id="text_part0023.html_page_242" class="calibre4"></span>upload) and
then puts the headshot on the channel. The <span
class="literal1">let</span> bindings and <span
class="literal1">upload</span> function calls beginning at <span
class="ent">➊</span> should make sense: we create three channels and
then use them to perform the uploads.</p>
<p>Things get interesting at <span class="ent">➋</span>. The <span
class="literal1">alts!!</span> function takes a vector of channels as
its argument. This is like saying, “Try to do a blocking take on each of
these channels simultaneously. As soon as a take succeeds, return a
vector whose first element is the value taken and whose second element
is the winning channel.” In this case, the channel associated with
<em>sassy.jpg</em> received a value first. The other channels are still
available if you want to take their values and do something with them.
All <span class="literal1">alts!!</span> does is take a value from the
first channel to have a value; it doesn’t touch the other channels.</p>
<p>One cool aspect of <span class="literal1">alts!!</span> is that you
can give it a <em>timeout channel</em>, which waits the specified number
of milliseconds and then closes. It’s an elegant mechanism for putting a
time limit on concurrent operations. Here’s how you could use it with
the upload service:</p>
<pre class="programs"><code>(let [c1 (chan)]
  (upload &quot;serious.jpg&quot; c1)
  (let [[headshot channel] (alts!! [c1 (timeout 20)])]
    (if headshot
      (println &quot;Sending headshot notification for&quot; headshot)
      (println &quot;Timed out!&quot;))))
; =&gt; Timed out!</code></pre>
<p>In this case, we set the timeout to 20 milliseconds. Because the
upload didn’t finish in that time frame, we got a timeout message.</p>
<p>You can also use <span class="literal1">alts!!</span> to specify put
operations. To do that, place a vector inside the vector you pass to
<span class="literal1">alts!!</span>, like at <span class="ent">➊</span>
in this example:</p>
<pre class="programs"><code>(let [c1 (chan)
      c2 (chan)]
  (go (&lt;! c2))
➊ (let [[value channel] (alts!! [c1 [c2 &quot;put!&quot;]])]
    (println value)
    (= channel c2)))
; =&gt; true
; =&gt; true</code></pre>
<p>Here you’re creating two channels and then creating a process that’s
waiting to perform a take on <span class="literal1">c2</span>. The
vector that you supply to <span class="literal1">alts!!</span> tells it,
“Try to do a take on <span class="literal1">c1</span> and try to put
<span class="literal1">"put!"</span> on <span
class="literal1">c2</span>. If the take on <span
class="literal1">c1</span> finishes first, return its value and channel.
If the put on <span class="literal1">c2</span> finishes first, return
<span class="literal1">true</span> if the put was successful and <span
class="literal1">false</span> otherwise.” Finally, the result of <span
class="literal1">value</span> (which is <span
class="literal1">true</span>, because the <span
class="literal1">c2</span> channel was open) prints and shows that the
channel returned was indeed <span class="literal1">c2</span>.</p>
<p>Like <span class="literal1">&lt;!!</span> and <span
class="literal1">&gt;!!</span>, <span class="literal1">alts!!</span> has
a parking alternative, <span class="literal1">alts!</span>, which you
can use inside go blocks. <span class="literal1">alts!</span> is a nice
way to exercise some choice over which of a group of channels you put or
take from. It still performs puts and takes, so the same reasons to use
the parking or blocking variation apply.</p>
<p><span id="text_part0023.html_page_243" class="calibre4"></span>And
that covers the core.async basics! The rest of the chapter explains two
common patterns for coordinating processes.</p>
<h4 class="h2"
id="text_part0023.html_ch11lev2sec5"><strong>Queues</strong></h4>
<p>In “<a href="#text_part0021.html_ch09lev2sec9"
class="calibre4">Rolling Your Own Queue</a>” on <a
href="#text_part0021.html_page_202" class="calibre4">page 202</a>, you
wrote a macro that let you queue futures. Processes let you use a
similar technique in a more straightforward manner. Let’s say you want
to get a bunch of random quotes from a website and write them to a
single file. You want to make sure that only one quote is written to a
file at a time so the text doesn’t get interleaved, so you put your
quotes on a queue. Here’s the full code:</p>
<pre class="programs"><code>(defn append-to-file
  &quot;Write a string to the end of a file&quot;
  [filename s]
  (spit filename s :append true))


(defn format-quote
  &quot;Delineate the beginning and end of a quote because it&#39;s convenient&quot;
  [quote]
  (str &quot;=== BEGIN QUOTE ===\n&quot; quote &quot;=== END QUOTE ===\n\n&quot;))


(defn random-quote
  &quot;Retrieve a random quote and format it&quot;
  []
  (format-quote (slurp &quot;http://www.braveclojure.com/random-quote&quot;)))


(defn snag-quotes
  [filename num-quotes]
  (let [c (chan)]
    (go (while true (append-to-file filename (&lt;! c))))
    (dotimes [n num-quotes] (go (&gt;! c (random-quote))))))</code></pre>
<p>The functions <span class="literal1">append-to-file</span>, <span
class="literal1">format-quote</span>, and <span
class="literal1">random-quote</span> have docstrings that explain what
they do. <span class="literal1">snag-quotes</span> is where the
interesting work happens. First, it creates a channel that’s shared
between the quoteproducing processes and the quote-consuming process.
Then it creates a process that uses <span class="literal1">while
true</span> to create an infinite loop. On every iteration of the loop,
it waits for a quote to arrive on <span class="literal1">c</span> and
then appends it to a file. Finally, <span
class="literal1">snag-quotes</span> creates a <span
class="literal1">num-quotes</span> number of processes that fetch a
quote and then put it on <span class="literal1">c</span>. If you
evaluate <span class="literal1">(snag-quotes "quotes" 2)</span> and
check the <em>quotes</em> file in the directory where you started your
REPL, it should have two quotes:</p>
<pre class="programs"><code>=== BEGIN QUOTE ===
Nobody&#39;s gonna believe that computers are intelligent until they start
coming in late and lying about it.
=== END QUOTE ===

=== BEGIN QUOTE ===
Give your child mental blocks for Christmas.
=== END QUOTE ===</code></pre>
<p>This kind of queuing differs from the example in <a
href="#text_part0021.html_ch09" class="calibre4">Chapter 9</a>. In that
example, each task was handled in the order it was created. Here, each
quote-retrieving task is handled in the order that it finishes. In both
cases, you ensure that only one quote at a time is written to a
file.</p>
<h3 class="h2" id="text_part0023.html_ch11lev1sec3"><strong>Escape
Callback Hell with Process Pipelines</strong></h3>
<p>In languages without channels, you need to express the idea “when
<em>x</em> happens, do <em>y</em>” with <span
class="literal1">callbacks</span>. In a language like JavaScript,
callbacks are a way to define code that executes asynchronously once
other code finishes. If you’ve worked with JavaScript, you’ve probably
spent some time wallowing in <em>callback hell</em>.</p>
<p>The reason it’s called callback hell is that it’s very easy to create
dependencies among layers of callbacks that aren’t immediately obvious.
They end up sharing state, making it difficult to reason about the state
of the overall system as the callbacks get triggered. You can avoid this
depressing outcome by creating a process pipeline. That way, each unit
of logic lives in its own isolated process, and all communication
between units of logic occurs through explicitly defined input and
output channels.</p>
<p>In the following example, we create three infinitely looping
processes connected through channels, passing the <em>out</em> channel
of one process as the <em>in</em> channel of the next process in the
pipeline:</p>
<pre class="programs"><code>(defn upper-caser
  [in]
  (let [out (chan)]
    (go (while true (&gt;! out (clojure.string/upper-case (&lt;! in)))))
    out))


(defn reverser
  [in]
  (let [out (chan)]
    (go (while true (&gt;! out (clojure.string/reverse (&lt;! in)))))
    out))


(defn printer
  [in]
  (go (while true (println (&lt;! in)))))


(def in-chan (chan))
(def upper-caser-out (upper-caser in-chan))
(def reverser-out (reverser upper-caser-out))
(printer reverser-out)
(&gt;!! in-chan &quot;redrum&quot;)
; =&gt; MURDER


(&gt;!! in-chan &quot;repaid&quot;)
; =&gt; DIAPER</code></pre>
<p>By handling events using processes like this, it’s easier to reason
about the individual steps of the overall data transformation system.
You can look at each step and understand what it does without having to
refer to what might have happened before it or what might happen after
it; each process is as easy to reason about as a pure function.</p>
<h3 class="h2" id="text_part0023.html_ch11lev1sec4"><strong>Additional
Resources</strong></h3>
<p>Clojure’s core.async library was largely inspired by Go’s concurrency
model, which is based on the work by Tony Hoare in <em>Communicating
Sequential Processes</em> and is available at <em><a
href="http://www.usingcsp.com/"
class="calibre4">http://www.usingcsp.com/</a>.</em></p>
<p>Rob Pike, co-creator of Go, has a good talk on concurrency, which is
available at <em><a href="https://www.youtube.com/watch?v=f6kdp27TYZs"
class="calibre4">https://www.youtube.com/watch?v=f6kdp27TYZs</a></em>.</p>
<p>ClojureScript, also known as the best thing to happen to the browser,
uses core.async. No more callback hell! You can learn about
ClojureScript at <em><a href="https://github.com/clojure/clojurescript"
class="calibre4">https://github.com/clojure/clojurescript</a></em>.</p>
<p>Finally, check out the API docs at <em><a
href="http://clojure.github.io/core.async/"
class="calibre4">http://clojure.github.io/core.async/</a></em>.</p>
<h3 class="h2"
id="text_part0023.html_ch11lev1sec5"><strong>Summary</strong></h3>
<p>In this chapter, you learned about how core.async allows you to
create concurrent processes that respond to the put and take
communication events on channels. You learned about how to use <span
class="literal1">go</span> and <span class="literal1">thread</span> to
create concurrent processes that wait for communication events by
parking and blocking. You also learned how to create process pipelines
by making the <em>out</em> channel of one process the <em>in</em>
channel of another, and how this allows you to write code that’s way
more intelligible than nested callbacks. Finally, you meditated on
whether or not you’re just a fancy hot dog vending machine.<span
id="text_part0023.html_page_246" class="calibre4"></span></p>
<p><span id="text_part0024.html"></span></p>
<h2 class="h1" id="text_part0024.html_ch12"><span
id="text_part0024.html_page_247" class="calibre1"></span><strong><span
class="big1">12</span></strong><br />
<strong>Working with the JVM</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>There comes a day in every Clojurist’s life when she must venture
forth from the sanctuary of pure functions and immutable data structures
into the wild, barbaric Land of Java. This treacherous journey is
necessary because Clojure is hosted on the Java Virtual Machine (JVM),
which grants it three fundamental characteristics. First, you run
Clojure applications the same way you run Java applications. Second, you
need to use Java objects for core functionality like reading files and
working with dates. Third, Java has a vast ecosystem of useful
libraries, and you’ll need to know a bit about Java to use them.</p>
<p>In this way, Clojure is a bit like a utopian community plunked down
in the middle of a dystopian country. Obviously you’d prefer to interact
with other utopians, but every once in a while you need to talk to the
locals in order to get things done.</p>
<p><span id="text_part0024.html_page_248" class="calibre4"></span>This
chapter is like a cross between a phrase book and cultural introduction
for the Land of Java. You’ll learn what the JVM is, how it runs
programs, and how to compile programs for it. This chapter will also
give you a brief tour of frequently used Java classes and methods, and
explain how to interact with them using Clojure. You’ll learn how to
think about and understand Java so you can incorporate any Java library
into your Clojure programs.</p>
<p>To run the examples in this chapter, you’ll need to have the Java
Development Kit (JDK) version 1.6 or later installed on your computer.
You can check by running <span class="literal1">javac -version</span> at
your terminal. You should see something like <span class="literal1">java
1.8.0_40</span>; if you don’t, visit <em><a
href="http://www.oracle.com/"
class="calibre4">http://www.oracle.com/</a></em> to download the latest
JDK.</p>
<h3 class="h2" id="text_part0024.html_ch12lev1sec1"><strong>The
JVM</strong></h3>
<p>Developers use the term JVM to refer to a few different things.
You’ll hear them say, “Clojure runs on <em>the</em> JVM,” and you’ll
also hear, “Clojure programs run in <em>a</em> JVM.” In the first case,
JVM refers to an abstraction—the general model of the Java Virtual
Machine. In the second, it refers to a process—an instance of a running
program. We’ll focus on the JVM model, but I’ll point out when we’re
talking about running JVM processes.</p>
<p>To understand the JVM, let’s step back and review how plain ol’
computers work. Deep in the cockles of a computer’s heart is its CPU,
and the CPU’s job is to execute operations like <em>add</em> and
<em>unsigned multiply</em>. You’ve probably heard about programmers
encoding these instructions on punch cards, in lightbulbs, in the sacred
cracks of a tortoise shell, or <em>whatever</em>, but nowadays these
operations are represented in assembly language by mnemonics like ADD
and MUL. The CPU architecture (x86, ARMv7, and what have you) determines
what operations are available as part of the architecture’s
<em>instruction set</em>.</p>
<p>Because it’s no fun to program in assembly language, people have
invented higher-level languages like C and C++, which are compiled into
instructions that a CPU will understand. Broadly speaking, the process
is:</p>
<p>1. The compiler reads source code.</p>
<p>2. The compiler outputs a file containing machine instructions.</p>
<p>3. The CPU executes those instructions.</p>
<p>Notice in <a href="#text_part0024.html_ch12fig1"
class="calibre4">Figure 12-1</a> that, ultimately, you have to translate
programs into instructions that a CPU will understand, and the CPU
doesn’t care which programming language you use to produce those
instructions.</p>
<p>The JVM is analogous to a computer in that it also needs to translate
code into low-level instructions, called <em>Java bytecode</em>.
However, as a <em>virtual</em> machine, this translation is implemented
as software rather than hardware. A running JVM executes bytecode by
translating it on the fly into machine code that its host will
understand, a process called <em>just-in-time compilation</em>.</p>
<div class="image">
<span id="text_part0024.html_page_249" class="calibre4"></span><img
src="images_00070.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0024.html_ch12fig1"
class="calibre4"></span><em>Figure 12-1: A high-level overview of how a
C program is translated into machine code</em></p>
<p>For a program to run on the JVM, it must get compiled to Java
bytecode. Usually, when you compile programs, the resulting bytecode is
saved in a <em>.class</em> file. Then you’ll package these files in
<em>Java archive files</em> (JAR files). And just like how a CPU doesn’t
care which programming language you use to generate machine
instructions, the JVM doesn’t care how you create bytecode. It doesn’t
care if you use Scala, JRuby, Clojure, or even Java to create Java
bytecode. Generally speaking, the process looks like that shown in <a
href="#text_part0024.html_ch12fig2" class="calibre4">Figure
12-2</a>.</p>
<p>1. The Java compiler reads source code.</p>
<p>2. The compiler outputs bytecode, often to a JAR file.</p>
<p>3. JVM executes the bytecode.</p>
<p>4. The JVM sends machine instructions to the CPU.</p>
<p>When someone says that Clojure runs on the JVM, one of the things
they mean is that Clojure programs get compiled to Java bytecode and JVM
processes execute them. From an operations perspective, this means you
treat Clojure programs the same as Java programs. You compile them to
JAR files and run them using the <span class="literal1">java</span>
command. If a client needs a program that runs on the JVM, you could
secretly write it in Clojure instead of Java and they would be none the
wiser. From the outside, you can’t tell the difference between a Java
and a Clojure program any more than you can tell the difference between
a C and a C++ program. Clojure allows you to be productive <em>and</em>
sneaky.</p>
<div class="image">
<span id="text_part0024.html_page_250" class="calibre4"></span><img
src="images_00071.jpeg" class="calibre3" alt="image" />
</div>
<p><span id="text_part0024.html_ch12fig2"
class="calibre4"></span><em>Figure 12-2: Java programs produce JVM
bytecode, but the JVM still has to produce machine instructions, just
like a C compiler.</em></p>
<h3 class="h2" id="text_part0024.html_ch12lev1sec2"><strong>Writing,
Compiling, and Running a Java Program</strong></h3>
<p>Let’s look at how a real Java program works. In this section, you’ll
learn about the object-oriented paradigm that Java uses. Then, you’ll
build a simple pirate phrase book using Java. This will help you feel
more comfortable with the JVM, it will prepare you for the upcoming
section on Java interop (writing Clojure code that uses Java classes,
objects, and methods directly), and it’ll come in handy should a
scallywag ever attempt to scuttle your booty on the high seas. To tie
all the information together, you’ll take a peek at some of Clojure’s
Java code at the end of the chapter.</p>
<h4 class="h2"
id="text_part0024.html_ch12lev2sec1"><em><strong>Object-Oriented
Programming in the World’s Tiniest Nutshell</strong></em></h4>
<p>Java is an object-oriented language, so you need to understand how
object-oriented programming (OOP) works if you want to understand what’s
happening when you use Java libraries or write Java interop code in your
Clojure programming. You’ll also find object-oriented terminology in
Clojure documentation, so it’s important to learn these concepts. If
you’re OOP savvy, feel free to skip this section. For those who need the
two-minute lowdown, here it is: the central players in OOP are
<em>classes</em>, <em>objects</em>, and <em>methods</em>.</p>
<p>I think of objects as really, really, ridiculously dumb androids.
They’re the kind of android that would never inspire philosophical
debate about the ethics of forcing sentient creatures into perpetual
servitude. These androids <span id="text_part0024.html_page_251"
class="calibre4"></span>only do two things: they respond to commands and
they maintain data. In my imagination they do this by writing stuff down
on little Hello Kitty clipboards.</p>
<p>Imagine a factory that makes these androids. Both the set of commands
the android understands and the set of data it maintains are determined
by the factory that makes the android. In OOP terms, the factories
correspond to classes, the androids correspond to objects, and the
commands correspond to methods. For example, you might have a <span
class="literal1">ScaryClown</span> factory (class) that produces
androids (objects) that respond to the command (method) <span
class="literal1">makeBalloonArt</span>. The android keeps track of the
number of balloons it has, and then updates that number whenever the
number of balloons changes. It can report that number with <span
class="literal1">balloonCount</span> and receive any number of balloons
with <span class="literal1">receiveBalloons</span>. Here’s how you might
interact with a Java object representing Belly Rubs the Clown:</p>
<pre class="programs"><code>ScaryClown bellyRubsTheClown = new ScaryClown();
bellyRubsTheClown.balloonCount();
// =&gt; 0


bellyRubsTheClown.receiveBalloons(2);
bellyRubsTheClown.balloonCount();
// =&gt; 2


bellyRubsTheClown.makeBalloonArt();
// =&gt; &quot;Belly Rubs makes a balloon shaped like a clown, because Belly Rubs
// =&gt; is trying to scare you and nothing is scarier than clowns.&quot;</code></pre>
<p>This example shows you how to create a new object, <span
class="literal1">bellyRubsTheClown</span>, using the <span
class="literal1">ScaryClown</span> class. It also shows you how to call
methods (such as <span class="literal1">balloonCount</span>, <span
class="literal1">receiveBalloons</span>, and <span
class="literal1">makeBalloonArt</span>) on the object, presumably so you
can terrify children.</p>
<p>One final aspect of OOP that you should know, or at least how it’s
implemented in Java, is that you can also send commands to the factory.
In OOP terms, you would say that classes also have methods. For example,
the built-in class <span class="literal1">Math</span> has many class
methods, including <span class="literal1">Math.abs</span>, which returns
the absolute value of a number:</p>
<pre class="programs"><code>Math.abs(-50)
// =&gt; 50</code></pre>
<p>I hope those clowns weren’t too traumatizing for you. Now let’s put
your OOP knowledge to work!</p>
<h4 class="h2" id="text_part0024.html_ch12lev2sec2"><em><strong>Ahoy,
World</strong></em></h4>
<p>Go ahead and create a new directory called <em>phrasebook</em>. In
that directory, create a file called <em>PiratePhrases.java</em>, and
write the following:</p>
<pre class="programs"><code>public class PiratePhrases
{

   public static void main(String[] args)
   {
       System.out.println(&quot;Shiver me timbers!!!&quot;);
   }
}</code></pre>
<p>This very simple program will print the phrase “Shiver me timbers!!!”
(which is how pirates say “Hello, world!”) to your terminal when you run
it. It consists of a class, <span class="literal1">PiratePhrases</span>,
and a static method belonging to that class, <span
class="literal1">main</span>. Static methods are essentially class
methods.</p>
<p>In your terminal, compile the <span
class="literal1">PiratePhrases</span> source code with the command <span
class="literal1"><strong>javac PiratePhrases.java</strong></span>. If
you typed everything correctly <em>and</em> you’re pure of heart, you
should see a file named <em>PiratePhrases.class</em>:</p>
<pre class="programs"><code>$ ls
PiratePhrases.class PiratePhrases.java</code></pre>
<p>You’ve just compiled your first Java program, me matey! Now run it
with <span class="literal1">java PiratePhrases</span>. You should see
this:</p>
<pre class="programs"><code>Shiver me timbers!!!</code></pre>
<p>What’s happening here is you used the Java compiler, <span
class="literal1">javac</span>, to create a Java class file,
<em>PiratePhrases.class</em>. This file is packed with oodles of Java
bytecode (well, for a program this size, maybe only one oodle).</p>
<p>When you ran <span class="literal1">java PiratePhrases</span>, the
JVM first looked at your <em>classpath</em> for a class named <span
class="literal1">PiratePhrases</span>. The classpath is the list of
filesystem paths that the JVM searches to find a file that defines a
class. By default, the classpath includes the directory you’re in when
you run java. Try running <span class="literal1"><strong>java
-classpath/tmp PiratePhrases</strong></span> and you’ll get an error,
even though <em>PiratePhrases.class</em> is right there in your current
directory.</p>
<div class="note">
<p><strong><span class="bordera1">NOTE</span></strong></p>
<p><em>You can have multiple paths on your classpath by separating them
with colons if you’re on a Mac or running Linux, or semicolons if you’re
using Windows. For example, the classpath <span
class="literal1">/tmp:/var/maven:.</span> includes the <span
class="literal1">/tmp</span>, <span class="literal1">/var/maven</span>,
and. directories.</em></p>
</div>
<p>In Java, you’re allowed only one public class per file, and the
filename must match the class name. This is how <span
class="literal1">java</span> knows to try looking in
<em>PiratePhrases.class</em> for the <span
class="literal1">PiratePhrases</span> class’s bytecode. After <span
class="literal1">java</span> found the bytecode for the <span
class="literal1">PiratePhrases</span> class, it executed that class’s
<span class="literal1">main</span> method. Java’s similar to C in that
whenever you say “run something, and use this class as your entry
point,” it will always run that class’s <span
class="literal1">main</span> method; therefore, that method must be
<span class="literal1">public</span>, as you can see in the <span
class="literal1">PiratePhrases</span>’s source code.</p>
<p>In the next section you’ll learn how to handle program code that
spans multiple files, and how to use Java libraries.</p>
<h3 class="h2" id="text_part0024.html_ch12lev1sec3"><span
id="text_part0024.html_page_253"
class="calibre1"></span><strong>Packages and Imports</strong></h3>
<p>To see how to work with multi-file programs and Java libraries, we’ll
compile and run a program. This section has direct implications for
Clojure because you’ll use the same ideas and terminology to interact
with Java libraries.</p>
<p>Let’s start with a couple of definitions:</p>
<p><span class="literal1"><strong>package</strong></span> Similar to
Clojure’s namespaces, packages provide code organization. Packages
contain classes, and package names correspond to filesystem directories.
If a file has the line <span class="literal1">package
com.shapemaster</span> in it, the directory <em>com/shapemaster</em>
must exist somewhere on your classpath. Within that directory will be
files defining classes.</p>
<p><span class="literal1"><strong>import</strong></span> Java allows you
to import classes, which basically means that you can refer to them
without using their namespace prefix. So if you have a class in <span
class="literal1">com.shapemaster</span> named <span
class="literal1">Square</span>, you could write <span
class="literal1">import com.shapemaster.Square;</span> or <span
class="literal1">import com.shapemaster.*;</span> at the top of a <span
class="literal1">.java</span> file to use <span
class="literal1">Square</span> in your code instead of <span
class="literal1">com.shapemaster.Square</span>.</p>
<p>Let’s try using <span class="literal1">package</span> and <span
class="literal1">import</span>. For this example, you’ll create a
package called <span class="literal1">pirate_phrases</span> that has two
classes, <span class="literal1">Greetings</span> and <span
class="literal1">Farewells</span>. To start, navigate to your
<em>phrasebook</em> and within that directory create another directory,
<em>pirate_phrases</em>. It’s necessary to create
<em>pirate_phrases</em> because Java package names correspond to
filesystem directories. Then, create <em>Greetings.java</em> within the
<em>pirate_phrases</em> directory:</p>
<pre class="programs"><code>➊ package pirate_phrases;


  public class Greetings
  {
      public static void hello()
      {
          System.out.println(&quot;Shiver me timbers!!!&quot;);
      }
  }</code></pre>
<p>At <span class="ent">➊</span>, <span class="literal1">package
pirate_phrases;</span> indicates that this class will be part of the
<span class="literal1">pirate_phrases</span> package. Now create
<em>Farewells.java</em> within the <em>pirate_phrases</em>
directory:</p>
<pre class="programs"><code>package pirate_phrases;


public class Farewells
{
    public static void goodbye()
    {
        System.out.println(&quot;A fair turn of the tide ter ye thar, ye
magnificent sea friend!!&quot;);
    }
}</code></pre>
<p><span id="text_part0024.html_page_254" class="calibre4"></span>Now
create <em>PirateConversation.java</em> in the <em>phrasebook</em>
directory:</p>
<pre class="programs"><code>import pirate_phrases.*;


public class PirateConversation
{
    public static void main(String[] args)
    {
        Greetings greetings = new Greetings();
        greetings.hello();


        Farewells farewells = new Farewells();
        farewells.goodbye();
    }
}</code></pre>
<p>The first line, <span class="literal1">import
pirate_phrases.*;</span>, imports all classes in the <span
class="literal1">pirate_phrases</span> package, which contains the <span
class="literal1">Greetings</span> and <span
class="literal1">Farewells</span> classes.</p>
<p>If you run <span class="literal1"><strong>javac
PirateConversation.java</strong></span> within the <em>phrasebook</em>
directory followed by <span class="literal1">java
PirateConversation</span>, you should see this:</p>
<pre class="programs"><code>Shiver me timbers!!!
A fair turn of the tide ter ye thar, ye magnificent sea friend!!</code></pre>
<p>And thar she blows, dear reader. Thar she blows indeed.</p>
<p>Note that, when you’re compiling a Java program, Java searches your
classpath for packages. Try typing the following:</p>
<pre class="programs"><code>cd pirate_phrases
javac ../PirateConversation.java</code></pre>
<p>You’ll get this:</p>
<pre class="programs"><code>../PirateConversation.java:1: error: package pirate_phrases does not exist
import pirate_phrases.*;
^</code></pre>
<p>Boom! The Java compiler just told you to hang your head in shame and
maybe weep a little.</p>
<p>Why? It thinks that the <span class="literal1">pirate_phrases</span>
package doesn’t exist. But that’s stupid, right? You’re in the
<em>pirate_phrases</em> directory!</p>
<p>What’s happening here is that the default classpath only includes the
current directory, which in this case is <em>pirate_phrases</em>. <span
class="literal1">javac</span> is trying to find the directory
<em>phrasebook/pirate_phrases/pirate_phrases</em>, which doesn’t exist.
When you run <span class="literal1">javac
../PirateConversation.java</span> from within the <em>phrasebook</em>
directory, <span class="literal1">javac</span> tries to find the
directory <em>phrasebook/pirate_phrases</em>, which does exist. Without
changing directories, try running <span class="literal1"><strong>javac
-classpath ../../PirateConversation.java</strong></span>. Shiver me
timbers, it works! This works because <span
id="text_part0024.html_page_255" class="calibre4"></span>you manually
set the classpath to the parent directory of <em>pirate_phrases</em>,
which is <em>phrasebook</em>. From there, <span
class="literal1">javac</span> can successfully find the
<em>pirate_phrases</em> directory.</p>
<p>In summary, packages organize code and require a matching directory
structure. Importing classes allows you to refer to them without having
to prepend the entire class’s package name. <span
class="literal1">javac</span> and Java find packages using the
classpath.</p>
<h3 class="h2" id="text_part0024.html_ch12lev1sec4"><strong>JAR
Files</strong></h3>
<p>JAR files allow you to bundle all your <em>.class</em> files into one
single file. Navigate to your <em>phrasebook</em> directory and run the
following:</p>
<pre class="programs"><code>jar cvfe conversation.jar PirateConversation PirateConversation.class
pirate_phrases/*.class
java -jar conversation.jar</code></pre>
<p>This displays the pirate conversation correctly. You bundled all the
class files into <em>conversation.jar</em>. Using the <span
class="literal1">e</span> flag, you also indicated that the <span
class="literal1">PirateConversation</span> class is the <em>entry
point</em>. The entry point is the class that contains the <span
class="literal1">main</span> method that should be executed when the JAR
as a whole runs, and <span class="literal1">jar</span> stores this
information in the file <em>META-INF/MANIFEST.MF</em> within the JAR
file. If you were to read that file, it would contain this line:</p>
<pre class="programs"><code>Main-Class: PirateConversation</code></pre>
<p>By the way, when you execute JAR files, you don’t have to worry which
directory you’re in, relative to the file. You could change to the
<em>pirate_phrases</em> directory and run <span class="literal1">java
-jar ../conversation.jar</span>, and it would work fine. The reason is
that the JAR file maintains the directory structure. You can see its
contents with <span class="literal1"><strong>jar tf
conversation.jar</strong></span>, which outputs this:</p>
<pre class="programs"><code>META-INF/
META-INF/MANIFEST.MF
PirateConversation.class
pirate_phrases/Farewells.class
pirate_phrases/Greetings.class</code></pre>
<p>You can see that the JAR file includes the <em>pirate_phrases</em>
directory. One more fun fact about JARs: they’re really just ZIP files
with a <em>.jar</em> extension. You can treat them the same as any other
ZIP file.</p>
<h3 class="h2"
id="text_part0024.html_ch12lev1sec5"><strong>clojure.jar</strong></h3>
<p>Now you’re ready to see how Clojure works under the hood! Download
the 1.7.0 stable release and run it:</p>
<pre class="programs"><code>java -jar clojure-1.7.0.jar</code></pre>
<p><span id="text_part0024.html_page_256" class="calibre4"></span>You
should see the most soothing of sights, the Clojure REPL. How did it
actually start up? Let’s look at <em>META-INF/MANIFEST.MF</em> in the
JAR file:</p>
<pre class="programs"><code>Manifest-Version: 1.0
Archiver-Version: Plexus Archiver
Created-By: Apache Maven
Built-By: hudson
Build-Jdk: 1.7.0_20
Main-Class: clojure.main</code></pre>
<p>It looks like <span class="literal1">clojure.main</span> is specified
as the entry point. Where does this class come from? Well, have a look
at <em>clojure/main.java</em> on GitHub at <em><a
href="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/main.java"
class="calibre4">https://github.com/clojure/clojure/blob/master/src/jvm/clojure/main.java</a></em>:</p>
<pre class="programs"><code>/**
 *   Copyright (c) Rich Hickey. All rights reserved.
 *   The use and distribution terms for this software are covered by the
 *   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
 *   which can be found in the file epl-v10.html at the root of this distribution.
 *   By using this software in any fashion, you are agreeing to be bound by
 *   the terms of this license.
 *   You must not remove this notice, or any other, from this software.
 **/


package clojure;


import clojure.lang.Symbol;
import clojure.lang.Var;
import clojure.lang.RT;


public class main{


final static private Symbol CLOJURE_MAIN = Symbol.intern(&quot;clojure.main&quot;);
final static private Var REQUIRE = RT.var(&quot;clojure.core&quot;, &quot;require&quot;);
final static private Var LEGACY_REPL = RT.var(&quot;clojure.main&quot;, &quot;legacy-repl&quot;);
final static private Var LEGACY_SCRIPT = RT.var(&quot;clojure.main&quot;, &quot;legacy-script&quot;);
final static private Var MAIN = RT.var(&quot;clojure.main&quot;, &quot;main&quot;);


public static void legacy_repl(String[] args) {
    REQUIRE.invoke(CLOJURE_MAIN);
    LEGACY_REPL.invoke(RT.seq(args));
}


public static void legacy_script(String[] args) {
    REQUIRE.invoke(CLOJURE_MAIN);
    LEGACY_SCRIPT.invoke(RT.seq(args));
}


public static void main(String[] args) {
    REQUIRE.invoke(CLOJURE_MAIN);
    MAIN.applyTo(RT.seq(args));
}
}</code></pre>
<p><span id="text_part0024.html_page_257" class="calibre4"></span>As you
can see, the file defines a class named <span
class="literal1">main</span>. It belongs to the package <span
class="literal1">clojure</span> and defines a <span
class="literal1">public static main</span> method, and the JVM is
completely happy to use it as an entry point. Seen this way, Clojure is
a JVM program just like any other.</p>
<p>This wasn’t meant to be an in-depth Java tutorial, but I hope that it
helped clarify what programmers mean when they talk about Clojure
“running on the JVM” or being a “hosted” language. In the next section,
you’ll continue to explore the magic of the JVM as you learn how to use
additional Java libraries within your Clojure project.</p>
<h3 class="h2" id="text_part0024.html_ch12lev1sec6"><strong>Clojure App
JARs</strong></h3>
<p>You now know how Java runs Java JARs, but how does it run Clojure
apps bundled as JARs? After all, Clojure applications don’t have
classes, do they?</p>
<p>As it turns out, you can make the Clojure compiler generate a class
for a namespace by putting the <span
class="literal1">(:gen-class)</span> directive in the namespace
declaration. (You can see this in the very first Clojure program you
created, <em>clojure-noob</em> in <a href="#text_part0011.html_ch01"
class="calibre4">Chapter 1</a>. Remember that program, little teapot?)
This means that the compiler produces the bytecode necessary for the JVM
to treat the namespace as if it defines a Java class.</p>
<p>You set the namespace of the entry point for your program in the
program’s <em>project.clj</em> file, using the <span
class="literal1">:main</span> attribute. For <em>clojure-noob</em>, you
should see <span class="literal1">:main ^:skip-aot
clojure-noob.core</span>. When Leiningen compiles this file, it will add
a <em>meta-inf/manifest.mf</em> file that contains the entry point to
the resulting JAR file.</p>
<p>So, if you define a <span class="literal1">-main</span> function in a
namespace and include the <span class="literal1">(:gen-class)</span>
directive, and also set <span class="literal1">:main</span> in your
<em>project.clj</em> file, your program will have everything it needs
for Java to run it when it gets compiled as a JAR. You can try this out
in your terminal by navigating to your <em>clojure-noob</em> directory
and running this:</p>
<pre class="programs"><code>lein uberjar
java -jar target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar</code></pre>
<p>You should see two messages printed out: “Cleanliness is next to
godliness” and “I’m a little teapot!” Note that you don’t need Leiningen
to run the JAR file; you can send it to friends and neighbors and they
can run it as long as they have Java installed.</p>
<h3 class="h2" id="text_part0024.html_ch12lev1sec7"><strong>Java
Interop</strong></h3>
<p>One of Rich Hickey’s design goals for Clojure was to create a
<em>practical</em> language. For that reason, Clojure was designed to
make it easy for you to interact with Java classes and objects, meaning
you can use Java’s extensive native functionality and its enormous
ecosystem. The ability to use Java classes, objects, and methods is
called <em>Java interop</em>. In this section, you’ll learn how to use
Clojure’s interop syntax, how to import Java packages, and how to use
the most frequently used Java classes.</p>
<h4 class="h2" id="text_part0024.html_ch12lev2sec3"><span
id="text_part0024.html_page_258"
class="calibre1"></span><em><strong>Interop Syntax</strong></em></h4>
<p>Using Clojure’s interop syntax, interacting with Java objects and
classes is straightforward. Let’s start with object interop syntax.</p>
<p>You can call methods on an object using (<span
class="literal1">.<em>methodName object</em></span>). For example,
because all Clojure strings are implemented as Java strings, you can
call Java methods on them:</p>
<pre class="programs"><code>  (.toUpperCase &quot;By Bluebeard&#39;s bananas!&quot;)
  ; =&gt; &quot;BY BLUEBEARD&#39;S BANANAS!&quot;


➊ (.indexOf &quot;Let&#39;s synergize our bleeding edges&quot; &quot;y&quot;)
  ; =&gt; 7</code></pre>
<p>These are equivalent to this Java:</p>
<pre class="programs"><code>&quot;By Bluebeard&#39;s bananas!&quot;.toUpperCase()
&quot;Let&#39;s synergize our bleeding edges&quot;.indexOf(&quot;y&quot;)</code></pre>
<p>Notice that Clojure’s syntax allows you to pass arguments to Java
methods. In this example, at <span class="ent">➊</span> you passed the
argument <span class="literal1">"y"</span> to the <span
class="literal1">indexOf</span> method.</p>
<p>You can also call static methods on classes and access classes’
static fields. Observe!</p>
<pre class="programs"><code>➊ (java.lang.Math/abs -3)
  ; =&gt; 3


➋ java.lang.Math/PI
  ; =&gt; 3.141592653589793</code></pre>
<p>At <span class="ent">➊</span> you called the <span
class="literal1">abs</span> static method on the <span
class="literal1">java.lang.Math</span> class, and at <span
class="ent">➋</span> you accessed that class’s <span
class="literal1">PI</span> static field.</p>
<p>All of these examples (except <span
class="literal1">java.lang.Math/PI</span>) use macros that expand to use
the <em>dot special form</em>. In general, you won’t need to use the dot
special form unless you want to write your own macros to interact with
Java objects and classes. Nevertheless, here is each example followed by
its macroexpansion:</p>
<pre class="programs"><code>(macroexpand-1 &#39;(.toUpperCase &quot;By Bluebeard&#39;s bananas!&quot;))
; =&gt; (. &quot;By Bluebeard&#39;s bananas!&quot; toUpperCase)


(macroexpand-1 &#39;(.indexOf &quot;Let&#39;s synergize our bleeding edges&quot; &quot;y&quot;))
; =&gt; (. &quot;Let&#39;s synergize our bleeding edges&quot; indexOf &quot;y&quot;)


(macroexpand-1 &#39;(Math/abs -3))
; =&gt; (. Math abs -3)</code></pre>
<p>This is the general form of the dot operator:</p>
<pre class="programs"><code>(. object-expr-or-classname-symbol method-or-member-symbol optional-args*)</code></pre>
<p><span id="text_part0024.html_page_259" class="calibre4"></span>The
dot operator has a few more capabilities, and if you’re interested in
exploring it further, you can look at clojure.org’s documentation on
Java interop at <em><a
href="http://clojure.org/java_interop#Java%20Interop-The%20Dot%20special%20form"
class="calibre4">http://clojure.org/java_interop#Java%20Interop-The%20Dot%20special%20form</a></em>.</p>
<h4 class="h2" id="text_part0024.html_ch12lev2sec4"><em><strong>Creating
and Mutating Objects</strong></em></h4>
<p>The previous section showed you how to call methods on objects that
already exist. This section shows you how to create new objects and how
to interact with them.</p>
<p>You can create a new object in two ways: <span class="literal1">(new
<em>ClassName optional-args</em>*)</span> and <span
class="literal1">(<em>ClassName</em>.
<em>optional-args</em>*)</span>:</p>
<pre class="programs"><code>(new String)
; =&gt; &quot;&quot;


(String.)
; =&gt; &quot;&quot;


(String. &quot;To Davey Jones&#39;s Locker with ye hardies&quot;)
; =&gt; &quot;To Davey Jones&#39;s Locker with ye hardies&quot;</code></pre>
<p>Most people use the dot version, <span
class="literal1">(<em>ClassName</em>.)</span>.</p>
<p>To modify an object, you call methods on it like you did in the
previous section. To investigate this, let’s use <span
class="literal1">java.util.Stack</span>. This class represents a
last-in, first-out (LIFO) stack of objects, or just <em>stack</em>.
<em>Stacks</em> are a common data structure, and they’re called stacks
because you can visualize them as a physical stack of objects, say, a
stack of gold coins that you just plundered. When you add a coin to your
stack, you add it to the top of the stack. When you remove a coin, you
remove it from the top. Thus, the last object added is the first object
removed.</p>
<p>Unlike Clojure data structure, Java stacks are mutable. You can add
items to them and remove items, changing the object instead of deriving
a new value. Here’s how you might create a stack and add an object to
it:</p>
<pre class="programs"><code>  (java.util.Stack.)
  ; =&gt; []


➊ (let [stack (java.util.Stack.)]
    (.push stack &quot;Latest episode of Game of Thrones, ho!&quot;)
    stack)
  ; =&gt; [&quot;Latest episode of Game of Thrones, ho!&quot;]</code></pre>
<p>There are a couple of interesting details here. First, you need to
create a <span class="literal1">let</span> binding for <span
class="literal1">stack</span> like you see at <span class="ent">➊</span>
and add it as the last expression in the <span
class="literal1">let</span> form. If you didn’t do that, the value of
the overall expression would be the string <span
class="literal1">"Latest episode of Game of Thrones, ho!"</span> because
that’s the return value of <span class="literal1">push</span>.</p>
<p>Second, Clojure prints the stack with square brackets, the same
textual representation it uses for a vector, which could throw you
because it’s not <span id="text_part0024.html_page_260"
class="calibre4"></span>a vector. However, you can use Clojure’s <span
class="literal1">seq</span> functions for reading a data structure, like
<span class="literal1">first</span>, on the stack:</p>
<pre class="programs"><code>(let [stack (java.util.Stack.)]
  (.push stack &quot;Latest episode of Game of Thrones, ho!&quot;)
  (first stack))
; =&gt; &quot;Latest episode of Game of Thrones, ho!&quot;</code></pre>
<p>But you can’t use functions like <span class="literal1">conj</span>
and <span class="literal1">into</span> to add elements to the stack. If
you do, you’ll get an exception. It’s possible to read the stack using
Clojure functions because Clojure extends its abstractions to <span
class="literal1">java.util.Stack</span>, a topic you’ll learn about in
<a href="#text_part0025.html_ch13" class="calibre4">Chapter 13</a>.</p>
<p>Clojure provides the <span class="literal1">doto</span> macro, which
allows you to execute multiple methods on the same object more
succinctly:</p>
<pre class="programs"><code>(doto (java.util.Stack.)
  (.push &quot;Latest episode of Game of Thrones, ho!&quot;)
  (.push &quot;Whoops, I meant &#39;Land, ho!&#39;&quot;))
; =&gt; [&quot;Latest episode of Game of Thrones, ho!&quot; &quot;Whoops, I meant &#39;Land, ho!&#39;&quot;]</code></pre>
<p>The <span class="literal1">doto</span> macro returns the object
rather than the return value of any of the method calls, and it’s easier
to understand. If you expand it using <span
class="literal1">macroexpand-1</span>, you can see its structure is
identical to the <span class="literal1">let</span> expression you just
saw in an earlier example:</p>
<pre class="programs"><code>(macroexpand-1
 &#39;(doto (java.util.Stack.)
    (.push &quot;Latest episode of Game of Thrones, ho!&quot;)
    (.push &quot;Whoops, I meant &#39;Land, ho!&#39;&quot;)))
 ; =&gt; (clojure.core/let
       [G__2876 (java.util.Stack.)]
       (.push G__2876 &quot;Latest episode of Game of Thrones, ho!&quot;)
       (.push G__2876 &quot;Whoops, I meant &#39;Land, ho!&#39;&quot;)
       G__2876)</code></pre>
<p>Convenient!</p>
<h4 class="h2"
id="text_part0024.html_ch12lev2sec5"><em><strong>Importing</strong></em></h4>
<p>In Clojure, importing has the same effect as it does in Java: you can
use classes without having to type out their entire package prefix:</p>
<pre class="programs"><code>(import java.util.Stack)
(Stack.)
; =&gt; []</code></pre>
<p>You can also import multiple classes at once using this general
form:</p>
<pre class="programs"><code>(import [package.name1 ClassName1 ClassName2]
        [package.name2 ClassName3 ClassName4])</code></pre>
<p><span id="text_part0024.html_page_261" class="calibre4"></span>Here’s
an example:</p>
<pre class="programs"><code>(import [java.util Date Stack]
        [java.net Proxy URI])


(Date.)
; =&gt; #inst &quot;2016-09-19T20:40:02.733-00:00&quot;</code></pre>
<p>But usually, you’ll do all your importing in the <span
class="literal1">ns</span> macro, like this:</p>
<pre class="programs"><code>(ns pirate.talk
  (:import [java.util Date Stack]
           [java.net Proxy URI]))</code></pre>
<p>The two different methods of importing classes have the same results,
but the second is usually preferable because it’s convenient for people
reading your code to see all the code involving naming in the <span
class="literal1">ns</span> declaration.</p>
<p>And that’s how you import classes! Pretty easy. To make life even
easier, Clojure automatically imports the classes in <span
class="literal1">java.lang</span>, including <span
class="literal1">java.lang.String</span> and <span
class="literal1">java.lang.Math</span>, which is why you were able to
use <span class="literal1">String</span> without a preceding package
name.</p>
<h3 class="h2" id="text_part0024.html_ch12lev1sec8"><strong>Commonly
Used Java Classes</strong></h3>
<p>To round out this chapter, let’s take a quick tour of the Java
classes that you’re most likely to use.</p>
<h4 class="h2" id="text_part0024.html_ch12lev2sec6"><em><strong>The
System Class</strong></em></h4>
<p>The <span class="literal1">System</span> class has useful class
fields and methods for interacting with the environment that your
program’s running in. You can use it to get environment variables and
interact with the standard input, standard output, and error output
streams.</p>
<p>The most useful methods and members are <span
class="literal1">exit</span>, <span class="literal1">getenv</span>, and
<span class="literal1">getProperty</span>. You might recognize <span
class="literal1">System/exit</span> from <a
href="#text_part0016.html_ch05" class="calibre4">Chapter 5</a>, where
you used it to exit the Peg Thing game. <span
class="literal1">System/exit</span> terminates the current program, and
you can pass it a status code as an argument. If you’re not familiar
with status codes, I recommend Wikipedia’s “Exit status” article at
<em><a href="http://en.wikipedia.org/wiki/Exit_status"
class="calibre4">http://en.wikipedia.org/wiki/Exit_status</a></em>.</p>
<p><span class="literal1">System/getenv</span> will return all of your
system’s environment variables as a map:</p>
<pre class="programs"><code>(System/getenv)
{&quot;USER&quot; &quot;the-incredible-bulk&quot;
 &quot;JAVA_ARCH&quot; &quot;x86_64&quot;}</code></pre>
<p>One common use for environment variables is to configure your
program.</p>
<p><span id="text_part0024.html_page_262" class="calibre4"></span>The
JVM has its own list of properties separate from the computer’s
environment variables, and if you need to read them, you can use <span
class="literal1">System/getProperty</span>:</p>
<pre class="programs"><code>➊ (System/getProperty &quot;user.dir&quot;)
  ; =&gt; &quot;/Users/dabulk/projects/dabook&quot;


➋ (System/getProperty &quot;java.version&quot;)
  ; =&gt; &quot;1.7.0_17&quot;</code></pre>
<p>The first call at <span class="ent">➊</span> returned the directory
that the JVM started from, and the second call at <span
class="ent">➋</span> returned the version of the JVM.</p>
<h4 class="h2" id="text_part0024.html_ch12lev2sec7"><em><strong>The Date
Class</strong></em></h4>
<p>Java has good tools for working with dates. I won’t go into too much
detail about the <span class="literal1">java.util.Date</span> class
because the online API documentation (available at <em><a
href="http://docs.oracle.com/javase/7/docs/api/java/util/Date.html"
class="calibre4">http://docs.oracle.com/javase/7/docs/api/java/util/Date.html</a></em>)
is thorough. As a Clojure developer, you should know three features of
this <span class="literal1">date</span> class. First, Clojure allows you
to represent dates as literals using a form like this:</p>
<pre class="programs"><code>#inst &quot;2016-09-19T20:40:02.733-00:00&quot;</code></pre>
<p>Second, you need to use the <span
class="literal1">java.util.DateFormat</span> class if you want to
customize how you convert dates to strings or if you want to convert
strings to dates. Third, if you’re doing tasks like comparing dates or
trying to add minutes, hours, or other units of time to a date, you
should use the immensely useful clj-time library (which you can check
out at <em><a href="https://github.com/clj-time/clj-time"
class="calibre4">https://github.com/clj-time/clj-time</a></em>).</p>
<h3 class="h2" id="text_part0024.html_ch12lev1sec9"><strong>Files and
Input/Output</strong></h3>
<p>In this section you’ll learn about Java’s approach to input/output
(IO) and how Clojure simplifies it. The <span
class="literal1">clojure.java.io</span> namespace provides many handy
functions for simplifying IO (<em><a
href="https://clojure.github.io/clojure/clojure.java.io-api.html"
class="calibre4">https://clojure.github.io/clojure/clojure.java.io-api.html</a></em>).
This is great because Java IO isn’t exactly straightforward. Because
you’ll probably want to perform IO at some point during your programming
career, let’s start wrapping your mind tentacles around it.</p>
<p>IO involves resources, be they files, sockets, buffers, or whatever.
Java has separate classes for reading a resource’s contents, for
writings its contents, and for interacting with the resource’s
properties.</p>
<p>For example, the <span class="literal1">java.io.File</span> class is
used to interact with a file’s properties:</p>
<pre class="programs"><code>  (let [file (java.io.File. &quot;/&quot;)]
➊   (println (.exists file))
➋   (println (.canWrite file))
➌   (println (.getPath file)))
  ; =&gt; true
  ; =&gt; false
  ; =&gt; /</code></pre>
<p>Among other tasks, you can use it to check whether a file exists, to
get the file’s read/write/execute permissions, and to get its filesystem
path, which you can see at <span class="ent">➊</span>, <span
class="ent">➋</span>, and <span class="ent">➌</span>, respectively.</p>
<div class="image">
<img src="images_00072.jpeg" class="calibre3" alt="image" />
</div>
<p>Reading and writing are noticeably missing from this list of
capabilities. To read a file, you could use the <span
class="literal1">java.io.BufferedReader</span> class or perhaps <span
class="literal1">java.io.FileReader</span>. Likewise, you can use the
<span class="literal1">java.io.BufferedWriter</span> or <span
class="literal1">java.io.FileWriter</span> class for writing. Other
classes are available for reading and writing as well, and which one you
choose depends on your specific needs. Reader and writer classes all
have the same base set of methods for their interfaces; readers
implement <span class="literal1">read</span>, <span
class="literal1">close</span>, and more, while writers implement <span
class="literal1">append</span>, <span class="literal1">write</span>,
<span class="literal1">close</span>, and <span
class="literal1">flush</span>. Java gives you a variety of IO tools. A
cynical person might say that Java gives you enough rope to hang
yourself, and if you find such a person, I hope you give them a hug.</p>
<p>Either way, Clojure makes reading and writing easier for you because
it includes functions that unify reading and writing across different
kinds of resources. For example, <span class="literal1">spit</span>
writes to a resource, and <span class="literal1">slurp</span> reads from
one. Here’s an example of using them to write and read a file:</p>
<pre class="programs"><code>(spit &quot;/tmp/hercules-todo-list&quot;
&quot;- kill dat lion brov
- chop up what nasty multi-headed snake thing&quot;)


(slurp &quot;/tmp/hercules-todo-list&quot;)


; =&gt; &quot;- kill dat lion brov
      - chop up what nasty multi-headed snake thing&quot;</code></pre>
<p>You can also use these functions with objects representing resources
other than files. The next example uses a <span
class="literal1">StringWriter</span>, which allows you to perform IO
operations on a string:</p>
<pre class="programs"><code>(let [s (java.io.StringWriter.)]
  (spit s &quot;- capture cerynian hind like for real&quot;)
  (.toString s))
; =&gt; &quot;- capture cerynian hind like for real&quot;</code></pre>
<p><span id="text_part0024.html_page_264" class="calibre4"></span>You
can also read from a <span class="literal1">StringReader</span> using
<span class="literal1">slurp</span>:</p>
<pre class="programs"><code>(let [s (java.io.StringReader. &quot;- get erymanthian pig what with the tusks&quot;)]
  (slurp s))
; =&gt; &quot;- get erymanthian pig what with the tusks&quot;</code></pre>
<p>In addition, you can use the <span class="literal1">read</span> and
<span class="literal1">write</span> methods for resources. It doesn’t
really make much difference which you use; <span
class="literal1">spit</span> and <span class="literal1">slurp</span> are
convenient because they work with just a string representing a
filesystem path or a URL.</p>
<p>The <span class="literal1">with-open</span> macro is another
convenience: it implicitly closes a resource at the end of its body,
ensuring that you don’t accidentally tie up resources by forgetting to
manually close the resource. The <span class="literal1">reader</span>
function is a handy utility that, according to the <span
class="literal1">clojure.java.io</span> API docs, “attempts to coerce
its argument to an open <span class="literal1">java.io.Reader</span>.”
This is convenient when you don’t want to use <span
class="literal1">slurp</span>, because you don’t want to try to read a
resource in its entirety and you don’t want to figure out which Java
class you need to use. You could use <span
class="literal1">reader</span> along with <span
class="literal1">with-open</span> and the <span
class="literal1">line-seq</span> function if you’re trying to read a
file one line at a time. Here’s how you could print just the first item
of the Hercules to-do list:</p>
<pre class="programs"><code>(with-open [todo-list-rdr (clojure.java.io/reader &quot;/tmp/hercules-todo-list&quot;)]
  (println (first (line-seq todo-list-rdr))))
; =&gt; - kill dat lion brov</code></pre>
<p>That should be enough for you to get started with IO in Clojure. If
you’re trying to do more sophisticated tasks, definitely check out the
<span class="literal1">clojure.java.io</span> docs, the <span
class="literal1">java.nio.file</span> package docs, or the <span
class="literal1">java.io</span> package docs.</p>
<h3 class="h2"
id="text_part0024.html_ch12lev1sec10"><strong>Resources</strong></h3>
<p>• “The Java Virtual Machine and Compilers Explained”: <em><a
href="https://www.youtube.com/watch?v=XjNwyXx2os8"
class="calibre4">https://www.youtube.com/watch?v=XjNwyXx2os8</a></em></p>
<p>• clojure.java.io: <em><a
href="https://clojure.github.io/clojure/clojure.java.io-api.html"
class="calibre4">https://clojure.github.io/clojure/clojure.java.io-api.html</a></em></p>
<p>• clojure.org Java interop documentation: <em><a
href="http://clojure.org/java_interop"
class="calibre4">http://clojure.org/java_interop</a></em></p>
<p>• Wikipedia’s “Exit status” article: <em><a
href="http://en.wikipedia.org/wiki/Exit_status"
class="calibre4">http://en.wikipedia.org/wiki/Exit_status</a></em></p>
<h3 class="h2"
id="text_part0024.html_ch12lev1sec11"><strong>Summary</strong></h3>
<p>In this chapter, you learned what it means for Clojure to be hosted
on the JVM. Clojure programs get compiled to Java bytecode and executed
within a JVM process. Clojure programs also have access to Java
libraries, and you can easily interact with them using Clojure’s interop
facilities.</p>
<p><span id="text_part0025.html"></span></p>
<h2 class="h1" id="text_part0025.html_ch13"><span
id="text_part0025.html_page_265" class="calibre1"></span><strong><span
class="big1">13</span></strong><br />
<strong>Creating and Extending Abstractions with Multimethods,
Protocols, and Records</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>Take a minute to contemplate how great it is to be one of Mother
Nature’s top-of-the-line products: a human. As a human, you get to
gossip on social media, play Dungeons and Dragons, and wear hats.
Perhaps more important, you get to think and communicate in terms of
abstractions.</p>
<p>The ability to think in terms of abstractions is truly one of the
best human features. It lets you circumvent your cognitive limits by
tying together disparate details into a neat conceptual package that you
can hold in your working memory. Instead of having to think the clunky
thought “squeezable honking red ball nose adornment,” you only need the
concept “clown nose.”</p>
<p>In Clojure, an <em>abstraction</em> is a collection of operations,
and <em>data types</em> implement abstractions. For example, the seq
abstraction consists of <span id="text_part0025.html_page_266"
class="calibre4"></span>operations like <span
class="literal1">first</span> and <span class="literal1">rest</span>,
and the vector data type is an implementation of that abstraction; it
responds to all of the seq operations. A specific vector like <span
class="literal1">[:seltzer :water]</span> is an <em>instance</em> of
that data type.</p>
<p>The more a programming language lets you think and write in terms of
abstractions, the more productive you will be. For example, if you learn
that a data structure is an instance of the seq abstraction, you can
instantly call forth a large web of knowledge about what functions will
work with the data structure. As a result, you spend time actually using
the data structure instead of constantly looking up documentation on how
it works. By the same token, if you extend a data structure to work with
the seq abstraction, you can use the extensive library of seq functions
on it.</p>
<p>In <a href="#text_part0015.html_ch04" class="calibre4">Chapter 4</a>,
you learned that Clojure is written in terms of abstractions. This is
powerful because in Clojure you can focus on what you can actually do
with data structures and not worry about the nitty-gritty of
implementation. This chapter introduces you to the world of creating and
implementing your own abstractions. You’ll learn the basics of
multimethods, protocols, and records.</p>
<h3 class="h2"
id="text_part0025.html_ch13lev1sec1"><strong>Polymorphism</strong></h3>
<p>The main way we achieve abstraction in Clojure is by associating an
operation name with more than one algorithm. This technique is called
<em>polymorphism</em>. For example, the algorithm for performing <span
class="literal1">conj</span> on a list is different from the one for
vectors, but we unify them under the same name to indicate that they
implement the same concept, namely, <em>add an element to this data
structure</em>.</p>
<p>Because Clojure relies on Java’s standard library for many of its
data types, a little Java is used in this chapter. For example, Clojure
strings are just Java strings, instances of the Java class <span
class="literal1">java.lang.String</span>. To define your own data types
in Java, you use classes. Clojure provides additional type constructs:
<em>records</em> and <em>types</em>. This book only covers records.</p>
<p>Before we learn about records, though, let’s look at multimethods,
our first tool for defining polymorphic behavior.</p>
<h4 class="h2"
id="text_part0025.html_ch13lev2sec1"><em><strong>Multimethods</strong></em></h4>
<p><em>Multimethods</em> give you a direct, flexible way to introduce
polymorphism into your code. Using multimethods, you associate a name
with multiple implementations by defining a <em>dispatching
function</em>, which produces <em>dispatching values</em> that are used
to determine which <em>method</em> to use. The dispatching function is
like the host at a restaurant. The host will ask you questions like “Do
you have a reservation?” and “Party size?” and then seat you
accordingly. Similarly, when you call a multimethod, the dispatching
function will interrogate the arguments and send them to the right
method, as this example shows:</p>
<pre class="programs"><code>   
   (ns were-creatures)
➊ (defmulti full-moon-behavior (fn [were-creature] (:were-type were-creature)))
➋ (defmethod full-moon-behavior :wolf
    [were-creature]
    (str (:name were-creature) &quot; will howl and murder&quot;))
➌ (defmethod full-moon-behavior :simmons
    [were-creature]
    (str (:name were-creature) &quot; will encourage people and sweat to the oldies&quot;))


   (full-moon-behavior {:were-type :wolf
➍                      :name &quot;Rachel from next door&quot;})
   ; =&gt; &quot;Rachel from next door will howl and murder&quot;


   (full-moon-behavior {:name &quot;Andy the baker&quot;
➎                      :were-type :simmons})
   ; =&gt; &quot;Andy the baker will encourage people and sweat to the oldies&quot;</code></pre>
<p>This multimethod shows how you might define the full moon behavior of
different kinds of were-creatures. Everyone knows that a werewolf turns
into a wolf and runs around howling and murdering people. A lesserknown
species of were-creature, the were-Simmons, turns into Richard Simmons,
power perm and all, and runs around encouraging people to be their best
and sweat to the oldies. You do not want to get bitten by either, lest
<em>you</em> turn into one.</p>
<div class="image">
<img src="images_00073.jpeg" class="calibre3" alt="image" />
</div>
<p>We create the multimethod at <span class="ent">➊</span>. This tells
Clojure, “Hey, create a new multimethod named <span
class="literal1">full-moon-behavior</span>. Whenever someone calls <span
class="literal1">full-moon-behavior</span>, run the dispatching function
<span class="literal1">(fn [were-creature] (:were-type
were-creature))</span> on the arguments. Use the result of that
function, aka the dispatching value, to decide which specific method to
use!”</p>
<p>Next, we define two methods, one for when the value returned by the
dispatching function is <span class="literal1">:wolf</span> at <span
class="ent">➋</span>, and one for when it’s <span
class="literal1">:simmons</span> at <span class="ent">➌</span>. Method
definitions look a lot like function definitions, but the major
difference is that the method name is immediately followed by the
<em>dispatch value</em>. <span class="literal1">:wolf</span> and <span
class="literal1">:simmons</span> are both <em>dispatch values</em>. This
is different from a dispatch<em>ing</em> value, which is what the
dispatching function returns. The full dispatch sequence goes like
this:</p>
<p>1. The form <span class="literal1">(full-moon-behavior {:were-type
:wolf :name "Rachel from next door"})</span> is evaluated.</p>
<p>2. <span class="literal1">full-moon-behavior</span>’s dispatching
function runs, returning <span class="literal1">:wolf</span> as the
dispatching value.</p>
<p><span id="text_part0025.html_page_268" class="calibre4"></span>3.
Clojure compares the dispatching value <span
class="literal1">:wolf</span> to the dispatch values of all the methods
defined for <span class="literal1">full-moon-behavior</span>. The
dispatch values are <span class="literal1">:wolf</span> and <span
class="literal1">:simmons</span>.</p>
<p>4. Because the dispatching value <span class="literal1">:wolf</span>
is equal to the dispatch value <span class="literal1">:wolf</span>, the
algorithm for <span class="literal1">:wolf</span> runs.</p>
<p>Don’t let the terminology trip you up! The main idea is that the
dispatching function returns some value, and this value is used to
determine which method definition to use.</p>
<p>Back to our example! Next we call the method twice. At <span
class="ent">➍</span>, the dispatching function returns the value <span
class="literal1">:wolf</span> and the corresponding method is used,
informing you that <span class="literal1">"Rachel from next door will
howl and murder"</span>. At <span class="ent">➏</span>, the function
behaves similarly, except <span class="literal1">:simmons</span> is the
dispatching value.</p>
<p>You can define a method with <span class="literal1">nil</span> as the
dispatch value:</p>
<pre class="programs"><code>(defmethod full-moon-behavior nil
  [were-creature]
  (str (:name were-creature) &quot; will stay at home and eat ice cream&quot;))


(full-moon-behavior {:were-type nil
                     :name &quot;Martin the nurse&quot;})
; =&gt; &quot;Martin the nurse will stay at home and eat ice cream&quot;</code></pre>
<p>When you call <span class="literal1">full-moon-behavior</span> this
time, the argument you give it has <span class="literal1">nil</span> for
its <span class="literal1">:were-type</span>, so the method
corresponding to <span class="literal1">nil</span> gets evaluated and
you’re informed that <span class="literal1">"Martin the nurse will stay
at home and eat ice cream"</span>.</p>
<p>You can also define a default method to use if no other methods match
by specifying <span class="literal1">:default</span> as the dispatch
value. In this example, the <span class="literal1">:were-type</span> of
the argument given doesn’t match any of the previously defined methods,
so the default method is used:</p>
<pre class="programs"><code>(defmethod full-moon-behavior :default
  [were-creature]
  (str (:name were-creature) &quot; will stay up all night fantasy footballing&quot;))


(full-moon-behavior {:were-type :office-worker
                     :name &quot;Jimmy from sales&quot;})
; =&gt; &quot;Jimmy from sales will stay up all night fantasy footballing&quot;</code></pre>
<p>One cool thing about multimethods is that you can always add new
methods. If you publish a library that includes the <span
class="literal1">were-creatures</span> namespace, other people can
continue extending the multimethod to handle new dispatch values. This
example shows that you’re creating your own random namespace and
including the <span class="literal1">were-creatures</span> namespace,
and then defining another method for the <span
class="literal1">full-moon-behavior</span> multimethod:</p>
<pre class="programs"><code>(ns random-namespace
  (:require [were-creatures]))
(defmethod were-creatures/full-moon-behavior :bill-murray
  [were-creature]

  (str (:name were-creature) &quot; will be the most likeable celebrity&quot;))
(were-creatures/full-moon-behavior {:name &quot;Laura the intern&quot;
                                    :were-type :bill-murray})
; =&gt; &quot;Laura the intern will be the most likeable celebrity&quot;</code></pre>
<p>Your dispatching function can return arbitrary values using any or
all of its arguments. The next example defines a multimethod that takes
two arguments and returns a vector containing the type of each argument.
It also defines an implementation of that method, which will be called
when each argument is a string:</p>
<pre class="programs"><code>(ns user)
(defmulti types (fn [x y] [(class x) (class y)]))
(defmethod types [java.lang.String java.lang.String]
  [x y]
  &quot;Two strings!&quot;)


(types &quot;String 1&quot; &quot;String 2&quot;)
; =&gt; &quot;Two strings!&quot;</code></pre>
<p>Incidentally, this is why they’re called <em>multi</em>methods: they
allow dispatch on multiple arguments. I haven’t used this feature very
often, but I could see it being used in a role-playing game to write
methods that are dispatched according to, say, a mage’s major school of
magic and his magic specialization. Either way, it’s better to have it
and not need it than need it and not have it.</p>
<div class="note">
<p><strong><span class="bordera1">NOTE</span></strong></p>
<p><em>Multimethods also allow</em> hierarchical dispatching<em>.
Clojure lets you build custom hierarchies, which I won’t cover, but you
can learn about them by reading the documentation at</em> <a
href="http://clojure.org/multimethods/"
class="calibre4">http://clojure.org/multimethods/</a>.</p>
</div>
<h4 class="h2"
id="text_part0025.html_ch13lev2sec2"><em><strong>Protocols</strong></em></h4>
<p>Approximately 93.58 percent of the time, you’ll want to dispatch to
methods according to an argument’s type. For example, <span
class="literal1">count</span> needs to use a different method for
vectors than it does for maps or for lists. Although it’s possible to
perform type dispatch with multimethods, <em>protocols</em> are
optimized for type dispatch. They’re more efficient than multimethods,
and Clojure makes it easy for you to succinctly specify protocol
implementations.</p>
<p>A multimethod is just one polymorphic operation, whereas a protocol
is a <em>collection</em> of one or more polymorphic operations. Protocol
operations are called methods, just like multimethod operations. Unlike
multimethods, which perform dispatch on arbitrary values returned by a
dispatching function, protocol methods are dispatched based on the type
of the first argument, as shown in this example:</p>
<pre class="programs"><code>(ns data-psychology)
➊(defprotocol ➋Psychodynamics
  ➌&quot;Plumb the inner depths of your data types&quot;

  ➍(thoughts [x] &quot;The data type&#39;s innermost thoughts&quot;)
  ➎(feelings-about [x] [x y] &quot;Feelings about self or other&quot;))</code></pre>
<p>First, there’s <span class="literal1">defprotocol</span> at <span
class="ent">➊</span>. This takes a name, <span
class="literal1">Psychodynamics</span> <span class="ent">➋</span>, and
an optional docstring, <span class="literal1">"Plumb the inner depths of
your data types"</span> <span class="ent">➌</span>. Next are the method
signatures. A <em>method signature</em> consists of a name, an argument
specification, and an optional docstring. The first method signature is
named <span class="literal1">thoughts</span> <span class="ent">➍</span>
and can take only one argument. The second is named <span
class="literal1">feelings-about</span> <span class="ent">➎</span> and
can take one or two arguments. Protocols do have one limitation: the
methods can’t have rest arguments. So a line like the following isn’t
allowed:</p>
<pre class="programs"><code>(feelings-about [x] [x &amp; others])</code></pre>
<p>By defining a protocol, you’re defining an abstraction, but you
haven’t yet defined how that abstraction is implemented. It’s like
you’re reserving names for behavior (in this example, you’re reserving
<span class="literal1">thoughts</span> and <span
class="literal1">feelings</span>), but you haven’t defined what exactly
the behavior should be. If you were to evaluate <span
class="literal1">(thoughts "blorb")</span>, you would get an exception
that reads, “No implementation of method: thoughts of protocol:
data-psychology/Psychodynamics found for class: java.lang.String.”
Protocols dispatch on the first argument’s type, so when you call <span
class="literal1">(thoughts "blorb")</span>, Clojure tries to look up the
implementation of the <span class="literal1">thoughts</span> method for
strings, and fails.</p>
<p>You can fix this sorry state of affairs by <em>extending</em> the
string data type to <em>implement</em> the <span
class="literal1">Psychodynamics</span> protocol:</p>
<pre class="programs"><code>➊ (extend-type java.lang.String
➋   Psychodynamics
➌   (thoughts [x] (str x &quot; thinks, &#39;Truly, the character defines the data type&#39;&quot;)
➍   (feelings-about
       ([x] (str x &quot; is longing for a simpler way of life&quot;))
       ([x y] (str x &quot; is envious of &quot; y &quot;&#39;s simpler way of life&quot;))))


   (thoughts &quot;blorb&quot;)
➎ ; =&gt; &quot;blorb thinks, &#39;Truly, the character defines the data type&#39;&quot;


   (feelings-about &quot;schmorb&quot;)
   ; =&gt; &quot;schmorb is longing for a simpler way of life&quot;


   (feelings-about &quot;schmorb&quot; 2)
   ; =&gt; &quot;schmorb is envious of 2&#39;s simpler way of life&quot;</code></pre>
<p><span class="literal1">extend-type</span> is followed by the name of
the class or type you want to extend and the protocol you want it to
support—in this case, you specify the class <span
class="literal1">java.lang.String</span> at <span class="ent">➊</span>
and the protocol you want it to support, <span
class="literal1">Psychodynamics</span>, at <span class="ent">➋</span>.
After that, you provide an implementation for both the <span
class="literal1">thoughts</span> method at <span class="ent">➌</span>
and the <span class="literal1">feelings-about</span> method at <span
class="ent">➍</span>. If you’re extending a type to implement a
protocol, you have to implement every method in the protocol or Clojure
will throw an exception. In this case, you can’t implement just <span
class="literal1">thoughts</span> or just <span
class="literal1">feelings</span>; you have to implement both.</p>
<p><span id="text_part0025.html_page_271" class="calibre4"></span>Notice
that these method implementations don’t begin with <span
class="literal1">defmethod</span> like multimethods do. In fact, they
look similar to function definitions, except without <span
class="literal1">defn</span>. To define a method implementation, you
write a form that starts with the method’s name, like <span
class="literal1">thoughts</span>, then supply a vector of parameters and
the method’s body. These methods also allow arity overloading, just like
functions, and you define multiple-arity method implementations
similarly to multiple-arity functions. You can see this in the <span
class="literal1">feelings-about</span> implementation at <span
class="ent">➍</span>.</p>
<p>After you’ve extended the <span
class="literal1">java.lang.String</span> type to implement the <span
class="literal1">Psychodynamics</span> protocol, Clojure knows how to
dispatch the call <span class="literal1">(thoughts "blorb")</span>, and
you get the string <span class="literal1">"blorb thinks, 'Truly, the
character defines the data type'"</span> at <span
class="ent">➎</span>.</p>
<p>What if you want to provide a default implementation, like you did
with multimethods? To do that, you can extend <span
class="literal1">java.lang.Object</span>. This works because every type
in Java (and hence, Clojure) is a descendant of <span
class="literal1">java.lang.Object</span>. If that doesn’t quite make
sense (perhaps because you’re not familiar with object-oriented
programming), don’t worry about it—just know that it works. Here’s how
you would use this technique to provide a default implementation for the
<span class="literal1">Psychodynamics</span> protocol:</p>
<pre class="programs"><code>(extend-type java.lang.Object
 Psychodynamics
 (thoughts [x] &quot;Maybe the Internet is just a vector for toxoplasmosis&quot;)
 (feelings-about
   ([x] &quot;meh&quot;)
   ([x y] (str &quot;meh about &quot; y))))


(thoughts 3)
; =&gt; &quot;Maybe the Internet is just a vector for toxoplasmosis&quot;


(feelings-about 3)
; =&gt; &quot;meh&quot;


(feelings-about 3 &quot;blorb&quot;)
; =&gt; &quot;meh about blorb&quot;</code></pre>
<p>Because we haven’t defined a <span
class="literal1">Psychodynamics</span> implementation for numbers,
Clojure dispatches calls to <span class="literal1">thoughts</span> and
<span class="literal1">feelings</span> to the implementation defined for
<span class="literal1">java.lang.Object</span>.</p>
<p>Instead of making multiple calls to <span
class="literal1">extend-type</span> to extend multiple types, you can
use <span class="literal1">extend-protocol</span>, which lets you define
protocol implementations for multiple types at once. Here’s how you’d
define the preceding protocol implementations:</p>
<pre class="programs"><code>(extend-protocol Psychodynamics
  java.lang.String
  (thoughts [x] &quot;Truly, the character defines the data type&quot;)
  (feelings-about
    ([x] &quot;longing for a simpler way of life&quot;)
    ([x y] (str &quot;envious of &quot; y &quot;&#39;s simpler way of life&quot;)))

  java.lang.Object
 (thoughts [x] &quot;Maybe the Internet is just a vector for toxoplasmosis&quot;)
 (feelings-about
   ([x] &quot;meh&quot;)
   ([x y] (str &quot;meh about &quot; y))))</code></pre>
<p>You might find this technique more convenient than using <span
class="literal1">extend-type</span>. Then again, you might not. How does
<span class="literal1">extend-type</span> make you feel? How about <span
class="literal1">extend-protocol</span>? Come sit down on this couch and
tell me all about it.</p>
<p>It’s important to note that a protocol’s methods “belong” to the
namespace that they’re defined in. In these examples, the fully
qualified names of the <span class="literal1">Psychodynamics</span>
methods are <span class="literal1">data-psychology/thoughts</span> and
<span class="literal1">data-psychology/feelings-about</span>. If you
have an object-oriented background, this might seem weird because
methods belong to data types in OOP. But don’t freak out! It’s just
another way that Clojure gives primacy to abstractions. One consequence
of this fact is that, if you want two different protocols to include
methods with the same name, you’ll need to put the protocols in
different namespaces.</p>
<h3 class="h2"
id="text_part0025.html_ch13lev1sec2"><strong>Records</strong></h3>
<p>Clojure allows you to create <em>records</em>, which are custom,
maplike data types. They’re maplike in that they associate keys with
values, you can look up their values the same way you can with maps, and
they’re immutable like maps. They’re different in that you specify
<em>fields</em> for records. Fields are slots for data; using them is
like specifying which keys a data structure should have. Records are
also different from maps in that you can extend them to implement
protocols.</p>
<p>To create a record, you use <span class="literal1">defrecord</span>
to specify its name and fields:</p>
<pre class="programs"><code>(ns were-records)
(defrecord WereWolf [name title])</code></pre>
<p>This record’s name is <span class="literal1">WereWolf</span>, and its
two fields are <span class="literal1">name</span> and <span
class="literal1">title</span>. You can create an instance of this record
in three ways:</p>
<pre class="programs"><code>➊ (WereWolf. &quot;David&quot; &quot;London Tourist&quot;)
   ; =&gt; #were_records.WereWolf{:name &quot;David&quot;, :title &quot;London Tourist&quot;}


➋ (-&gt;WereWolf &quot;Jacob&quot; &quot;Lead Shirt Discarder&quot;)
   ; =&gt; #were_records.WereWolf{:name &quot;Jacob&quot;, :title &quot;Lead Shirt Discarder&quot;}


➌ (map-&gt;WereWolf {:name &quot;Lucian&quot; :title &quot;CEO of Melodrama&quot;})
   ; =&gt; #were_records.WereWolf{:name &quot;Lucian&quot;, :title &quot;CEO of Melodrama&quot;}</code></pre>
<p>At <span class="ent">➊</span>, we create an instance the same way
we’d create a Java object, using the class instantiation interop call.
(<em>Interop</em> refers to the ability to <span
id="text_part0025.html_page_273" class="calibre4"></span>interact with
native Java constructs within Clojure.) Notice that the arguments must
follow the same order as the field definition. This works because
records are actually Java classes under the covers.</p>
<p>The instance at <span class="ent">➋</span> looks nearly identical to
the one at <span class="ent">➊</span>, but the key difference is that
<span class="literal1">-&gt;WereWolf</span> is a function. When you
create a record, the factory functions <span
class="literal1">-&gt;<em>RecordName</em></span> and <span
class="literal1">map-&gt;<em>RecordName</em></span> are created
automatically. At <span class="ent">➌</span>, <span
class="literal1">map-&gt;WereWolf</span> takes a map as an argument with
keywords that correspond to the record type’s fields and returns a
record.</p>
<p>If you want to use a record type in another namespace, you’ll have to
import it, just like you did with the Java classes in <a
href="#text_part0024.html_ch12" class="calibre4">Chapter 12</a>. Be
careful to replace all dashes in the namespace with underscores. This
brief example shows how you’d import the <span
class="literal1">WereWolf</span> record type in another namespace:</p>
<pre class="programs"><code>(ns monster-mash
  (:import [were_records WereWolf]))
(WereWolf. &quot;David&quot; &quot;London Tourist&quot;)
; =&gt; #were_records.WereWolf{:name &quot;David&quot;, :title &quot;London Tourist&quot;}</code></pre>
<p>Notice that <span class="literal1">were_records</span> has an
underscore, not a dash.</p>
<p>You can look up record values in the same way you look up map values,
and you can also use Java field access interop:</p>
<pre class="programs"><code>   (def jacob (-&gt;WereWolf &quot;Jacob&quot; &quot;Lead Shirt Discarder&quot;))
➊ (.name jacob)
   ; =&gt; &quot;Jacob&quot;


➋ (:name jacob)
   ; =&gt; &quot;Jacob&quot;


➌ (get jacob :name) 
   ; =&gt; &quot;Jacob&quot;</code></pre>
<p>The first example, <span class="literal1">(.name jacob)</span> at
<span class="ent">➊</span>, uses Java interop, and the examples at <span
class="ent">➋</span> and <span class="ent">➌</span> access <span
class="literal1">:name</span> the same way you would with a map.</p>
<p>When testing for equality, Clojure will check that all fields are
equal and that the two comparands have the same type:</p>
<pre class="programs"><code>➊ (= jacob (-&gt;WereWolf &quot;Jacob&quot; &quot;Lead Shirt Discarder&quot;))
   ; =&gt; true


➋ (= jacob (WereWolf. &quot;David&quot; &quot;London Tourist&quot;))
   ; =&gt; false


➌ (= jacob {:name &quot;Jacob&quot; :title &quot;Lead Shirt Discarder&quot;})
   ; =&gt; false</code></pre>
<p>The test at <span class="ent">➊</span> returns <span
class="literal1">true</span> because <span class="literal1">jacob</span>
and the newly created record are of the same type and their fields are
equal. The test at <span class="ent">➋</span> returns <span
class="literal1">false</span> because the fields aren’t equal. The final
test at <span class="ent">➌</span> returns <span
class="literal1">false</span> because the two comparands don’t have the
same type: <span class="literal1">jacob</span> is a <span
class="literal1">WereWolf</span> record, and the other argument is a
map.</p>
<p><span id="text_part0025.html_page_274" class="calibre4"></span>Any
function you can use on a map, you can also use on a record:</p>
<pre class="programs"><code>(assoc jacob :title &quot;Lead Third Wheel&quot;)
; =&gt; #were_records.WereWolf{:name &quot;Jacob&quot;, :title &quot;Lead Third Wheel&quot;}</code></pre>
<p>However, if you <span class="literal1">dissoc</span> a field, the
result’s type will be a plain ol’ Clojure map; it won’t have the same
data type as the original record:</p>
<pre class="programs"><code>(dissoc jacob :title)
; =&gt; {:name &quot;Jacob&quot;} &lt;- that&#39;s not a were_records.WereWolf</code></pre>
<p>This matters for at least two reasons: first, accessing map values is
slower than accessing record values, so watch out if you’re building a
highperformance program. Second, when you create a new record type, you
can extend it to implement a protocol, similar to how you extended a
type using <span class="literal1">extend-type</span> earlier. If you
<span class="literal1">dissoc</span> a record and then try to call a
protocol method on the result, the record’s protocol method won’t be
called.</p>
<p>Here’s how you would extend a protocol when defining a record:</p>
<pre class="programs"><code>➊ (defprotocol WereCreature
➋   (full-moon-behavior [x]))


➌ (defrecord WereWolf [name title]
     WereCreature
     (full-moon-behavior [x]
       (str name &quot; will howl and murder&quot;)))


   (full-moon-behavior (map-&gt;WereWolf {:name &quot;Lucian&quot; :title &quot;CEO of Melodrama&quot;}))
   ; =&gt; &quot;Lucian will howl and murder&quot;</code></pre>
<p>We’ve created a new protocol, <span
class="literal1">WereCreature</span> <span class="ent">➊</span>, with
one method, <span class="literal1">full-moon-behavior</span> <span
class="ent">➋</span>. At <span class="ent">➌</span>, <span
class="literal1">defrecord</span> implements <span
class="literal1">WereCreature</span> for <span
class="literal1">WereWolf</span>. The most interesting part of the <span
class="literal1">full-moon-behavior</span> implementation is that you
have access to <span class="literal1">name</span>. You also have access
to <span class="literal1">title</span> and any other fields that might
be defined for your record. You can also extend records using <span
class="literal1">extend-type</span> and <span
class="literal1">extend-protocol</span>.</p>
<p>When should you use records, and when should you use maps? In
general, you should consider using records if you find yourself creating
maps with the same fields over and over. This tells you that that set of
data represents information in your application’s domain, and your code
will communicate its purpose better if you provide a name based on the
concept you’re trying to model. Not only that, but record access is more
performant than map access, so your program will become a bit more
efficient. Finally, if you want to use protocols, you’ll need to create
a record.</p>
<h3 class="h2" id="text_part0025.html_ch13lev1sec3"><span
id="text_part0025.html_page_275" class="calibre1"></span><strong>Further
Study</strong></h3>
<p>Clojure offers other tools for working with abstractions and data
types. These tools, which I consider advanced, include <span
class="literal1">deftype</span>, <span class="literal1">reify</span>,
and <span class="literal1">proxy</span>. If you’re interested in
learning more, check out the documentation on data types at <em><a
href="http://clojure.org/datatypes/"
class="calibre4">http://clojure.org/datatypes/</a></em>.</p>
<h3 class="h2"
id="text_part0025.html_ch13lev1sec4"><strong>Summary</strong></h3>
<p>One of Clojure’s design principles is to write to abstractions. In
this chapter, you learned how to define your own abstractions using
multimethods and prototypes. These constructs provide polymorphism,
allowing the same operation to behave differently based on the arguments
it’s given. You also learned how to create and use your own associative
data types with <span class="literal1">defrecord</span> and how to
extend records to implement protocols.</p>
<p>When I first started learning Clojure, I was pretty shy about using
multimethods, protocols, and records. However, they are used often in
Clojure libraries, so it’s good to know how they work. Once you get the
hang of them, they’ll help you write cleaner code.</p>
<h3 class="h2" id="text_part0025.html_ch13lev1sec5"><strong><span
class="bordera">Exercises</span></strong></h3>
<p>1. Extend the <span class="literal1">full-moon-behavior</span>
multimethod to add behavior for your own kind of were-creature.</p>
<p>2. Create a <span class="literal1">WereSimmons</span> record type,
and then extend the <span class="literal1">WereCreature</span>
protocol.</p>
<p>3. Create your own protocol, and then extend it using <span
class="literal1">extend-type</span> and <span
class="literal1">extend-protocol</span>.</p>
<p>4. Create a role-playing game that implements behavior using multiple
dispatch.<span id="text_part0025.html_page_276"
class="calibre4"></span></p>
<p><span id="text_part0026.html"></span></p>
<h2 class="h1" id="text_part0026.html_app01"><span
id="text_part0026.html_page_277" class="calibre1"></span><strong><span
class="big1">A</span></strong><br />
<strong>Building and Developing with Leiningen</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>Writing software in any language involves generating
<em>artifacts</em>, which are executable files or library packages that
are meant to be deployed or shared. It also involves managing dependent
artifacts, also called <em>dependencies</em>, by ensuring that they’re
loaded into the project you’re building. The most popular tool among
Clojurists for managing artifacts is Leiningen, and this appendix will
show you how to use it. You’ll also learn how to use Leiningen to
totally enhancify your development experience with
<em>plug-ins</em>.</p>
<h3 class="h2" id="text_part0026.html_app01lev1sec1"><strong>The
Artifact Ecosystem</strong></h3>
<p>Because Clojure is hosted on the Java Virtual Machine (JVM), Clojure
artifacts are distributed as JAR files (covered in <a
href="#text_part0024.html_ch12" class="calibre4">Chapter 12</a>). Java
land already has an entire artifact ecosystem for handling JAR files,
and Clojure uses it. <em>Artifact ecosystem</em> isn’t an official
programming term; I use <span id="text_part0026.html_page_278"
class="calibre4"></span>it to refer to the suite of tools, resources,
and conventions used to identify and distribute artifacts. Java’s
ecosystem grew up around the Maven build tool, and because Clojure uses
this ecosystem, you’ll often see references to Maven. Maven is a huge
tool that can perform all kinds of wacky project management tasks.
Thankfully, you don’t need to get your PhD in Mavenology to be an
effective Clojurist. The only feature you need to know is that Maven
specifies a pattern for identifying artifacts that Clojure projects
adhere to, and it also specifies how to host these artifacts in Maven
<em>repositories</em>, which are just servers that store artifacts for
distribution.</p>
<h4 class="h2"
id="text_part0026.html_app01lev2sec1"><em><strong>Identification</strong></em></h4>
<p>Maven artifacts need a <em>group ID</em>, an <em>artifact ID</em>,
and a <em>version</em>. You can specify these for your project in the
<em>project.clj</em> file. Here’s what the first line of
<em>project.clj</em> looks like for the <span
class="literal1">clojure-noob</span> project you created in <a
href="#text_part0011.html_ch01" class="calibre4">Chapter 1</a>:</p>
<pre class="programs"><code>(defproject clojure-noob &quot;0.1.0-SNAPSHOT&quot;</code></pre>
<p><span class="literal1">clojure-noob</span> is both the group ID and
the artifact ID of your project, and <span
class="literal1">"0.1.0-SNAPSHOT"</span> is its version. In general,
versions are permanent; if you deploy an artifact with version 0.1.0 to
a repository, you can’t make changes to the artifact and deploy it using
the same version number. You’ll need to change the version number. (Many
programmers like the Semantic Versioning system, which you can read
about at <em><a href="http://semver.org/"
class="calibre4">http://semver.org/</a>.</em>) If you want to indicate
that the version is a work in progress and you plan to keep updating it,
you can append <span class="literal1">-SNAPSHOT</span> to your version
number.</p>
<p>If you want your group ID to be different from your artifact ID, you
can separate the two with a slash, like so:</p>
<pre class="programs"><code>(defproject group-id/artifact-id &quot;0.1.0-SNAPSHOT&quot;</code></pre>
<p>Often, developers will use their company name or their GitHub
username as the group ID.</p>
<h4 class="h2"
id="text_part0026.html_app01lev2sec2"><em><strong>Dependencies</strong></em></h4>
<p>Your <em>project.clj</em> file also includes a line that looks like
this, which lists your project’s dependencies:</p>
<pre class="programs"><code>  :dependencies [[org.clojure/clojure &quot;1.7.0&quot;]]</code></pre>
<p>If you want to use a library, add it to this dependency vector using
the same naming schema that you use to name your project. For example,
if you want to easily work with dates and times, you could add the
clj-time library, like this:</p>
<pre class="programs"><code>  :dependencies [[org.clojure/clojure &quot;1.7.0&quot;]
                 [clj-time &quot;0.9.0&quot;]]</code></pre>
<p><span id="text_part0026.html_page_279" class="calibre4"></span>The
next time you start your project, either by running it or by starting a
REPL, Leiningen will automatically download clj-time and make it
available within your project.</p>
<p>The Clojure community has created a multitude of useful libraries,
and a good place to look for them is the Clojure Toolbox at <em><a
href="http://www.clojure-toolbox.com"
class="calibre4">http://www.clojure-toolbox.com</a></em>, which
categorizes projects according to their purpose. Nearly every Clojure
library provides its identifier at the top of its README, making it easy
for you to figure out how to add it to your Leiningen dependencies.</p>
<p>Sometimes you might want to use a Java library, but the identifier
isn’t as readily available. If you want to add Apache Commons Email, for
example, you have to search online until you find a web page that
contains something like this:</p>
<pre class="programs"><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-email&lt;/artifactId&gt;
    &lt;version&gt;1.3.3&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>This XML is how Java projects communicate their Maven identifier. To
add it your Clojure project, you’d change your <span
class="literal1">:dependencies</span> vector so it looks like this:</p>
<pre class="programs"><code>   :dependencies [[org.clojure/clojure &quot;1.7.0&quot;]
                  [clj-time &quot;0.9.0&quot;]
                  [org.apache.commons/commons-email &quot;1.3.3&quot;]]</code></pre>
<p>The main Clojure repository is Clojars (<em><a
href="https://clojars.org/"
class="calibre4">https://clojars.org/</a></em>), and the main Java
repository is The Central Repository (<em><a
href="http://search.maven.org/"
class="calibre4">http://search.maven.org/</a></em>), which is often
referred to as just <em>Central</em> in the same way that San Francisco
residents refer to San Francisco as <em>the city</em>. You can use these
sites to find libraries and their identifiers.</p>
<p>To deploy your own projects to Clojars, all you have to do is create
an account there and run <span class="literal1">lein deploy
clojars</span> in your project. This task generates everything necessary
for a Maven artifact to be stored in a repository, including a POM file
(which I won’t go into) and a JAR file. Then it uploads them to
Clojars.</p>
<h4 class="h2"
id="text_part0026.html_app01lev2sec3"><em><strong>Plug-Ins</strong></em></h4>
<p>Leiningen lets you use <em>plug-ins</em>, which are libraries that
help you when you’re writing code. For example, the Eastwood plug-in is
a Clojure lint tool; it identifies poorly written code. You’ll usually
want to specify your plug-ins in the file
<em>$HOME/.lein/profiles.clj</em>. To add Eastwood, you’d change
<em>profiles.clj</em> to look like this:</p>
<pre class="programs"><code>{:user {:plugins [[jonase/eastwood &quot;0.2.1&quot;]] }}</code></pre>
<p><span id="text_part0026.html_page_280" class="calibre4"></span>This
enables an <span class="literal1">eastwood</span> Leiningen task for all
your projects, which you can run with <span class="literal1">lein
eastwood</span> at the project’s root.</p>
<p>Leiningen’s GitHub project page has excellent documentation on how to
use profiles and plug-ins, and it includes a handy list of plug-ins.</p>
<h3 class="h2"
id="text_part0026.html_app01lev1sec2"><strong>Summary</strong></h3>
<p>This appendix focused on the aspects of project management that are
important but that are difficult to find out about, like what Maven is
and Clojure’s relationship to it. It showed you how to use Leiningen to
name your project, specify dependencies, and deploy to Clojars.
Leiningen offers a lot of functionality for software development tasks
that don’t involve actually writing your code. If you want to find out
more, check out the Leiningen tutorial online at <em><a
href="https://github.com/technomancy/leiningen/blob/stable/doc/TUTORIAL.md/"
class="calibre4">https://github.com/technomancy/leiningen/blob/stable/doc/TUTORIAL.md/</a></em>.</p>
<p><span id="text_part0027.html"></span></p>
<h2 class="h1" id="text_part0027.html_app02"><span
id="text_part0027.html_page_281" class="calibre1"></span><strong><span
class="big1">B</span></strong><br />
<strong>Boot, the Fancy Clojure Build Framework</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>Boot is an alternative to Leiningen that provides the same
functionality. Leiningen’s more popular (as of the summer of 2015), but
I personally like to work with Boot because it’s easier to extend. This
appendix explains Boot’s underlying concepts and guides you through
writing your first Boot tasks. If you’re interested in using Boot to
build projects right this second, check out its GitHub README (<em><a
href="https://github.com/boot-clj/boot/"
class="calibre4">https://github.com/boot-clj/boot/</a></em>) and its
wiki (<em><a href="https://github.com/boot-clj/boot/wiki/"
class="calibre4">https://github.com/boot-clj/boot/wiki/</a></em>).</p>
<div class="note">
<p><span class="bordera"><strong>NOTE</strong></span></p>
<p><em>As of this writing, Boot has limited support for Windows. The
Boot team welcomes contributions!</em></p>
</div>
<h3 class="h2" id="text_part0027.html_app02lev1sec1"><span
id="text_part0027.html_page_282" class="calibre1"></span><strong>Boot’s
Abstractions</strong></h3>
<p>Created by Micha Niskin and Alan Dipert, Boot is a fun and powerful
addition to the Clojure tooling landscape. On the surface, it’s a
convenient way to build Clojure applications and run Clojure tasks from
the command line. Dig a little deeper and you’ll see that Boot is like
the Lisped-up lovechild of Git and Unix in that it provides abstractions
that make it more pleasant to write code that exists at the intersection
of your operating system and your application.</p>
<p>Unix provides abstractions that we’re all familiar with to the point
where we take them for granted. (Would it kill you to take your computer
out to a nice restaurant once in a while?) The process abstraction lets
you reason about programs as isolated units of logic that can be easily
composed into a stream-processing pipeline through the STDIN and STDOUT
file descriptors. These abstractions make certain kinds of operations,
like text processing, very straightforward.</p>
<p>Similarly, Boot provides abstractions that make it easy to compose
independent operations into the kinds of complex, coordinated operations
that build tools end up doing, like converting ClojureScript into
JavaScript. Boot’s task abstraction lets you easily define units of
logic that communicate through <em>filesets</em>. The fileset
abstraction keeps track of the evolving build context and provides a
well-defined, reliable method of task coordination.</p>
<p>That’s a lot of high-level description, which hopefully has hooked
your attention. But I would be ashamed to leave you with a plateful of
metaphors. Oh no, dear reader, that was only the appetizer. Throughout
the rest of this appendix, you’ll learn how to build your own Boot
tasks. Along the way, you’ll discover that build tools can actually have
a conceptual foundation.</p>
<h3 class="h2"
id="text_part0027.html_app02lev1sec2"><strong>Tasks</strong></h3>
<p>Like make, rake, grunt, and other build tools of yore, Boot lets you
define tasks. <em>Tasks</em> are named operations that take command line
options dispatched by some intermediary program (make, rake, Boot).</p>
<p>Boot provides the dispatching program, <em>boot</em>, and a Clojure
library that makes it easy for you to define named operations and their
command line options with the <span class="literal1">deftask</span>
macro. To see what all the fuss is about, let’s create your first task.
Normally, programming tutorials encourage you to write code that prints
“Hello World,” but I like my examples to have real-world utility, so
your task is to print “My pants are on fire!” This information is
objectively more useful. First, install Boot; then create a new
directory named <em>boot-walkthrough</em>, navigate to that directory,
create a file named <em>build.boot,</em> and write this:</p>
<pre class="programs"><code>(deftask fire
  &quot;Prints &#39;My pants are on fire!&#39;&quot;
  []
  (println &quot;My pants are on fire!&quot;))</code></pre>
<p><span id="text_part0027.html_page_283" class="calibre4"></span>Now
run this task from the command line with <span class="literal1">boot
fire</span>; you should see the message you wrote printed to your
terminal. This task demonstrates two out of the three task components:
the task is named (<span class="literal1">fire</span>), and it’s
dispatched by boot. This is super cool. You’ve essentially created a
Clojure shell script, stand-alone Clojure code that you can run from the
command line with ease. No <em>project.clj</em>, directory structure, or
namespaces needed!</p>
<p>Let’s extend the example to demonstrate how you’d write command line
options:</p>
<pre class="programs"><code>(deftask fire
  &quot;Announces that something is on fire&quot;
  [t thing     THING str &quot;The thing that&#39;s on fire&quot;
   p pluralize       bool &quot;Whether to pluralize&quot;]
  (let [verb (if pluralize &quot;are&quot; &quot;is&quot;)]
    (println &quot;My&quot; thing verb &quot;on fire!&quot;)))</code></pre>
<p>Try running the task like so:</p>
<pre class="programs"><code>boot fire -t heart
# =&gt; My heart is on fire!


boot fire -t logs -p
# =&gt; My logs are on fire!</code></pre>
<p>In the first instance, either you’re newly in love or you need to be
rushed to the emergency room. In the second, you are a Boy Scout
awkwardly expressing your excitement over meeting the requirements for a
merit badge. In both instances, you were able to easily specify options
for the task.</p>
<p>This refinement of the <span class="literal1">fire</span> task
introduced two command line options, <span class="literal1">thing</span>
and <span class="literal1">pluralize</span>. Both options are defined
using a <em>domain-specific language (DSL)</em>. DSLs are their own
topic, but briefly, the term refers to mini-languages that you can use
within a larger program to write compact, expressive code for narrowly
defined domains (like defining options).</p>
<p>In the option <span class="literal1">thing</span>, <span
class="literal1">t</span> specifies its short name, and <span
class="literal1">thing</span> specifies its long name. <span
class="literal1">THING</span> is a bit complicated, and I’ll get to it
in a second. <span class="literal1">str</span> specifies the option’s
type, and Boot uses that to validate the argument and convert it. <span
class="literal1">"The thing that's on fire"</span> is the documentation
for the option. You can view a task’s documentation in the terminal with
<span class="literal1">boot task-name -h</span>:</p>
<pre class="programs"><code>boot fire -h
# Announces that something is on fire
#
# Options:
#   -h, --help        Print this help info.
#   -t, --thing THING Set the thing that&#39;s on fire to THING.
#   -p, --pluralize   Whether to pluralize</code></pre>
<p>Pretty groovy! Boot makes it very easy to write code that’s meant to
be invoked from the command line.</p>
<p><span id="text_part0027.html_page_284" class="calibre4"></span>Now,
let’s look at <span class="literal1">THING</span>. <span
class="literal1">THING</span> is an <em>optarg</em>, and it indicates
that this option expects an argument. You don’t have to include an
optarg when you’re defining an option (notice that the <span
class="literal1">pluralize</span> option has no optarg). The optarg
doesn’t have to correspond to the full name of the option; you could
replace <span class="literal1">THING</span> with <span
class="literal1">BILLY_JOEL</span> or whatever you want and the task
would work the same. You can also designate complex options using the
optarg. (Visit <em><a
href="https://github.com/boot-clj/boot/wiki/Task-Options-DSL#complex-options"
class="calibre4">https://github.com/boot-clj/boot/wiki/Task-Options-DSL#complex-options</a></em>
for Boot’s documentation on the subject.) Basically, complex options
allow you to specify that option arguments should be treated as maps,
sets, vectors, or even nested collections. It’s pretty powerful.</p>
<p>Boot provides you with all the tools you could ask for to build
command line interfaces with Clojure. And you’ve only just started
learning about it!</p>
<h3 class="h2" id="text_part0027.html_app02lev1sec3"><strong>The
REPL</strong></h3>
<p>Boot comes with a number of useful built-in tasks, including a REPL
task. Run <span class="literal1">boot repl</span> to fire up that puppy.
The Boot REPL is similar to Leiningen’s in that it handles loading your
project code so you can play around with it. You might not think this
applies to the project you’ve been writing because you’ve only written
tasks, but you can actually run tasks in the REPL (I’ve omitted the
<span class="literal1">boot.user=&gt;</span> prompt). You can specify
options using a string:</p>
<pre class="programs"><code>(fire &quot;-t&quot; &quot;NBA Jam guy&quot;)
; My NBA Jam guy is on fire!
; =&gt; nil</code></pre>
<p>Notice that the option’s value comes right after the option.</p>
<p>You can also specify an option using a keyword:</p>
<pre class="programs"><code>(fire :thing &quot;NBA Jam guy&quot;)
; My NBA Jam guy is on fire!
; =&gt; nil</code></pre>
<p>You can also combine options:</p>
<pre class="programs"><code>(fire &quot;-p&quot; &quot;-t&quot; &quot;NBA Jam guys&quot;)
; My NBA Jam guys are on fire!
; =&gt; nil


(fire :pluralize true :thing &quot;NBA Jam guys&quot;)
; My NBA Jam guys are on fire!
; =&gt; nil</code></pre>
<p>And of course, you can use <span class="literal1">deftask</span> in
the REPL as well—it’s just Clojure, after all. The takeaway is that Boot
lets you interact with your tasks as Clojure functions, because that’s
what they are.</p>
<h3 class="h2" id="text_part0027.html_app02lev1sec4"><span
id="text_part0027.html_page_285"
class="calibre1"></span><strong>Composition and
Coordination</strong></h3>
<p>If what you’ve seen so far was all that Boot had to offer, it’d be a
pretty swell tool, but it wouldn’t be very different from other build
tools. One feature that sets Boot apart is how it lets you compose
tasks. For comparison’s sake, here’s an example Rake invocation (Rake is
the premier Ruby build tool):</p>
<pre class="programs"><code>rake db:create db:migrate db:seed</code></pre>
<p>This code will create a database, run migrations on it, and populate
it with seed data when run in a Rails project. However, worth noting is
that Rake doesn’t provide any way for these tasks to communicate with
each other. Specifying multiple tasks is just a convenience, saving you
from having to run <span class="literal1">rake db:create; rake
db:migrate; rake db:seed</span>. If you want to access the result of
Task A within Task B, the build tool doesn’t help you; you have to
manage that coordination yourself. Usually, you’ll do this by shoving
the result of Task A into a special place on the filesystem and then
making sure Task B reads that special place. This looks like programming
with mutable, global variables, and it’s just as brittle.</p>
<h4 class="h2"
id="text_part0027.html_app02lev2sec1"><em><strong>Handlers and
Middleware</strong></em></h4>
<p>Boot addresses this task communication problem by treating tasks as
<em>middleware factories</em>. If you’re familiar with Ring, Boot’s
tasks work very similarly, so feel free to skip to “<a
href="#text_part0027.html_app02lev2sec2" class="calibre4">Tasks Are
Middleware Factories</a>” on <a href="#text_part0027.html_page_287"
class="calibre4">page 287</a>. If you’re not familiar with the concept
of middleware, allow me to explain! <em>Middleware</em> refers to a set
of <em>conventions</em> that programmers adhere to so they can flexibly
create domain-specific function pipelines. That’s pretty dense, so let’s
un-dense it. I’ll discuss the <em>flexible</em> part in this section and
cover <em>domain-specific</em> in “<a
href="#text_part0027.html_app02lev1sec5" class="calibre4">Filesets</a>”
on <a href="#text_part0027.html_page_288" class="calibre4">page
288</a>.</p>
<p>To understand how the middleware approach differs from
run-of-the-mill function composition, here’s an example of composing
everyday functions:</p>
<pre class="programs"><code>(def strinc (comp str inc))
(strinc 3)
; =&gt; &quot;4&quot;</code></pre>
<p>There’s nothing interesting about this function composition. In fact,
this function composition is so unremarkable that it strains my
abilities as a writer to actually say anything about it. There are two
functions, each does its own thing, and now they’ve been composed into
one. Whoop-dee-doo!</p>
<p>Middleware introduces an extra step to function composition, giving
you more flexibility in defining your function pipeline. Suppose, in the
<span id="text_part0027.html_page_286" class="calibre4"></span>preceding
example, that you wanted to return <span class="literal1">"I don't like
the number X"</span> for arbitrary numbers but return a string-ified
number for everything else. Here’s how you could do that:</p>
<pre class="programs"><code>(defn whiney-str
  [rejects]
  {:pre [(set? rejects)]}
  (fn [x]
    (if (rejects x)
      (str &quot;I don&#39;t like &quot; x)
      (str x))))


(def whiney-strinc (comp (whiney-str #{2}) inc))
(whiney-strinc 1)
; =&gt; &quot;I don&#39;t like 2&quot;</code></pre>
<p>Now let’s take it one step further. What if you want to decide
whether or not to call <span class="literal1">inc</span> in the first
place? <a href="#text_part0027.html_app02list1" class="calibre4">Listing
B-1</a> shows how you could do that:</p>
<pre class="programs"><code>   (defn whiney-middleware
     [next-handler rejects]
     {:pre [(set? rejects)]}
     (fn [x]
➊     (if (= x 1)
         &quot;I&#39;m not going to bother doing anything to that&quot;
         (let [y (next-handler x)]
           (if (rejects y)
             (str &quot;I don&#39;t like &quot; y)
             (str y))))))


(def whiney-strinc (whiney-middleware inc #{2}))
(whiney-strinc 1)
; =&gt; &quot;I don&#39;t like 2&quot;</code></pre>
<p><span id="text_part0027.html_app02list1"
class="calibre4"></span><em>Listing B-1: The middleware approach to
function composition lets you introduce choice</em></p>
<p>Here, instead of using <span class="literal1">comp</span> to create
your function pipeline, you pass the next function in the pipeline as
the first argument to the middleware function. In this case, you’re
passing <span class="literal1">inc</span> as the first argument to <span
class="literal1">whiney-middleware</span> as <span
class="literal1">next-handler</span>. <span
class="literal1">whiney-middleware</span> then returns an anonymous
function that closes over <span class="literal1">inc</span> and has the
ability to choose whether to call it or not. You can see this choice at
<span class="ent">➊</span>.</p>
<p>We say that a middleware takes a handler as its first argument and
returns a handler. In this example, <span
class="literal1">whiney-middleware</span> takes a handler as its first
argument, <span class="literal1">inc</span>, and it returns another
handler, the anonymous function with <span class="literal1">x</span> as
its only argument. Middleware can also take extra arguments, like <span
class="literal1">rejects</span>, that act as configuration. The result
is that the handler returned by the middleware can behave more flexibly
(thanks to configuration), and it has more control over the function
pipeline (because it can choose whether or not to call the next
handler).</p>
<h4 class="h2" id="text_part0027.html_app02lev2sec2"><span
id="text_part0027.html_page_287"
class="calibre1"></span><em><strong>Tasks Are Middleware
Factories</strong></em></h4>
<p>Boot takes this pattern of making function composition more flexible
one step further by separating middleware configuration from handler
creation. First, you create a function that takes <em>n</em>
configuration arguments. This is the <em>middleware factory</em>, and it
returns a middleware function. The middleware function expects one
argument, the next handler, and it returns a handler, just like in the
preceding example. Here’s a whiney middleware factory:</p>
<pre class="programs"><code>(defn whiney-middleware-factory
  [rejects]
  {:pre [(set? rejects)]}
  (fn [handler]
    (fn [x]
     (if (= x 1)
       &quot;I&#39;m not going to bother doing anything to that&quot;
       (let [y (handler x)]
         (if (rejects y)
           (str &quot;I don&#39;t like &quot; y &quot; :&#39;(&quot;)
           (str y)))))))


(def whiney-strinc ((whiney-middleware-factory #{3}) inc))</code></pre>
<p>As you can see, this code is nearly identical to <a
href="#text_part0027.html_app02list1" class="calibre4">Listing B-1</a>.
The change is that the topmost function, <span
class="literal1">whiney-middleware-factory</span>, now only accepts one
argument, <span class="literal1">rejects</span>. It returns an anonymous
function, the middleware, which expects one argument, a handler. The
rest of the code is the same.</p>
<p>In Boot, tasks can act as middleware factories. To show this, let’s
split the <span class="literal1">fire</span> task into two tasks: <span
class="literal1">what</span> and <span class="literal1">fire</span> (see
<a href="#text_part0027.html_app02list2" class="calibre4">Listing
B-2</a>). <span class="literal1">what</span> lets you specify an object
and whether it’s plural, and <span class="literal1">fire</span>
announces that it’s on fire. This is great modular software engineering
because it allows you to add other tasks, like <span
class="literal1">gnomes</span>, to announce that a thing is being
overrun with gnomes, which is just as objectively useful. (As an
exercise, try creating the gnome task. It should compose with the <span
class="literal1">what</span> task, just as <span
class="literal1">fire</span> does.)</p>
<pre class="programs"><code>   (deftask what
     &quot;Specify a thing&quot;
     [t thing     THING str  &quot;An object&quot;
      p pluralize       bool &quot;Whether to pluralize&quot;]
     (fn middleware [next-handler]
➊     (fn handler [fileset]
         (next-handler (merge fileset {:thing thing :pluralize pluralize})))))
   (deftask fire
     &quot;Announce a thing is on fire&quot;
     []
     (fn middleware [next-handler]
➋     (fn handler [fileset]
         (let [verb (if (:pluralize fileset) &quot;are&quot; &quot;is&quot;)]

         (println &quot;My&quot; (:thing fileset) verb &quot;on fire!&quot;)
         fileset))))</code></pre>
<p><span id="text_part0027.html_app02list2"
class="calibre4"></span><em>Listing B-2: The full code for composable
Boot tasks that announce something’s on fire</em></p>
<p>Here’s how you’d run this on the command line:</p>
<pre class="programs"><code>boot what -t &quot;pants&quot; -p – fire</code></pre>
<p>And here’s how you’d run it in the REPL:</p>
<pre class="programs"><code>(boot (what :thing &quot;pants&quot; :pluralize true) (fire))</code></pre>
<p>Wait a minute, what’s that <span class="literal1">boot</span> call
doing there? And what’s with <span class="literal1">fileset</span> at
<span class="ent">➊</span> and <span class="ent">➋</span>? In Micha’s
words, “The <span class="literal1">boot</span> macro takes care of setup
and cleanup (creating the initial fileset, stopping servers started by
tasks, things like that). Tasks are functions, so you can call them
directly, but if they use the fileset, they will fail unless you call
them via the <span class="literal1">boot</span> macro.” Let’s take a
closer look at filesets.</p>
<h3 class="h2"
id="text_part0027.html_app02lev1sec5"><strong>Filesets</strong></h3>
<p>Earlier I mentioned that middleware is for creating
<em>domain-specific</em> function pipelines. All that means is that each
handler expects to receive domain-specific data and returns
domain-specific data. With Ring, for example, each handler expects to
receive a request map representing the HTTP request, which might look
something like this:</p>
<pre class="programs"><code>{:server-port 80
 :request-method :get
 :scheme :http}</code></pre>
<p>Each handler can choose to modify this request map in some way before
passing it on to the next handler, say, by adding a <span
class="literal1">:params</span> key with a nice Clojure map of all query
string and POST parameters. Ring handlers return a <em>response
map</em>, which consists of the keys <span
class="literal1">:status</span>, <span class="literal1">:headers</span>,
and <span class="literal1">:body</span>, and once again each handler can
transform this data in some way before returning it to its parent
handler.</p>
<p>In Boot, each handler receives and returns a <em>fileset</em>. The
fileset abstraction lets you treat files on your filesystem as immutable
data, and this is a great innovation for build tools because building
projects is so file-centric. For example, your project might need to
place temporary, intermediary files on the filesystem. Usually, with
most build tools, these files get placed in some specially named place,
say, <em>project/target/tmp</em>. The problem with this is that
<em>project/target/tmp</em> is effectively a global variable, and other
tasks can accidentally muck it up.</p>
<p><span id="text_part0027.html_page_289" class="calibre4"></span>Boot’s
fileset abstraction solves this problem by adding a layer of indirection
on top of the filesystem. Let’s say Task A creates File X and tells the
fileset to store it. Behind the scenes, the fileset stores the file in
an anonymous, temporary directory. The fileset then gets passed to Task
B, and Task B modifies File X and asks the fileset to store the result.
Behind the scenes, a new file, File Y, is created and stored, but File X
remains untouched. In Task B, an updated fileset is returned. This is
the equivalent of doing <span class="literal1">assoc-in</span> with a
map: Task A can still access the original fileset and the files it
references.</p>
<p>And you didn’t even use any of this cool file management
functionality in the <span class="literal1">what</span> and <span
class="literal1">fire</span> tasks in <a
href="#text_part0027.html_app02list2" class="calibre4">Listing B-2</a>!
Nevertheless, when Boot composes tasks, it expects handlers to receive
and return fileset records. Therefore, to convey your data across tasks,
you sneakily added it to the fileset record using <span
class="literal1">(merge fileset {:thing thing :pluralize
pluralize})</span>.</p>
<p>Although that covers the basic concept of a middleware factory,
you’ll need to learn a bit more to take full advantage of filesets. The
mechanics of working with filesets are all explained in the fileset wiki
(<em><a href="https://github.com/boot-clj/boot/wiki/Filesets"
class="calibre4">https://github.com/boot-clj/boot/wiki/Filesets</a></em>).
In the meantime, I hope this information gave you a good conceptual
overview!</p>
<h3 class="h2" id="text_part0027.html_app02lev1sec6"><strong>Next
Steps</strong></h3>
<p>The point of this appendix was to explain the concepts behind Boot.
However, Boot also has a bunch of other functions, like <span
class="literal1">set-env!</span> and <span
class="literal1">task-options!</span>, that make your programming life
easier when you’re actually using it. It offers amazing magical
features, like providing classpath isolation so you can run multiple
projects using one JVM, and letting you add new dependencies to your
project without having to restart your REPL. If Boot tickles your fancy,
check out its README for more information on real-world usage. Also, its
wiki provides top-notch documentation. <span
id="text_part0027.html_page_290" class="calibre4"></span></p>
<p><span id="text_part0028.html"></span></p>
<h2 class="h1" id="text_part0028.html_app03"><span
id="text_part0028.html_page_291"
class="calibre1"></span><strong>Farewell!</strong></h2>
<div class="image1">
<img src="images_00007.jpeg" class="calibre3" alt="image" />
</div>
<p>As Semisonic’s hit ’90s song “Closing Time” teaches us, every new
beginning comes from some other beginning’s end. Congratulations, noble
reader, on completing this Clojure journey. I hope you’ve found it
rewarding, and I hope you’re looking forward to more!</p>
<p>And believe me, there’s so much more. One of the things I like most
about Clojure is that there’s an entire world to explore. Logic
programming, parsers, type systems—name a fun realm of computer science,
and you can investigate it with Clojure. I leave you with my humble
suggestions of where to go next.</p>
<p>If you want to get a broad overview of the Clojure ecosystem, check
out <em><a href="http://www.clojure-toolbox.com/"
class="calibre4">http://www.clojure-toolbox.com/</a></em>, which lists
hundreds of Clojure projects organized by the problem they solve.</p>
<p>If you’re interested in web programming, a great place to start is
the Luminus framework (<em><a href="http://www.luminusweb.net/"
class="calibre4">http://www.luminusweb.net/</a></em>). The documentation
is excellent, and you’ll have a website running in no time.</p>
<p><span id="text_part0028.html_page_292" class="calibre4"></span>To
stay up-to-date with Clojure news, a great resource is Eric Normand’s
Clojure Gazzette (<em><a href="http://www.clojuregazette.com/"
class="calibre4">http://www.clojuregazette.com/</a></em>). There’s also
the Clojure mailing list, of course (<em><a
href="https://groups.google.com/forum/#!forum/clojure"
class="calibre4">https://groups.google.com/forum/#!forum/clojure</a></em>)
and the Clojure subreddit is a helpful, friendly place, too (<em><a
href="http://www.reddit.com/r/clojure"
class="calibre4">http://www.reddit.com/r/clojure</a></em>).</p>
<p>If Twitter is your social media outlet of choice, then @swannodette
(David Nolen), @gigasquid (Carin Meier), @puredanger (Alex Miller),
@ztellman (Zach Tellman), @bbatsov (Bozhidar Batsov), and @stuartsierra
(Stuart Sierra) are your huckleberries. You could also follow me,
@nonrecursive!</p>
<p>Farewell, little teacup, and have fun Clojuring!</p>
<p><span id="text_part0029.html"></span></p>
<h2 class="h1" id="text_part0029.html_index"><span
id="text_part0029.html_page_293"
class="calibre1"></span><strong>Index</strong></h2>
<h3 class="h2"><strong>Symbols</strong></h3>
<p><span class="literal1">+</span> (addition operator), <a
href="#text_part0014.html_page_36" class="calibre4">36–37</a></p>
<p><span class="literal1">@</span>, <a
href="#text_part0018.html_page_155" class="calibre4">155</a>, <a
href="#text_part0021.html_page_197" class="calibre4">197</a></p>
<p><span class="literal1">&gt;!!</span> (blocking put), <a
href="#text_part0023.html_page_235" class="calibre4">235–238</a></p>
<p><span class="literal1">&lt;!!</span> (blocking take), <a
href="#text_part0023.html_page_235" class="calibre4">235–238</a></p>
<p><span class="literal1">.</span> (dot operator), <a
href="#text_part0024.html_page_258" class="calibre4">258–259</a></p>
<p><span class="literal1">=</span> (equality operator), <a
href="#text_part0014.html_page_39" class="calibre4">39</a></p>
<p><span class="literal1">#'</span>, <a
href="#text_part0017.html_page_128" class="calibre4">128</a></p>
<p><span class="literal1">&gt;!</span> (parking put), <a
href="#text_part0023.html_page_235" class="calibre4">235–238</a></p>
<p><span class="literal1">&lt;!</span> (parking take), <a
href="#text_part0023.html_page_235" class="calibre4">235–238</a></p>
<p><span class="literal1">'</span> (quote) reader macro, <a
href="#text_part0018.html_page_154" class="calibre4">154–155</a></p>
<p><span class="literal1">&amp;</span> (rest parameter), <a
href="#text_part0014.html_page_54" class="calibre4">54</a></p>
<h3 class="h2"><strong>A</strong></h3>
<p>abstractions, <a href="#text_part0025.html_page_265"
class="calibre4">265–266</a></p>
<p>implementing, <a href="#text_part0025.html_page_270"
class="calibre4">270</a></p>
<p>through indirection, <a href="#text_part0015.html_page_77"
class="calibre4">77</a></p>
<p>with macros, <a href="#text_part0019.html_page_183"
class="calibre4">183</a></p>
<p>abstract syntax tree (AST), <a href="#text_part0018.html_page_149"
class="calibre4">149</a></p>
<p><span class="literal1">add-watch</span>, <a
href="#text_part0022.html_page_216" class="calibre4">216</a></p>
<p><span class="literal1">alias</span>, <a
href="#text_part0017.html_page_132" class="calibre4">132</a></p>
<p><span class="literal1">alter</span>, <a
href="#text_part0022.html_page_219" class="calibre4">219–221</a></p>
<p><span class="literal1">alter-var-root</span> function, <a
href="#text_part0022.html_page_227" class="calibre4">227</a></p>
<p><span class="literal1">and</span> (Boolean operator), <a
href="#text_part0014.html_page_40" class="calibre4">40</a></p>
<p>source code, <a href="#text_part0019.html_page_168"
class="calibre4">168</a></p>
<p><span class="literal1">apply</span> function, <a
href="#text_part0015.html_page_91" class="calibre4">91</a></p>
<p>architecture, of code, <a href="#text_part0016.html_page_110"
class="calibre4">110</a></p>
<p>arity, <a href="#text_part0014.html_page_52"
class="calibre4">52–54</a></p>
<p>overloading, <a href="#text_part0014.html_page_52"
class="calibre4">52–53</a></p>
<p>artifact ecosystem, <a href="#text_part0026.html_page_277"
class="calibre4">277–280</a></p>
<p>artifacts, <a href="#text_part0026.html_page_277"
class="calibre4">277</a></p>
<p><span class="literal1">assoc-in</span>, <a
href="#text_part0016.html_page_114" class="calibre4">114</a></p>
<p>AST (abstract syntax tree), <a href="#text_part0018.html_page_149"
class="calibre4">149</a></p>
<p>asynchronous tasks, <a href="#text_part0021.html_page_191"
class="calibre4">191</a></p>
<p>atomic values, <a href="#text_part0022.html_page_210"
class="calibre4">210</a></p>
<p>atoms, <a href="#text_part0022.html_page_212"
class="calibre4">212–217</a></p>
<p><span class="literal1">auto-gensym</span>, <a
href="#text_part0019.html_page_177" class="calibre4">177–178</a></p>
<h3 class="h2"><strong>B</strong></h3>
<p>binding</p>
<p>with <span class="literal1">def</span>, <a
href="#text_part0014.html_page_40" class="calibre4">40–41</a></p>
<p>dynamic vars, <a href="#text_part0022.html_page_223"
class="calibre4">223–227</a></p>
<p>with <span class="literal1">let</span>, <a
href="#text_part0014.html_page_61" class="calibre4">61–63</a></p>
<p>local, <a href="#text_part0018.html_page_157"
class="calibre4">157–158</a></p>
<p>blocking, <a href="#text_part0021.html_page_191"
class="calibre4">191</a></p>
<p>blocking put (<span class="literal1">&gt;!!</span>), <a
href="#text_part0023.html_page_235" class="calibre4">235–238</a></p>
<p>blocking take (<span class="literal1">&lt;!!</span>), <a
href="#text_part0023.html_page_235" class="calibre4">235–238</a></p>
<p>Boolean</p>
<p>expressions, <a href="#text_part0014.html_page_39"
class="calibre4">39–40</a></p>
<p>forms, <a href="#text_part0014.html_page_37"
class="calibre4">37–38</a></p>
<p>operators, <a href="#text_part0014.html_page_40"
class="calibre4">40</a></p>
<p>values, <a href="#text_part0014.html_page_39"
class="calibre4">39</a></p>
<p>Boot</p>
<p>classpath isolation, <a href="#text_part0027.html_page_289"
class="calibre4">289</a></p>
<p>composition, <a href="#text_part0027.html_page_285"
class="calibre4">285–288</a></p>
<p><span class="literal1">deftask</span>, <a
href="#text_part0027.html_page_282" class="calibre4">282</a></p>
<p>documentation, <a href="#text_part0027.html_page_283"
class="calibre4">283</a></p>
<p>filesets, <a href="#text_part0027.html_page_282"
class="calibre4">282</a>, <a href="#text_part0027.html_page_288"
class="calibre4">288–289</a></p>
<p>middleware, <a href="#text_part0027.html_page_285"
class="calibre4">285–286</a></p>
<p>middleware factories, <a href="#text_part0027.html_page_285"
class="calibre4">285</a>, <a href="#text_part0027.html_page_287"
class="calibre4">287–288</a></p>
<p>optarg, <a href="#text_part0027.html_page_284"
class="calibre4">284</a></p>
<p>REPL, <a href="#text_part0027.html_page_284"
class="calibre4">284</a></p>
<p>tasks, <a href="#text_part0027.html_page_282"
class="calibre4">282–284</a></p>
<p><span class="literal1">bound-fn</span>, <a
href="#text_part0022.html_page_227" class="calibre4">227</a></p>
<p>Brave and True Ale example, <a href="#text_part0019.html_page_180"
class="calibre4">180</a></p>
<h3 class="h2"><strong>C</strong></h3>
<p>callbacks</p>
<p>hell, <a href="#text_part0023.html_page_244"
class="calibre4">244</a></p>
<p>with promises, <a href="#text_part0021.html_page_202"
class="calibre4">202</a></p>
<p>Central Repository, <a href="#text_part0026.html_page_279"
class="calibre4">279</a></p>
<p><span class="literal1">chan</span>, <a
href="#text_part0023.html_page_235" class="calibre4">235</a></p>
<p>channels, <a href="#text_part0023.html_page_235"
class="calibre4">235–237</a></p>
<p>buffering, <a href="#text_part0023.html_page_236"
class="calibre4">236–237</a></p>
<p>timeout, <a href="#text_part0023.html_page_242"
class="calibre4">242</a></p>
<p><span id="text_part0029.html_page_294" class="calibre4"></span><span
class="literal1">char</span>, <a href="#text_part0016.html_page_120"
class="calibre4">120</a></p>
<p>cheese heist, <a href="#text_part0017.html_page_130"
class="calibre4">130</a>, <a href="#text_part0017.html_page_140"
class="calibre4">140–144</a></p>
<p>CIDER package, <a href="#text_part0012.html_page_23"
class="calibre4">23–28</a></p>
<p>handling errors, <a href="#text_part0012.html_page_27"
class="calibre4">27–28</a></p>
<p>installation, <a href="#text_part0012.html_page_23"
class="calibre4">23</a></p>
<p>key bindings, <a href="#text_part0012.html_page_25"
class="calibre4">25–27</a></p>
<p>starting, <a href="#text_part0012.html_page_23"
class="calibre4">23</a></p>
<p>class instantiation, <a href="#text_part0025.html_page_272"
class="calibre4">272</a></p>
<p>classpath, <a href="#text_part0024.html_page_252"
class="calibre4">252</a></p>
<p>Clojars repository, <a href="#text_part0026.html_page_279"
class="calibre4">279</a></p>
<p>Clojure</p>
<p>compiler, <a href="#text_part0011.html_page_4"
class="calibre4">4</a></p>
<p>hosted language, <a href="#text_part0011.html_page_4"
class="calibre4">4</a></p>
<p>metaphysics, <a href="#text_part0022.html_page_210"
class="calibre4">210–211</a></p>
<p><em>clojure.jar</em>, <a href="#text_part0024.html_page_255"
class="calibre4">255–257</a></p>
<p>closures, <a href="#text_part0014.html_page_58"
class="calibre4">58</a></p>
<p>collection abstraction, <a href="#text_part0015.html_page_88"
class="calibre4">88–90</a></p>
<p>command-line interaction, <a href="#text_part0016.html_page_121"
class="calibre4">121–124</a></p>
<p>comma-separated values (CSV), <a href="#text_part0015.html_page_93"
class="calibre4">93</a></p>
<p><span class="literal1">commute</span>, <a
href="#text_part0022.html_page_221" class="calibre4">221–223</a></p>
<p>compare-and-set, <a href="#text_part0022.html_page_214"
class="calibre4">214–215</a></p>
<p><span class="literal1">comp</span> function, <a
href="#text_part0016.html_page_105" class="calibre4">105–106</a>, <a
href="#text_part0016.html_page_120" class="calibre4">120</a></p>
<p>compilation, <a href="#text_part0024.html_page_248"
class="calibre4">248–252</a></p>
<p><span class="literal1">complement</span> function, <a
href="#text_part0015.html_page_92" class="calibre4">92–93</a></p>
<p><span class="literal1">concat</span> function, <a
href="#text_part0015.html_page_84" class="calibre4">84</a></p>
<p>concurrency, <a href="#text_part0021.html_page_190"
class="calibre4">190–196</a></p>
<p>dining philosophers problem, <a href="#text_part0021.html_page_195"
class="calibre4">195–196</a></p>
<p>dwarven berserker problem, <a href="#text_part0021.html_page_195"
class="calibre4">195</a></p>
<p>mutual exclusion problem, <a href="#text_part0021.html_page_194"
class="calibre4">194–195</a>, <a href="#text_part0022.html_page_210"
class="calibre4">210</a></p>
<p>preventing with delays, <a href="#text_part0021.html_page_199"
class="calibre4">199</a></p>
<p>nondeterministic execution, <a href="#text_part0022.html_page_208"
class="calibre4">208–210</a></p>
<p>queues, <a href="#text_part0023.html_page_243"
class="calibre4">243–244</a></p>
<p>reference cell problem, <a href="#text_part0021.html_page_193"
class="calibre4">193–194</a>, <a href="#text_part0022.html_page_207"
class="calibre4">207</a>, <a href="#text_part0022.html_page_209"
class="calibre4">209</a></p>
<p>preventing with promises, <a href="#text_part0021.html_page_202"
class="calibre4">202</a></p>
<p>stateless, <a href="#text_part0022.html_page_228"
class="calibre4">228–232</a></p>
<p>tasks, <a href="#text_part0021.html_page_190"
class="calibre4">190</a></p>
<p>The Three Concurrency Goblins, <a href="#text_part0021.html_page_193"
class="calibre4">193–196</a></p>
<p><span class="literal1">conj</span> function, <a
href="#text_part0014.html_page_45" class="calibre4">45</a>, <a
href="#text_part0014.html_page_46" class="calibre4">46</a>, <a
href="#text_part0014.html_page_47" class="calibre4">47</a>, <a
href="#text_part0015.html_page_90" class="calibre4">90</a></p>
<p><span class="literal1">cons</span> function, <a
href="#text_part0015.html_page_74" class="calibre4">74–77</a></p>
<p><span class="literal1">contains?</span> function, <a
href="#text_part0014.html_page_47" class="calibre4">47</a></p>
<p>control flow, <a href="#text_part0014.html_page_37"
class="calibre4">37–40</a></p>
<p>Boolean expressions, <a href="#text_part0014.html_page_39"
class="calibre4">39–40</a></p>
<p><span class="literal1">do</span> operator, <a
href="#text_part0014.html_page_38" class="calibre4">38</a></p>
<p><span class="literal1">if</span> expression, <a
href="#text_part0014.html_page_37" class="calibre4">37–38</a></p>
<p><span class="literal1">when</span> operator, <a
href="#text_part0014.html_page_38" class="calibre4">38–39</a></p>
<p>core.async</p>
<p><span class="literal1">alts!</span>, <a
href="#text_part0023.html_page_235" class="calibre4">235</a>, <a
href="#text_part0023.html_page_242" class="calibre4">242</a></p>
<p><span class="literal1">alts!!</span>, <a
href="#text_part0023.html_page_235" class="calibre4">235</a>, <a
href="#text_part0023.html_page_241" class="calibre4">241–243</a></p>
<p>blocking, <a href="#text_part0023.html_page_237"
class="calibre4">237–238</a></p>
<p>buffering, <a href="#text_part0023.html_page_236"
class="calibre4">236–237</a></p>
<p>events, <a href="#text_part0023.html_page_233"
class="calibre4">233</a></p>
<p>hot dog vending machine example, <a
href="#text_part0023.html_page_239" class="calibre4">239–241</a></p>
<p>parking, <a href="#text_part0023.html_page_237"
class="calibre4">237–238</a></p>
<p>pipelines, <a href="#text_part0023.html_page_240"
class="calibre4">240</a>, <a href="#text_part0023.html_page_244"
class="calibre4">244–245</a></p>
<p>put, <a href="#text_part0023.html_page_235"
class="calibre4">235–238</a></p>
<p>queues, <a href="#text_part0023.html_page_243"
class="calibre4">243–244</a></p>
<p>take, <a href="#text_part0023.html_page_235"
class="calibre4">235–238</a></p>
<p>thread, <a href="#text_part0023.html_page_238"
class="calibre4">238–239</a></p>
<p>timeout channels, <a href="#text_part0023.html_page_235"
class="calibre4">235</a>, <a href="#text_part0023.html_page_242"
class="calibre4">242</a></p>
<p>waiting, <a href="#text_part0023.html_page_235"
class="calibre4">235–238</a></p>
<p><span class="literal1">create-ns</span>, <a
href="#text_part0017.html_page_129" class="calibre4">129</a></p>
<p>CSV (comma-separated values), <a href="#text_part0015.html_page_93"
class="calibre4">93</a></p>
<p>cuddle zombie, <a href="#text_part0022.html_page_208"
class="calibre4">208</a></p>
<h3 class="h2"><strong>D</strong></h3>
<p>data structures, <a href="#text_part0014.html_page_41"
class="calibre4">41–48</a></p>
<p>immutable, <a href="#text_part0014.html_page_42"
class="calibre4">42</a>, <a href="#text_part0016.html_page_100"
class="calibre4">100–105</a>, <a href="#text_part0022.html_page_210"
class="calibre4">210</a></p>
<p>keywords, <a href="#text_part0014.html_page_44"
class="calibre4">44–45</a></p>
<p>lists, <a href="#text_part0014.html_page_45"
class="calibre4">45–46</a></p>
<p>maps, <a href="#text_part0014.html_page_43"
class="calibre4">43–44</a></p>
<p>numbers, <a href="#text_part0014.html_page_42"
class="calibre4">42</a></p>
<p>sets, <a href="#text_part0014.html_page_46"
class="calibre4">46–47</a></p>
<p>simplicity, <a href="#text_part0014.html_page_48"
class="calibre4">48</a></p>
<p>strings, <a href="#text_part0014.html_page_42"
class="calibre4">42–43</a></p>
<p>vectors, <a href="#text_part0014.html_page_45"
class="calibre4">45</a></p>
<p>data types, <a href="#text_part0025.html_page_265"
class="calibre4">265–266</a></p>
<p>extending, <a href="#text_part0025.html_page_270"
class="calibre4">270</a></p>
<p>instances, <a href="#text_part0025.html_page_266"
class="calibre4">266</a></p>
<p><span class="literal1">def</span></p>
<p>naming values, <a href="#text_part0014.html_page_40"
class="calibre4">40–41</a></p>
<p>storing objects, <a href="#text_part0017.html_page_127"
class="calibre4">127–129</a></p>
<p><span class="literal1">defprotocol</span>, <a
href="#text_part0025.html_page_270" class="calibre4">270</a></p>
<p><span class="literal1">defrecord</span>, <a
href="#text_part0025.html_page_272" class="calibre4">272</a></p>
<p><span class="literal1">deftype</span>, <a
href="#text_part0025.html_page_275" class="calibre4">275</a></p>
<p>delays, <a href="#text_part0021.html_page_196"
class="calibre4">196</a>, <a href="#text_part0021.html_page_198"
class="calibre4">198–199</a></p>
<p><span id="text_part0029.html_page_295" class="calibre4"></span><span
class="literal1">deliver</span>, <a href="#text_part0021.html_page_200"
class="calibre4">200</a></p>
<p>dependencies, <a href="#text_part0026.html_page_277"
class="calibre4">277</a>, <a href="#text_part0026.html_page_278"
class="calibre4">278–279</a></p>
<p><span class="literal1">deref</span>, <a
href="#text_part0017.html_page_128" class="calibre4">128</a>, <a
href="#text_part0021.html_page_197" class="calibre4">197</a></p>
<p>reader macro, <a href="#text_part0018.html_page_155"
class="calibre4">155</a></p>
<p>timeout, <a href="#text_part0021.html_page_202"
class="calibre4">202</a></p>
<p>dereferencing</p>
<p>atoms, <a href="#text_part0022.html_page_212"
class="calibre4">212</a></p>
<p>delays, <a href="#text_part0021.html_page_198"
class="calibre4">198–199</a></p>
<p>futures, <a href="#text_part0021.html_page_191"
class="calibre4">191–198</a></p>
<p>promises, <a href="#text_part0021.html_page_200"
class="calibre4">200–202</a></p>
<p>destructuring, <a href="#text_part0014.html_page_54"
class="calibre4">54–56</a></p>
<p>dispatching function, <a href="#text_part0025.html_page_266"
class="calibre4">266</a>, <a href="#text_part0025.html_page_267"
class="calibre4">267–268</a></p>
<p>dispatching value, <a href="#text_part0025.html_page_266"
class="calibre4">266</a>, <a href="#text_part0025.html_page_267"
class="calibre4">267–268</a></p>
<p>dispatch value, <a href="#text_part0025.html_page_267"
class="calibre4">267–268</a></p>
<p>distributed computing, <a href="#text_part0021.html_page_191"
class="calibre4">191</a></p>
<p>domain-specific language (DSL), <a
href="#text_part0027.html_page_283" class="calibre4">283</a></p>
<p><span class="literal1">do</span> operator, <a
href="#text_part0014.html_page_38" class="calibre4">38</a></p>
<p><span class="literal1">dorun</span> function, <a
href="#text_part0022.html_page_229" class="calibre4">229</a></p>
<p><span class="literal1">doseq</span>, <a
href="#text_part0016.html_page_121" class="calibre4">121</a></p>
<p><span class="literal1">dosync</span>, <a
href="#text_part0022.html_page_219" class="calibre4">219–221</a></p>
<p><span class="literal1">doto</span> macro, <a
href="#text_part0024.html_page_260" class="calibre4">260</a></p>
<p>dot special form, <a href="#text_part0024.html_page_258"
class="calibre4">258</a></p>
<p>dot operator (<span class="literal1">.</span>), <a
href="#text_part0024.html_page_258" class="calibre4">258–259</a></p>
<p><span class="literal1">drop</span> function, <a
href="#text_part0015.html_page_81" class="calibre4">81</a></p>
<p><span class="literal1">drop-while</span> function, <a
href="#text_part0015.html_page_81" class="calibre4">81–82</a></p>
<p>DSL (domain-specific language), <a
href="#text_part0027.html_page_283" class="calibre4">283</a></p>
<p>Dungeons and Dragons, <a href="#text_part0025.html_page_265"
class="calibre4">265</a></p>
<p>dynamic binding, <a href="#text_part0022.html_page_223"
class="calibre4">223–227</a></p>
<h3 class="h2"><strong>E</strong></h3>
<p>Eastwood plug-in (lint tool), <a href="#text_part0026.html_page_279"
class="calibre4">279–280</a></p>
<p>editors, <a href="#text_part0011.html_page_9"
class="calibre4">9</a></p>
<p>El Chupacabra, <a href="#text_part0022.html_page_218"
class="calibre4">218</a></p>
<p>elisp, <a href="#text_part0012.html_page_11" class="calibre4">11</a>,
<a href="#text_part0012.html_page_17" class="calibre4">17</a>, <a
href="#text_part0012.html_page_19" class="calibre4">19</a>, <a
href="#text_part0015.html_page_72" class="calibre4">72</a></p>
<p>Emacs</p>
<p>buffers, <a href="#text_part0012.html_page_14"
class="calibre4">14–15</a></p>
<p>CIDER package, <a href="#text_part0012.html_page_23"
class="calibre4">23</a>. <em>See also</em> CIDER package</p>
<p>configuration, <a href="#text_part0012.html_page_13"
class="calibre4">13</a></p>
<p>cursor, <a href="#text_part0012.html_page_20"
class="calibre4">20</a></p>
<p>customizing, <a href="#text_part0012.html_page_15"
class="calibre4">15–16</a></p>
<p>files, <a href="#text_part0012.html_page_15"
class="calibre4">15–17</a></p>
<p>frames, <a href="#text_part0012.html_page_24"
class="calibre4">24</a></p>
<p>help, <a href="#text_part0012.html_page_22"
class="calibre4">22</a></p>
<p>installation, <a href="#text_part0012.html_page_12"
class="calibre4">12–14</a></p>
<p>key bindings, <a href="#text_part0012.html_page_17"
class="calibre4">17</a></p>
<p>killing, <a href="#text_part0012.html_page_21"
class="calibre4">21–22</a></p>
<p>kill ring, <a href="#text_part0012.html_page_21"
class="calibre4">21–22</a></p>
<p>Lisp (elisp), <a href="#text_part0012.html_page_11"
class="calibre4">11</a>, <a href="#text_part0012.html_page_19"
class="calibre4">19</a></p>
<p>mark, <a href="#text_part0012.html_page_20"
class="calibre4">20</a></p>
<p>minibuffer, <a href="#text_part0012.html_page_15"
class="calibre4">15</a></p>
<p>modes, <a href="#text_part0012.html_page_18"
class="calibre4">18–19</a></p>
<p>line, <a href="#text_part0012.html_page_18"
class="calibre4">18</a></p>
<p>major, <a href="#text_part0012.html_page_18"
class="calibre4">18</a></p>
<p>minor, <a href="#text_part0012.html_page_19"
class="calibre4">19</a></p>
<p>movement, <a href="#text_part0012.html_page_20"
class="calibre4">20</a></p>
<p>packages, <a href="#text_part0012.html_page_19"
class="calibre4">19</a></p>
<p>Paredit, <a href="#text_part0012.html_page_28"
class="calibre4">28–30</a>. <em>See also</em> Paredit</p>
<p>point, <a href="#text_part0012.html_page_20"
class="calibre4">20</a></p>
<p>regions, <a href="#text_part0012.html_page_20"
class="calibre4">20</a></p>
<p>windows, <a href="#text_part0012.html_page_24"
class="calibre4">24</a></p>
<p>yank, <a href="#text_part0012.html_page_21"
class="calibre4">21</a></p>
<p><span class="literal1">empty?</span> function, <a
href="#text_part0015.html_page_88" class="calibre4">88</a></p>
<p>equality operator (<span class="literal1">=</span>), <a
href="#text_part0014.html_page_39" class="calibre4">39</a></p>
<p><span class="literal1">eval</span>, <a
href="#text_part0018.html_page_151" class="calibre4">151</a></p>
<p>evaluation, <a href="#text_part0014.html_page_36"
class="calibre4">36</a></p>
<p>lists, <a href="#text_part0018.html_page_159"
class="calibre4">159–160</a></p>
<p>macros, <a href="#text_part0018.html_page_160"
class="calibre4">160–162</a></p>
<p>model, <a href="#text_part0018.html_page_148"
class="calibre4">148–152</a></p>
<p>rules, <a href="#text_part0018.html_page_155"
class="calibre4">155–162</a></p>
<p>to self, <a href="#text_part0018.html_page_156"
class="calibre4">156</a></p>
<p>symbols, <a href="#text_part0018.html_page_156"
class="calibre4">156</a></p>
<p>evaluator, <a href="#text_part0018.html_page_148"
class="calibre4">148</a>, <a href="#text_part0018.html_page_149"
class="calibre4">149–152</a>, <a href="#text_part0018.html_page_155"
class="calibre4">155</a></p>
<p>expression, <a href="#text_part0014.html_page_36"
class="calibre4">36</a></p>
<p>Boolean, <a href="#text_part0014.html_page_39"
class="calibre4">39–40</a></p>
<p>function, <a href="#text_part0016.html_page_98"
class="calibre4">98</a></p>
<p><span class="literal1">if</span>, <a
href="#text_part0014.html_page_37" class="calibre4">37–38</a></p>
<p><span class="literal1">extend-protocol</span>, <a
href="#text_part0025.html_page_271" class="calibre4">271</a>, <a
href="#text_part0025.html_page_274" class="calibre4">274</a></p>
<p><span class="literal1">extend-type</span>, <a
href="#text_part0025.html_page_270" class="calibre4">270</a>, <a
href="#text_part0025.html_page_274" class="calibre4">274</a></p>
<h3 class="h2"><strong>F</strong></h3>
<p><span class="literal1">false</span> (value), <a
href="#text_part0014.html_page_39" class="calibre4">39</a></p>
<p>falsey values, <a href="#text_part0014.html_page_39"
class="calibre4">39</a></p>
<p>fields, <a href="#text_part0025.html_page_272"
class="calibre4">272</a></p>
<p>file naming conventions, <a href="#text_part0017.html_page_134"
class="calibre4">134</a></p>
<p><span class="literal1">filter</span> function, <a
href="#text_part0015.html_page_83" class="calibre4">83</a></p>
<p><span class="literal1">first</span> function, <a
href="#text_part0015.html_page_74" class="calibre4">74</a></p>
<p><span class="literal1">force</span>, <a
href="#text_part0021.html_page_198" class="calibre4">198</a></p>
<p>forms, <a href="#text_part0014.html_page_36"
class="calibre4">36–37</a></p>
<p>fully qualified symbols, <a href="#text_part0019.html_page_171"
class="calibre4">171</a></p>
<p><span id="text_part0029.html_page_296"
class="calibre4"></span>functional programming, <a
href="#text_part0015.html_page_79" class="calibre4">79</a>, <a
href="#text_part0016.html_page_97" class="calibre4">97</a></p>
<p>immutable data structures, <a href="#text_part0016.html_page_100"
class="calibre4">100–105</a></p>
<p>Peg Thing game, <a href="#text_part0016.html_page_108"
class="calibre4">108–124</a></p>
<p>pure functions, <a href="#text_part0016.html_page_98"
class="calibre4">98–100</a></p>
<p>functions, <a href="#text_part0014.html_page_48"
class="calibre4">48–59</a></p>
<p>anonymous, <a href="#text_part0014.html_page_57"
class="calibre4">57–58</a></p>
<p>arity, <a href="#text_part0014.html_page_52"
class="calibre4">52–54</a></p>
<p>overloading, <a href="#text_part0014.html_page_52"
class="calibre4">52–53</a></p>
<p>calls, <a href="#text_part0014.html_page_48"
class="calibre4">48–51</a>, <a href="#text_part0018.html_page_159"
class="calibre4">159</a></p>
<p>composition, <a href="#text_part0016.html_page_103"
class="calibre4">103–105</a>, <a href="#text_part0027.html_page_285"
class="calibre4">285</a></p>
<p>defining, <a href="#text_part0014.html_page_51"
class="calibre4">51–52</a></p>
<p>expression, <a href="#text_part0014.html_page_48"
class="calibre4">48</a></p>
<p>higher-order, <a href="#text_part0014.html_page_49"
class="calibre4">49</a></p>
<p>pure, <a href="#text_part0016.html_page_98"
class="calibre4">98–100</a>, <a href="#text_part0016.html_page_105"
class="calibre4">105–107</a></p>
<p>rest parameters, <a href="#text_part0014.html_page_54"
class="calibre4">54</a></p>
<p>futures, <a href="#text_part0021.html_page_196"
class="calibre4">196–198</a>, <a href="#text_part0021.html_page_202"
class="calibre4">202–205</a></p>
<h3 class="h2"><strong>G</strong></h3>
<p>gensym, <a href="#text_part0019.html_page_177"
class="calibre4">177–178</a></p>
<p><span class="literal1">get</span> function, <a
href="#text_part0014.html_page_43" class="calibre4">43–44</a>, <a
href="#text_part0014.html_page_45" class="calibre4">45</a>, <a
href="#text_part0014.html_page_47" class="calibre4">47</a></p>
<p><span class="literal1">get-in</span> function, <a
href="#text_part0014.html_page_44" class="calibre4">44</a></p>
<p>go blocks, <a href="#text_part0023.html_page_235"
class="calibre4">235–239</a></p>
<p>grain size, <a href="#text_part0022.html_page_230"
class="calibre4">230</a></p>
<h3 class="h2"><strong>H</strong></h3>
<p>Handy, Jack, <a href="#text_part0012.html_page_19"
class="calibre4">19</a></p>
<p><span class="literal1">hash-map</span> function, <a
href="#text_part0014.html_page_43" class="calibre4">43</a></p>
<p><span class="literal1">hash-set</span>, <a
href="#text_part0014.html_page_46" class="calibre4">46</a></p>
<p>head (of a sequence), <a href="#text_part0014.html_page_65"
class="calibre4">65</a></p>
<p>Hickey, Rich, <a href="#text_part0011.html_page_4"
class="calibre4">4</a></p>
<p>hierarchical dispatching, <a href="#text_part0025.html_page_269"
class="calibre4">269</a></p>
<p>hobbits</p>
<p>modeling, <a href="#text_part0014.html_page_59"
class="calibre4">59–61</a></p>
<p>targeting, <a href="#text_part0014.html_page_67"
class="calibre4">67–68</a></p>
<p>homoiconic languages, <a href="#text_part0018.html_page_148"
class="calibre4">148</a>, <a href="#text_part0018.html_page_152"
class="calibre4">152</a></p>
<p>hot dog vending machine, <a href="#text_part0023.html_page_239"
class="calibre4">239–243</a></p>
<p>humans, <a href="#text_part0025.html_page_265"
class="calibre4">265</a></p>
<h3 class="h2"><strong>I</strong></h3>
<p>identity (Clojure metaphysics), <a
href="#text_part0022.html_page_211" class="calibre4">211</a></p>
<p><span class="literal1">identity</span> function, <a
href="#text_part0015.html_page_95" class="calibre4">95</a></p>
<p><span class="literal1">if</span> expressions, <a
href="#text_part0014.html_page_37" class="calibre4">37–38</a></p>
<p><span class="literal1">if-let</span>, <a
href="#text_part0016.html_page_119" class="calibre4">119</a></p>
<p>immutable data structures, <a href="#text_part0016.html_page_100"
class="calibre4">100–105</a>, <a href="#text_part0022.html_page_210"
class="calibre4">210</a>, <a href="#text_part0022.html_page_212"
class="calibre4">212</a></p>
<p>implementing abstractions, <a href="#text_part0015.html_page_74"
class="calibre4">74</a></p>
<p>importing</p>
<p>Java classes, <a href="#text_part0024.html_page_253"
class="calibre4">253–254</a></p>
<p>record types, <a href="#text_part0025.html_page_273"
class="calibre4">273</a></p>
<p><span class="literal1">in-ns</span> function, <a
href="#text_part0017.html_page_129" class="calibre4">129</a></p>
<p>installation</p>
<p>Emacs, <a href="#text_part0012.html_page_12"
class="calibre4">12–14</a></p>
<p>CIDER package, <a href="#text_part0012.html_page_23"
class="calibre4">23</a></p>
<p>packages, <a href="#text_part0012.html_page_19"
class="calibre4">19</a></p>
<p>Leiningen, <a href="#text_part0011.html_page_5"
class="calibre4">5</a></p>
<p>instance, of a data type, <a href="#text_part0025.html_page_266"
class="calibre4">266</a></p>
<p>interfaces, <a href="#text_part0015.html_page_77"
class="calibre4">77</a></p>
<p>interleaving, <a href="#text_part0021.html_page_190"
class="calibre4">190</a>, <a href="#text_part0021.html_page_192"
class="calibre4">192–193</a></p>
<p>interning, <a href="#text_part0017.html_page_128"
class="calibre4">128</a></p>
<p><span class="literal1">into</span> function, <a
href="#text_part0015.html_page_88" class="calibre4">88–89</a></p>
<h3 class="h2"><strong>J</strong></h3>
<p>JAR files, <a href="#text_part0011.html_page_4"
class="calibre4">4</a>, <a href="#text_part0024.html_page_249"
class="calibre4">249</a>, <a href="#text_part0024.html_page_255"
class="calibre4">255</a></p>
<p>Java</p>
<p>bytecode, <a href="#text_part0011.html_page_4"
class="calibre4">4</a>, <a href="#text_part0024.html_page_248"
class="calibre4">248–249</a>, <a href="#text_part0024.html_page_252"
class="calibre4">252</a></p>
<p>classes, <a href="#text_part0025.html_page_273"
class="calibre4">273</a></p>
<p>classpath, <a href="#text_part0024.html_page_252"
class="calibre4">252</a>, <a href="#text_part0024.html_page_254"
class="calibre4">254–255</a></p>
<p>entry point, <a href="#text_part0024.html_page_255"
class="calibre4">255</a></p>
<p>imports, <a href="#text_part0024.html_page_253"
class="calibre4">253–255</a></p>
<p>interop. <em>See</em> Java interop</p>
<p>JAR files, <a href="#text_part0011.html_page_4"
class="calibre4">4</a>, <a href="#text_part0024.html_page_249"
class="calibre4">249</a>, <a href="#text_part0024.html_page_255"
class="calibre4">255</a></p>
<p><span class="literal1">main</span> method, <a
href="#text_part0024.html_page_252" class="calibre4">252</a>, <a
href="#text_part0024.html_page_255" class="calibre4">255</a>, <a
href="#text_part0024.html_page_257" class="calibre4">257</a></p>
<p>packages, <a href="#text_part0024.html_page_253"
class="calibre4">253–255</a></p>
<p>stacks, <a href="#text_part0024.html_page_259"
class="calibre4">259–260</a></p>
<p><span class="literal1">javac</span>, <a
href="#text_part0024.html_page_252" class="calibre4">252</a></p>
<p>Java interop, <a href="#text_part0024.html_page_250"
class="calibre4">250</a>, <a href="#text_part0024.html_page_257"
class="calibre4">257–261</a></p>
<p>creating objects, <a href="#text_part0024.html_page_259"
class="calibre4">259–260</a></p>
<p><span class="literal1">Date</span> class, <a
href="#text_part0024.html_page_262" class="calibre4">262</a></p>
<p>files, <a href="#text_part0024.html_page_262"
class="calibre4">262–264</a></p>
<p>importing, <a href="#text_part0024.html_page_260"
class="calibre4">260–261</a></p>
<p>input/output, <a href="#text_part0024.html_page_262"
class="calibre4">262–264</a></p>
<p>method calls, <a href="#text_part0024.html_page_258"
class="calibre4">258</a></p>
<p>mutating objects, <a href="#text_part0024.html_page_259"
class="calibre4">259–260</a></p>
<p>passing arguments, <a href="#text_part0024.html_page_258"
class="calibre4">258</a></p>
<p>syntax, <a href="#text_part0024.html_page_258"
class="calibre4">258–259</a></p>
<p><span class="literal1">System</span> class, <a
href="#text_part0024.html_page_261" class="calibre4">261–262</a></p>
<p>Java Virtual Machine (JVM), <a href="#text_part0011.html_page_4"
class="calibre4">4</a>, <a href="#text_part0018.html_page_150"
class="calibre4">150</a>, <a href="#text_part0024.html_page_248"
class="calibre4">248–249</a></p>
<p>threads, <a href="#text_part0021.html_page_191"
class="calibre4">191–193</a></p>
<p>just-in-time compilation, <a href="#text_part0024.html_page_248"
class="calibre4">248</a></p>
<h3 class="h2"><span id="text_part0029.html_page_297"
class="calibre1"></span><strong>K</strong></h3>
<p>key functions, <a href="#text_part0015.html_page_84"
class="calibre4">84</a></p>
<p>keywords, <a href="#text_part0014.html_page_44"
class="calibre4">44–45</a></p>
<h3 class="h2"><strong>L</strong></h3>
<p>Lady Gaga, <a href="#text_part0021.html_page_190"
class="calibre4">190–191</a></p>
<p>lazy sequences, <a href="#text_part0015.html_page_84"
class="calibre4">84–88</a>, <a href="#text_part0016.html_page_112"
class="calibre4">112</a></p>
<p>chunking, <a href="#text_part0015.html_page_86"
class="calibre4">86</a></p>
<p>defining, <a href="#text_part0015.html_page_87"
class="calibre4">87</a></p>
<p>efficiency, <a href="#text_part0015.html_page_84"
class="calibre4">84–87</a></p>
<p>infinite, <a href="#text_part0015.html_page_87"
class="calibre4">87–88</a></p>
<p>realizing, <a href="#text_part0015.html_page_84"
class="calibre4">84</a></p>
<p><span class="literal1">repeatedly</span> function, <a
href="#text_part0015.html_page_87" class="calibre4">87</a></p>
<p><span class="literal1">repeat</span> function, <a
href="#text_part0015.html_page_87" class="calibre4">87</a></p>
<p>Leiningen build tool, <a href="#text_part0011.html_page_5"
class="calibre4">5–8</a>, <a href="#text_part0026.html_page_277"
class="calibre4">277–280</a></p>
<p>dependencies, <a href="#text_part0026.html_page_278"
class="calibre4">278–279</a></p>
<p>identification, <a href="#text_part0026.html_page_278"
class="calibre4">278</a></p>
<p>plug-ins, <a href="#text_part0026.html_page_279"
class="calibre4">279–280</a></p>
<p><span class="literal1">let</span>, <a
href="#text_part0014.html_page_61" class="calibre4">61–63</a></p>
<p><span class="literal1">line-seq</span> function, <a
href="#text_part0024.html_page_264" class="calibre4">264</a></p>
<p>linked list, <a href="#text_part0015.html_page_74"
class="calibre4">74–76</a></p>
<p>lint tool (Eastwood plug-in), <a href="#text_part0026.html_page_279"
class="calibre4">279–280</a></p>
<p>Lisp, <a href="#text_part0011.html_page_4" class="calibre4">4</a>, <a
href="#text_part0012.html_page_11" class="calibre4">11</a>, <a
href="#text_part0014.html_page_36" class="calibre4">36</a>, <a
href="#text_part0018.html_page_150" class="calibre4">150</a></p>
<p><span class="literal1">list</span> function, <a
href="#text_part0014.html_page_46" class="calibre4">46</a></p>
<p>lists, <a href="#text_part0014.html_page_45"
class="calibre4">45–46</a></p>
<p>evaluation rules for, <a href="#text_part0018.html_page_159"
class="calibre4">159–160</a></p>
<p>literals, <a href="#text_part0014.html_page_36"
class="calibre4">36</a></p>
<p>local binding, <a href="#text_part0018.html_page_157"
class="calibre4">157–158</a></p>
<p><span class="literal1">loop</span>, <a
href="#text_part0014.html_page_63" class="calibre4">63–64</a></p>
<h3 class="h2"><strong>M</strong></h3>
<p><span class="literal1">macroexpand</span>, <a
href="#text_part0018.html_page_162" class="calibre4">162</a></p>
<p>macros, <a href="#text_part0018.html_page_147"
class="calibre4">147–185</a></p>
<p>argument destructuring, <a href="#text_part0019.html_page_167"
class="calibre4">167–168</a></p>
<p>Brave and True Ale example, <a href="#text_part0019.html_page_180"
class="calibre4">180–184</a></p>
<p>building lists for evaluation, <a href="#text_part0019.html_page_168"
class="calibre4">168–173</a></p>
<p>calling, <a href="#text_part0014.html_page_50"
class="calibre4">50–51</a></p>
<p>characters, <a href="#text_part0018.html_page_154"
class="calibre4">154</a></p>
<p>defining, <a href="#text_part0019.html_page_167"
class="calibre4">167</a></p>
<p>distinguishing symbols and values, <a
href="#text_part0019.html_page_168" class="calibre4">168–169</a></p>
<p>evaluation rules for, <a href="#text_part0018.html_page_160"
class="calibre4">160–162</a></p>
<p>expansion, <a href="#text_part0018.html_page_162"
class="calibre4">162</a></p>
<p>gotchas, <a href="#text_part0019.html_page_176"
class="calibre4">176–180</a></p>
<p>composition, <a href="#text_part0019.html_page_179"
class="calibre4">179–180</a></p>
<p>double evaluation, <a href="#text_part0019.html_page_178"
class="calibre4">178</a></p>
<p>variable capture, <a href="#text_part0019.html_page_176"
class="calibre4">176–178</a></p>
<p>infection, <a href="#text_part0019.html_page_166"
class="calibre4">166</a></p>
<p><span class="literal1">map</span> function, <a
href="#text_part0014.html_page_50" class="calibre4">50</a>, <a
href="#text_part0015.html_page_73" class="calibre4">73</a>, <a
href="#text_part0015.html_page_79" class="calibre4">79–80</a></p>
<p>maps (data structure), <a href="#text_part0014.html_page_43"
class="calibre4">43–44</a></p>
<p>destructuring, <a href="#text_part0014.html_page_55"
class="calibre4">55</a></p>
<p>Maven, <a href="#text_part0026.html_page_278"
class="calibre4">278</a>, <a href="#text_part0026.html_page_279"
class="calibre4">279</a></p>
<p>McCarthy, John, <a href="#text_part0018.html_page_148"
class="calibre4">148</a></p>
<p>McFishwich, <a href="#text_part0015.html_page_85"
class="calibre4">85</a></p>
<p><span class="literal1">memoize</span> function, <a
href="#text_part0016.html_page_107" class="calibre4">107</a></p>
<p>metaphysics, Clojure, <a href="#text_part0022.html_page_210"
class="calibre4">210–211</a></p>
<p>multimethods, <a href="#text_part0025.html_page_266"
class="calibre4">266–269</a></p>
<p>default, <a href="#text_part0025.html_page_268"
class="calibre4">268</a></p>
<h3 class="h2"><strong>N</strong></h3>
<p>names</p>
<p>in Clojure metaphysics, <a href="#text_part0022.html_page_211"
class="calibre4">211</a></p>
<p>collision, <a href="#text_part0017.html_page_128"
class="calibre4">128–129</a></p>
<p>for values, <a href="#text_part0014.html_page_40"
class="calibre4">40–41</a></p>
<p>namespaces, <a href="#text_part0017.html_page_126"
class="calibre4">126</a></p>
<p>aliasing, <a href="#text_part0017.html_page_136"
class="calibre4">136</a></p>
<p><span class="literal1">create-ns</span>, <a
href="#text_part0017.html_page_129" class="calibre4">129</a></p>
<p>creating and switching to, <a href="#text_part0017.html_page_129"
class="calibre4">129–130</a></p>
<p>current, <a href="#text_part0017.html_page_126"
class="calibre4">126</a></p>
<p><span class="literal1">in-ns</span>, <a
href="#text_part0017.html_page_129" class="calibre4">129</a></p>
<p><span class="literal1">ns</span> macro, <a
href="#text_part0017.html_page_126" class="calibre4">126</a>, <a
href="#text_part0017.html_page_129" class="calibre4">129</a>, <a
href="#text_part0017.html_page_138" class="calibre4">138–140</a></p>
<p><span class="literal1">ns-interns</span>, <a
href="#text_part0017.html_page_128" class="calibre4">128</a></p>
<p><span class="literal1">ns-map</span>, <a
href="#text_part0017.html_page_128" class="calibre4">128</a></p>
<p><span class="literal1">refer-clojure</span>, <a
href="#text_part0017.html_page_138" class="calibre4">138</a></p>
<p>reference, <a href="#text_part0017.html_page_138"
class="calibre4">138</a></p>
<p>refering, <a href="#text_part0017.html_page_130"
class="calibre4">130–132</a>, <a href="#text_part0017.html_page_135"
class="calibre4">135</a></p>
<p>requiring, <a href="#text_part0017.html_page_134"
class="calibre4">134–137</a></p>
<p><span class="literal1">user</span>, <a
href="#text_part0017.html_page_126" class="calibre4">126</a></p>
<p>using, <a href="#text_part0017.html_page_136"
class="calibre4">136–137</a></p>
<p><span class="literal1">nil</span> (value), <a
href="#text_part0014.html_page_39" class="calibre4">39</a>, <a
href="#text_part0014.html_page_47" class="calibre4">47</a></p>
<p>nondeterministic execution, <a href="#text_part0021.html_page_193"
class="calibre4">193</a></p>
<p><span class="literal1">not-empty</span>, <a
href="#text_part0016.html_page_120" class="calibre4">120</a></p>
<p><span class="literal1">ns</span> macro, <a
href="#text_part0017.html_page_126" class="calibre4">126</a>, <a
href="#text_part0017.html_page_129" class="calibre4">129</a>, <a
href="#text_part0017.html_page_138" class="calibre4">138–140</a></p>
<p><span class="literal1">ns-interns</span>, <a
href="#text_part0017.html_page_128" class="calibre4">128</a></p>
<p><span class="literal1">ns-map</span>, <a
href="#text_part0017.html_page_128" class="calibre4">128</a></p>
<p><span class="literal1">nth</span> function, <a
href="#text_part0014.html_page_46" class="calibre4">46</a></p>
<p>numbers, <a href="#text_part0014.html_page_42"
class="calibre4">42</a></p>
<h3 class="h2"><span id="text_part0029.html_page_298"
class="calibre1"></span><strong>O</strong></h3>
<p>object-oriented metaphysics, <a href="#text_part0022.html_page_208"
class="calibre4">208–210</a></p>
<p>object-oriented programming, <a href="#text_part0016.html_page_104"
class="calibre4">104</a>, <a href="#text_part0024.html_page_250"
class="calibre4">250–251</a></p>
<p>classes, <a href="#text_part0024.html_page_251"
class="calibre4">251</a></p>
<p>methods, <a href="#text_part0024.html_page_251"
class="calibre4">251</a></p>
<p>objects, <a href="#text_part0024.html_page_250"
class="calibre4">250–251</a></p>
<p>operators, <a href="#text_part0014.html_page_36"
class="calibre4">36</a></p>
<p>addition (<span class="literal1">+</span>), <a
href="#text_part0014.html_page_36" class="calibre4">36–37</a></p>
<p>Boolean</p>
<p><span class="literal1">and</span>, <a
href="#text_part0014.html_page_40" class="calibre4">40</a></p>
<p><span class="literal1">or</span>, <a
href="#text_part0014.html_page_40" class="calibre4">40</a></p>
<p><span class="literal1">do</span>, <a
href="#text_part0014.html_page_38" class="calibre4">38</a></p>
<p>dot (<span class="literal1">.</span>), <a
href="#text_part0024.html_page_258" class="calibre4">258–259</a></p>
<p>equality (<span class="literal1">=</span>), <a
href="#text_part0014.html_page_39" class="calibre4">39</a></p>
<p><span class="literal1">when</span>, <a
href="#text_part0014.html_page_38" class="calibre4">38–39</a></p>
<p><span class="literal1">or</span> (Boolean operator), <a
href="#text_part0014.html_page_40" class="calibre4">40</a></p>
<h3 class="h2"><strong>P</strong></h3>
<p>parallelism, <a href="#text_part0021.html_page_190"
class="calibre4">190–196</a>. <em>See also</em> concurrency</p>
<p>Paredit, <a href="#text_part0012.html_page_28"
class="calibre4">28</a></p>
<p>barfing, <a href="#text_part0012.html_page_29"
class="calibre4">29–30</a></p>
<p>navigation, <a href="#text_part0012.html_page_30"
class="calibre4">30</a></p>
<p>slurping, <a href="#text_part0012.html_page_29"
class="calibre4">29</a></p>
<p>wrapping, <a href="#text_part0012.html_page_29"
class="calibre4">29</a></p>
<p><span class="literal1">partial</span> function, <a
href="#text_part0015.html_page_91" class="calibre4">91–92</a>, <a
href="#text_part0016.html_page_120" class="calibre4">120</a></p>
<p>Peg Thing game, <a href="#text_part0016.html_page_108"
class="calibre4">108–124</a></p>
<p>Perlis, Alan, <a href="#text_part0014.html_page_48"
class="calibre4">48</a></p>
<p>philosophy (of Clojure), <a href="#text_part0014.html_page_48"
class="calibre4">48</a></p>
<p>plug-ins, <a href="#text_part0026.html_page_279"
class="calibre4">279–280</a></p>
<p><span class="literal1">pmap</span>, <a
href="#text_part0022.html_page_228" class="calibre4">228–232</a></p>
<p>polymorphism, <a href="#text_part0015.html_page_77"
class="calibre4">77</a>, <a href="#text_part0025.html_page_266"
class="calibre4">266</a></p>
<p>multimethods, <a href="#text_part0025.html_page_266"
class="calibre4">266–269</a></p>
<p>protocols, <a href="#text_part0015.html_page_77"
class="calibre4">77</a>, <a href="#text_part0025.html_page_269"
class="calibre4">269–272</a></p>
<p>predicate functions, <a href="#text_part0015.html_page_81"
class="calibre4">81–82</a>, <a href="#text_part0016.html_page_119"
class="calibre4">119–120</a></p>
<p>processes, <a href="#text_part0023.html_page_234"
class="calibre4">234–239</a></p>
<p>blocking, <a href="#text_part0023.html_page_237"
class="calibre4">237–238</a></p>
<p>buffering, <a href="#text_part0023.html_page_236"
class="calibre4">236–237</a></p>
<p>parking, <a href="#text_part0023.html_page_237"
class="calibre4">237–238</a></p>
<p><span class="literal1">thread</span>, <a
href="#text_part0023.html_page_238" class="calibre4">238–239</a></p>
<p>programming to abstractions, <a href="#text_part0015.html_page_72"
class="calibre4">72</a></p>
<p>indirection, <a href="#text_part0015.html_page_77"
class="calibre4">77–78</a></p>
<p>linked lists, <a href="#text_part0015.html_page_74"
class="calibre4">74–77</a></p>
<p>sequences abstraction, <a href="#text_part0015.html_page_72"
class="calibre4">72–74</a></p>
<p>projects</p>
<p>building, <a href="#text_part0011.html_page_7"
class="calibre4">7</a></p>
<p>creating, <a href="#text_part0011.html_page_5"
class="calibre4">5–6</a></p>
<p>organizing, <a href="#text_part0017.html_page_133"
class="calibre4">133–140</a></p>
<p>running, <a href="#text_part0011.html_page_6"
class="calibre4">6</a></p>
<p>promises, <a href="#text_part0021.html_page_196"
class="calibre4">196</a>, <a href="#text_part0021.html_page_200"
class="calibre4">200–205</a></p>
<p>protocols, <a href="#text_part0015.html_page_77"
class="calibre4">77</a>, <a href="#text_part0025.html_page_269"
class="calibre4">269–272</a></p>
<p><span class="literal1">proxy</span>, <a
href="#text_part0025.html_page_275" class="calibre4">275</a></p>
<p>pure functions, <a href="#text_part0016.html_page_98"
class="calibre4">98–100</a>, <a href="#text_part0016.html_page_117"
class="calibre4">117</a></p>
<h3 class="h2"><strong>Q</strong></h3>
<p>queues</p>
<p>macro, <a href="#text_part0021.html_page_202"
class="calibre4">202–205</a></p>
<p>processes, <a href="#text_part0023.html_page_243"
class="calibre4">243–244</a></p>
<p><span class="literal1">quote</span>, <a
href="#text_part0018.html_page_160" class="calibre4">160</a></p>
<p>quote (<span class="literal1">'</span>) reader macro, <a
href="#text_part0018.html_page_154" class="calibre4">154–155</a></p>
<p>quoting, <a href="#text_part0017.html_page_127"
class="calibre4">127</a>, <a href="#text_part0019.html_page_169"
class="calibre4">169</a></p>
<p>simple, <a href="#text_part0019.html_page_169"
class="calibre4">169–171</a></p>
<p>syntax, <a href="#text_part0019.html_page_171"
class="calibre4">171–174</a></p>
<p>unquote splicing, <a href="#text_part0019.html_page_174"
class="calibre4">174–176</a></p>
<p>unquoting, <a href="#text_part0019.html_page_172"
class="calibre4">172</a>, <a href="#text_part0019.html_page_175"
class="calibre4">175</a></p>
<p>with <span class="literal1">when</span>, <a
href="#text_part0019.html_page_170" class="calibre4">170</a></p>
<h3 class="h2"><strong>R</strong></h3>
<p>reader, <a href="#text_part0018.html_page_148"
class="calibre4">148</a>, <a href="#text_part0018.html_page_150"
class="calibre4">150</a>, <a href="#text_part0018.html_page_153"
class="calibre4">153–155</a>, <a href="#text_part0024.html_page_264"
class="calibre4">264</a></p>
<p>form, <a href="#text_part0017.html_page_128"
class="calibre4">128</a>, <a href="#text_part0018.html_page_153"
class="calibre4">153</a></p>
<p>macros, <a href="#text_part0014.html_page_57"
class="calibre4">57</a>, <a href="#text_part0018.html_page_153"
class="calibre4">153</a>, <a href="#text_part0018.html_page_154"
class="calibre4">154–155</a></p>
<p><span class="literal1">read-string</span> function, <a
href="#text_part0018.html_page_153" class="calibre4">153–154</a></p>
<p><span class="literal1">realized?</span>, <a
href="#text_part0021.html_page_198" class="calibre4">198</a></p>
<p>records, <a href="#text_part0025.html_page_272"
class="calibre4">272–274</a></p>
<p><span class="literal1">recur</span>, <a
href="#text_part0016.html_page_102" class="calibre4">102–103</a></p>
<p>recursion, <a href="#text_part0016.html_page_100"
class="calibre4">100–103</a></p>
<p><span class="literal1">reduce</span> function, <a
href="#text_part0014.html_page_66" class="calibre4">66–67</a>, <a
href="#text_part0015.html_page_80" class="calibre4">80–81</a>, <a
href="#text_part0016.html_page_114" class="calibre4">114</a></p>
<p>reducers library, <a href="#text_part0022.html_page_231"
class="calibre4">231–232</a></p>
<p><span class="literal1">refer</span>, <a
href="#text_part0017.html_page_130" class="calibre4">130–132</a></p>
<p>reference types, <a href="#text_part0022.html_page_211"
class="calibre4">211</a></p>
<p>atoms, <a href="#text_part0022.html_page_212"
class="calibre4">212–215</a></p>
<p>referential transparency, <a href="#text_part0016.html_page_98"
class="calibre4">98–99</a></p>
<p>refs, <a href="#text_part0022.html_page_218"
class="calibre4">218–223</a></p>
<p>regular expressions, <a href="#text_part0014.html_page_64"
class="calibre4">64</a></p>
<p><span class="literal1">reify</span>, <a
href="#text_part0025.html_page_275" class="calibre4">275</a></p>
<p><span class="literal1">repeatedly</span> function, <a
href="#text_part0015.html_page_87" class="calibre4">87</a>, <a
href="#text_part0022.html_page_228" class="calibre4">228</a></p>
<p><span class="literal1">repeat</span> function, <a
href="#text_part0015.html_page_87" class="calibre4">87</a></p>
<p>REPL, <a href="#text_part0011.html_page_7" class="calibre4">7–9</a>,
<a href="#text_part0012.html_page_23" class="calibre4">23–24</a></p>
<p>Boot, <a href="#text_part0027.html_page_284"
class="calibre4">284</a></p>
<p>repositories, <a href="#text_part0026.html_page_278"
class="calibre4">278</a></p>
<p><span id="text_part0029.html_page_299" class="calibre4"></span><span
class="literal1">require</span>, <a href="#text_part0016.html_page_111"
class="calibre4">111</a>, <a href="#text_part0017.html_page_134"
class="calibre4">134–137</a></p>
<p><span class="literal1">rest</span> function, <a
href="#text_part0015.html_page_74" class="calibre4">74–77</a></p>
<h3 class="h2"><strong>S</strong></h3>
<p>scope, <a href="#text_part0014.html_page_61"
class="calibre4">61</a></p>
<p>Semantic Versioning system, <a href="#text_part0026.html_page_278"
class="calibre4">278</a></p>
<p>sequence (seq), <a href="#text_part0015.html_page_73"
class="calibre4">73–74</a></p>
<p>abstraction, <a href="#text_part0015.html_page_72"
class="calibre4">72–77</a></p>
<p>function examples, <a href="#text_part0015.html_page_79"
class="calibre4">79–84</a></p>
<p>lazy, <a href="#text_part0015.html_page_84"
class="calibre4">84–88</a></p>
<p>sets, <a href="#text_part0014.html_page_46"
class="calibre4">46–47</a></p>
<p>s-expressions, <a href="#text_part0018.html_page_150"
class="calibre4">150</a></p>
<p>side effects, of functions, <a href="#text_part0016.html_page_98"
class="calibre4">98</a>, <a href="#text_part0016.html_page_99"
class="calibre4">99–100</a></p>
<p>Simmons, Richard, <a href="#text_part0019.html_page_165"
class="calibre4">165</a></p>
<p>were-Simmons, <a href="#text_part0025.html_page_267"
class="calibre4">267</a></p>
<p>simplicity, of data structures, <a href="#text_part0014.html_page_48"
class="calibre4">48</a></p>
<p><span class="literal1">slurp</span> function, <a
href="#text_part0012.html_page_29" class="calibre4">29</a>, <a
href="#text_part0015.html_page_94" class="calibre4">94</a>, <a
href="#text_part0024.html_page_263" class="calibre4">263</a></p>
<p>sock gnomes, <a href="#text_part0022.html_page_218"
class="calibre4">218–220</a></p>
<p>software transactional memory (STM), <a
href="#text_part0022.html_page_218" class="calibre4">218</a></p>
<p><span class="literal1">some</span> function, <a
href="#text_part0015.html_page_83" class="calibre4">83</a></p>
<p><span class="literal1">sort-by</span> function, <a
href="#text_part0015.html_page_84" class="calibre4">84</a></p>
<p><span class="literal1">sort</span> function, <a
href="#text_part0015.html_page_84" class="calibre4">84</a></p>
<p>special forms, <a href="#text_part0014.html_page_50"
class="calibre4">50–51</a>, <a href="#text_part0018.html_page_156"
class="calibre4">156</a>, <a href="#text_part0018.html_page_159"
class="calibre4">159–160</a></p>
<p><span class="literal1">spit</span> function, <a
href="#text_part0017.html_page_144" class="calibre4">144</a>, <a
href="#text_part0024.html_page_263" class="calibre4">263</a></p>
<p>Stallman, Richard, <a href="#text_part0012.html_page_13"
class="calibre4">13</a></p>
<p>state, <a href="#text_part0022.html_page_207"
class="calibre4">207</a>, <a href="#text_part0022.html_page_211"
class="calibre4">211</a>, <a href="#text_part0022.html_page_212"
class="calibre4">212</a></p>
<p>mutable, <a href="#text_part0022.html_page_208"
class="calibre4">208–210</a></p>
<p>STM (software transactional memory), <a
href="#text_part0022.html_page_218" class="calibre4">218</a></p>
<p>strings, <a href="#text_part0014.html_page_42"
class="calibre4">42–43</a></p>
<p>concatenating, <a href="#text_part0014.html_page_43"
class="calibre4">43</a></p>
<p>pattern matching, <a href="#text_part0014.html_page_64"
class="calibre4">64</a></p>
<p>SVG, <a href="#text_part0017.html_page_140"
class="calibre4">140</a></p>
<p><span class="literal1">swap!</span>, <a
href="#text_part0022.html_page_212" class="calibre4">212–215</a></p>
<p>Swift, Taylor, <a href="#text_part0011.html_page_9"
class="calibre4">9</a></p>
<p>symbols, <a href="#text_part0017.html_page_126"
class="calibre4">126</a>, <a href="#text_part0018.html_page_156"
class="calibre4">156–158</a></p>
<p>fully qualified, <a href="#text_part0017.html_page_129"
class="calibre4">129–130</a></p>
<p>resolving, <a href="#text_part0018.html_page_156"
class="calibre4">156–157</a></p>
<p>synchronous tasks, <a href="#text_part0021.html_page_191"
class="calibre4">191</a></p>
<p>syntactic abstraction, <a href="#text_part0018.html_page_162"
class="calibre4">162</a>, <a href="#text_part0018.html_page_163"
class="calibre4">163</a></p>
<p>syntax, <a href="#text_part0014.html_page_36"
class="calibre4">36</a></p>
<p>Java interop, <a href="#text_part0024.html_page_258"
class="calibre4">258–259</a></p>
<h3 class="h2"><strong>T</strong></h3>
<p>tail call optimization, <a href="#text_part0016.html_page_102"
class="calibre4">102</a></p>
<p>tail (of a sequence), <a href="#text_part0014.html_page_65"
class="calibre4">65</a></p>
<p><span class="literal1">take</span> function, <a
href="#text_part0015.html_page_81" class="calibre4">81</a></p>
<p><span class="literal1">take-while</span> function, <a
href="#text_part0015.html_page_81" class="calibre4">81–82</a></p>
<p>telepath, <a href="#text_part0022.html_page_225"
class="calibre4">225</a></p>
<p><span class="literal1">thread-bound?</span> function, <a
href="#text_part0022.html_page_226" class="calibre4">226</a></p>
<p>threads, <a href="#text_part0021.html_page_191"
class="calibre4">191–193</a></p>
<p>delays, <a href="#text_part0021.html_page_198"
class="calibre4">198–199</a></p>
<p>futures, <a href="#text_part0021.html_page_196"
class="calibre4">196–198</a></p>
<p>nondeterministic programs, <a href="#text_part0021.html_page_193"
class="calibre4">193</a></p>
<p>promises, <a href="#text_part0021.html_page_200"
class="calibre4">200–202</a></p>
<p>spawning, <a href="#text_part0021.html_page_192"
class="calibre4">192</a></p>
<p><span class="literal1">Thread/sleep</span>, <a
href="#text_part0021.html_page_196" class="calibre4">196–197</a></p>
<p>Tick, The, <a href="#text_part0014.html_page_53"
class="calibre4">53</a></p>
<p>transactions, <a href="#text_part0022.html_page_218"
class="calibre4">218–221</a></p>
<p>troll, <a href="#text_part0022.html_page_225"
class="calibre4">225</a></p>
<p><span class="literal1">true</span> (value), <a
href="#text_part0014.html_page_39" class="calibre4">39</a></p>
<p>truthy values, <a href="#text_part0014.html_page_39"
class="calibre4">39</a></p>
<p>tuples, <a href="#text_part0016.html_page_119"
class="calibre4">119</a></p>
<p>types, <a href="#text_part0025.html_page_266"
class="calibre4">266</a></p>
<h3 class="h2"><strong>U</strong></h3>
<p><span class="literal1">unless</span> macro, <a
href="#text_part0019.html_page_171" class="calibre4">171</a></p>
<p>unquote splicing, <a href="#text_part0019.html_page_174"
class="calibre4">174–176</a></p>
<p>unquoting, <a href="#text_part0019.html_page_172"
class="calibre4">172</a>, <a href="#text_part0019.html_page_175"
class="calibre4">175</a></p>
<p><span class="literal1">use</span> function, <a
href="#text_part0017.html_page_136" class="calibre4">136–137</a></p>
<h3 class="h2"><strong>V</strong></h3>
<p>validators, <a href="#text_part0022.html_page_217"
class="calibre4">217</a></p>
<p>values, <a href="#text_part0022.html_page_210"
class="calibre4">210–211</a></p>
<p>vampire</p>
<p>data analysis, <a href="#text_part0015.html_page_93"
class="calibre4">93–96</a></p>
<p>food journal, <a href="#text_part0015.html_page_79"
class="calibre4">79–84</a></p>
<p><em>Vampire Diaries, The</em>, <a href="#text_part0015.html_page_71"
class="calibre4">71</a></p>
<p>variable assignment, <a href="#text_part0016.html_page_101"
class="calibre4">101</a></p>
<p>vars, <a href="#text_part0017.html_page_126"
class="calibre4">126–129</a>, <a href="#text_part0022.html_page_223"
class="calibre4">223–227</a></p>
<p>binding conveyance, <a href="#text_part0022.html_page_227"
class="calibre4">227</a></p>
<p>dynamic binding, <a href="#text_part0022.html_page_223"
class="calibre4">223–226</a></p>
<p>interning, <a href="#text_part0017.html_page_128"
class="calibre4">128</a></p>
<p>per-thread binding, <a href="#text_part0022.html_page_226"
class="calibre4">226–227</a></p>
<p>private, <a href="#text_part0017.html_page_132"
class="calibre4">132</a></p>
<p>reader form, <a href="#text_part0017.html_page_128"
class="calibre4">128</a></p>
<p>roots, <a href="#text_part0022.html_page_227"
class="calibre4">227</a></p>
<p><span id="text_part0029.html_page_300" class="calibre4"></span><span
class="literal1">vector</span> function, <a
href="#text_part0014.html_page_45" class="calibre4">45</a></p>
<p>vectors, <a href="#text_part0014.html_page_45"
class="calibre4">45</a></p>
<h3 class="h2"><strong>W</strong></h3>
<p>watches, <a href="#text_part0022.html_page_215"
class="calibre4">215–216</a></p>
<p>were-Simmons, <a href="#text_part0025.html_page_267"
class="calibre4">267</a></p>
<p><span class="literal1">when</span> operator, <a
href="#text_part0014.html_page_38" class="calibre4">38–39</a>, <a
href="#text_part0019.html_page_166" class="calibre4">166</a>, <a
href="#text_part0019.html_page_170" class="calibre4">170</a></p>
<p>whitespace (to separate operands), <a
href="#text_part0014.html_page_36" class="calibre4">36</a></p>
<p><span class="literal1">with-open</span>, <a
href="#text_part0024.html_page_264" class="calibre4">264</a></p>
<p><span class="literal1">with-redefs</span>, <a
href="#text_part0022.html_page_227" class="calibre4">227</a></p>
<h3 class="h2"><strong>Y</strong></h3>
<p>yak butter, <a href="#text_part0021.html_page_200"
class="calibre4">200–202</a></p>
<p><span id="text_part0030.html"></span></p>
<h2 class="h1"
id="text_part0030.html_footnote"><strong>Footnote</strong></h2>
<h3 class="h2" id="text_part0030.html_footnotelev1sec1"><strong>2 How to
Use Emacs, an Excellent Clojure Editor</strong></h3>
<p><a href="#text_part0012.html_fn_01" id="text_part0030.html_fn01"
class="calibre4">1.</a> <em><a
href="http://www.gnu.org/software/emacs/manual/html_node/emacs/Minor-Modes.html"
class="calibre4">http://www.gnu.org/software/emacs/manual/html_node/emacs/Minor-Modes.html</a></em>.</p>
<p><span id="text_part0031.html"></span></p>
<div class="sidebar">
<p><span id="text_part0031.html_page_301" class="calibre17"></span><span
id="text_part0031.html_back01"
class="calibre17"></span><strong>Resources</strong></p>
<p>Visit <em><a href="https://www.nostarch.com/clojure/"
class="calibre16">https://www.nostarch.com/clojure/</a></em> for
resources, errata, and more information.</p>
</div>
<div class="box">
<p><em>More no-nonsense books from</em> <img src="images_00074.jpeg"
class="calibre3" alt="image" /> <strong>NO STARCH PRESS</strong></p>
<div class="image1">
<img src="images_00075.jpeg" class="calibre3" alt="image" />
</div>
<p><strong>LAND OF LISP</strong></p>
<p><strong>Learn to Program in Lisp, One Game at a Time!</strong></p>
<p><em>by</em> <span class="small">CONRAD BARSKI, M.D.</span><br />
<span class="small">OCTOBER 2010, 504 PP., $49.95</span><br />
<span class="small">ISBN 978-1-59327-281-4</span></p>
<div class="image1">
<img src="images_00076.jpeg" class="calibre3" alt="image" />
</div>
<p><strong>LEARN YOU A HASKELL FOR GREAT GOOD!</strong></p>
<p><strong>A Beginner’s Guide</strong></p>
<p><em>by</em> <span class="small">MIRAN LIPOVAČA</span><br />
<span class="small">APRIL 2011, 400 PP., $44.95</span><br />
<span class="small">ISBN 978-1-59327-283-8</span></p>
<div class="image1">
<img src="images_00077.jpeg" class="calibre3" alt="image" />
</div>
<p><strong>LEARN YOU SOME ERLANG FOR GREAT GOOD!</strong></p>
<p><strong>A Beginner’s Guide</strong></p>
<p><em>by</em> <span class="small">FRED HÉBERT</span><br />
<span class="small">JANUARY 2013, 624 PP., $49.95</span><br />
<span class="small">ISBN 978-1-59327-435-1</span></p>
<div class="image1">
<img src="images_00078.jpeg" class="calibre3" alt="image" />
</div>
<p><strong>ELOQUENT JAVASCRIPT, 2ND EDITION</strong></p>
<p><strong>A Modern Introduction to Programming</strong></p>
<p><em>by</em> <span class="small">MARIJN HAVERBEKE</span><br />
<span class="small">DECEMBER 2014, 472 PP., $39.95</span><br />
<span class="small">ISBN 978-1-59327-584-6</span></p>
<div class="image1">
<img src="images_00079.jpeg" class="calibre3" alt="image" />
</div>
<p><strong>AUTOMATE THE BORING STUFF WITH PYTHON</strong></p>
<p><strong>Practical Programming for Total Beginners</strong></p>
<p><em>by</em> <span class="small">AL SWEIGART</span><br />
<span class="small">APRIL 2015, 504 PP., $29.95</span><br />
<span class="small">ISBN 978-1-59327-599-0</span></p>
<div class="image1">
<img src="images_00080.jpeg" class="calibre3" alt="image" />
</div>
<p><strong>THE ART OF R PROGRAMMING</strong></p>
<p><strong>A Tour of Statistical Software Design</strong></p>
<p><em>by</em> <span class="small">NORMAN MATLOFF</span><br />
<span class="small">OCTOBER 2011, 400 PP., $39.95</span><br />
<span class="small">ISBN 978-1-59327-384-2</span></p>
<div class="sidebar">
<p><span class="small"><strong>PHONE:</strong></span></p>
<p><span class="small">800.420.7240 OR</span></p>
<p><span class="small">415.863.9900</span></p>
<p><span class="small"><strong>EMAIL:</strong></span></p>
<p><span class="small"><a href="mailto:SALES@NOSTARCH.COM"
class="calibre16">SALES@NOSTARCH.COM</a></span></p>
<p><strong><span class="small">WEB:</span></strong></p>
<p><span class="small"><a href="http://WWW.NOSTARCH.COM"
class="calibre16">WWW.NOSTARCH.COM</a></span></p>
</div>
</div>
<p><span id="text_part0032_split_000.html"></span></p>
<p><span id="text_part0032_split_000.html_page_302"
class="calibre4"></span><span class="small"><strong>Shelve in:
Programming Languages/Clojure</strong></span></p>
<p><span id="text_part0032_split_001.html"></span></p>
<h2 class="h2a" id="text_part0032_split_001.html_back02"><strong><span
class="red">Join the Ranks of Noble Clojurists</span></strong></h2>
<p><strong>For weeks, months—nay!—from the very moment you were born,
you’ve felt it calling to you. At long last you’ll be united with the
programming language you’ve been longing for: Clojure!</strong></p>
<p>As a Lisp-style functional programming language, Clojure lets you
write robust and elegant code, and because it runs on the Java Virtual
Machine, you can take advantage of the vast Java ecosystem.
<em><strong>Clojure for the Brave and True</strong></em> offers a
“dessert-first” approach: you’ll start playing with real programs
immediately, as you steadily acclimate to the abstract but powerful
features of Lisp and functional programming. Inside you’ll find an
offbeat, practical guide to Clojure, filled with quirky sample programs
that catch cheese thieves and track glittery vampires.</p>
<h3 class="h2"
id="text_part0032_split_001.html_back02lev1sec1"><strong>LEARN HOW
TO</strong></h3>
<p>• Wield Clojure’s core functions</p>
<p>• Use Emacs for Clojure development</p>
<p>• Write macros to modify Clojure itself</p>
<p>• Use Clojure’s tools to simplify concurrency and parallel
programming</p>
<p><em><strong>Clojure for the Brave and True</strong></em> assumes no
prior experience with Clojure, the Java Virtual Machine, or functional
programming. Are you ready, brave reader, to meet your true destiny?
Grab your best pair of parentheses—you’re about to embark on an epic
journey into the world of Clojure!</p>
<h3 class="h2"
id="text_part0032_split_001.html_back02lev1sec2"><strong>ABOUT THE
AUTHOR</strong></h3>
<p><strong>Daniel Higginbotham</strong> has been a professional
programmer for 11 years, half of that at McKinsey &amp; Company, where
he used Clojure to build mobile and web applications. He has also
contributed to the curriculum for ClojureBridge, an organization that
offers free, beginner-friendly Clojure workshops for women. Daniel blogs
about life and programming at <em><a
href="http://flyingmachinestudios.com/"
class="calibre4">http://flyingmachinestudios.com/</a></em>, and can be
found on Twitter, @nonrecursive. He lives in Durham, North Carolina,
with his wife and four cats.</p>
<p><strong>COVERS CLOJURE 1.7</strong></p>
<p><strong>REQUIRES JAVA 1.6 OR LATER</strong></p>
<div class="image">
<img src="images_00081.jpeg" class="calibre3" alt="image" />
</div>
<p><strong><a href="http://www.nostarch.com"
class="calibre4">www.nostarch.com</a></strong></p>
<p><em><strong>THE FINEST IN</strong></em><br />
<em><strong>GEEK ENTERTAINMENT™</strong></em></p>
